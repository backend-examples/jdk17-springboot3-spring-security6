/*
 Navicat Premium Data Transfer

 Source Server         : 云服务器
 Source Server Type    : MySQL
 Source Server Version : 50741
 Source Host           : 101.35.44.70:3306
 Source Schema         : authorization

 Target Server Type    : MySQL
 Target Server Version : 50741
 File Encoding         : 65001

 Date: 10/09/2023 16:17:49
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for tb_app
-- ----------------------------
DROP TABLE IF EXISTS `tb_app`;
CREATE TABLE `tb_app`  (
  `appId` int(12) NOT NULL AUTO_INCREMENT COMMENT '应用id',
  `appName` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '应用名称',
  `appDescription` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '应用描述',
  `appRedirectUrl` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '应用授权回调域',
  `audited` smallint(2) NOT NULL COMMENT '审核状态(0待审核，1审核通过，2审核未通过)',
  `rejectRemark` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '审核拒绝信息',
  `delFlag` smallint(2) NOT NULL COMMENT '删除状态(0未删除，1已删除)',
  `createTime` datetime NOT NULL COMMENT '应用创建时间',
  `updateTime` datetime NOT NULL COMMENT '应用更新时间',
  PRIMARY KEY (`appId`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 23 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of tb_app
-- ----------------------------
INSERT INTO `tb_app` VALUES (4, '页', '测试1', 'www.baidu.com', 0, NULL, 0, '2023-01-29 11:25:30', '2023-01-31 09:54:37');
INSERT INTO `tb_app` VALUES (5, '书', NULL, 'http://localhost:8080', 0, NULL, 0, '2023-01-29 11:56:51', '2023-01-29 11:56:51');
INSERT INTO `tb_app` VALUES (6, '书', NULL, 'http://localhost:8080', 0, NULL, 0, '2023-01-29 14:20:47', '2023-01-31 09:55:43');
INSERT INTO `tb_app` VALUES (8, '1', NULL, 'http://localhost:8080', 0, NULL, 0, '2023-01-31 18:01:41', '2023-01-31 18:01:41');
INSERT INTO `tb_app` VALUES (9, '2', NULL, 'http://localhost:8080', 0, NULL, 0, '2023-01-31 18:01:48', '2023-01-31 18:01:48');
INSERT INTO `tb_app` VALUES (10, '3', NULL, 'http://localhost:8080', 0, NULL, 0, '2023-01-31 18:01:53', '2023-01-31 18:01:53');
INSERT INTO `tb_app` VALUES (11, '4', NULL, 'http://localhost:8080', 0, NULL, 0, '2023-01-31 18:01:57', '2023-01-31 18:01:57');
INSERT INTO `tb_app` VALUES (12, '5', NULL, 'http://localhost:8080', 0, NULL, 0, '2023-01-31 18:02:01', '2023-01-31 18:02:01');
INSERT INTO `tb_app` VALUES (13, '6', NULL, 'http://localhost:8080', 0, NULL, 0, '2023-01-31 18:02:05', '2023-01-31 18:02:05');
INSERT INTO `tb_app` VALUES (14, '7', NULL, 'http://localhost:8080', 0, NULL, 0, '2023-01-31 18:02:09', '2023-01-31 18:02:09');
INSERT INTO `tb_app` VALUES (15, '8', NULL, 'http://localhost:8080', 0, NULL, 0, '2023-01-31 18:02:14', '2023-01-31 18:02:14');
INSERT INTO `tb_app` VALUES (16, '9', NULL, 'http://localhost:8080', 0, NULL, 0, '2023-01-31 18:02:18', '2023-01-31 18:02:18');
INSERT INTO `tb_app` VALUES (17, '10', NULL, 'http://localhost:8080', 0, NULL, 0, '2023-01-31 18:02:27', '2023-01-31 18:02:27');
INSERT INTO `tb_app` VALUES (18, '11', NULL, 'http://localhost:8080', 0, NULL, 0, '2023-01-31 18:02:31', '2023-01-31 18:02:31');
INSERT INTO `tb_app` VALUES (19, '12', NULL, 'http://localhost:8080', 0, NULL, 0, '2023-01-31 18:02:35', '2023-01-31 18:02:35');
INSERT INTO `tb_app` VALUES (20, '13', NULL, 'http://localhost:8080', 0, NULL, 0, '2023-01-31 18:02:40', '2023-01-31 18:02:40');
INSERT INTO `tb_app` VALUES (21, '14', NULL, 'http://localhost:8080', 0, NULL, 0, '2023-01-31 18:02:44', '2023-01-31 18:02:44');
INSERT INTO `tb_app` VALUES (22, '15', NULL, 'http://localhost:8080', 0, NULL, 0, '2023-01-31 18:02:47', '2023-01-31 18:02:47');

-- ----------------------------
-- Table structure for tb_app_client
-- ----------------------------
DROP TABLE IF EXISTS `tb_app_client`;
CREATE TABLE `tb_app_client`  (
  `clientId` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '客户端id',
  `appId` int(12) NOT NULL COMMENT '应用id',
  `delFlag` smallint(2) NOT NULL COMMENT '删除状态(0为未删除，1为已删除)',
  `createTime` datetime NOT NULL COMMENT '创建日期',
  `updateTime` datetime NOT NULL COMMENT '更新日期',
  PRIMARY KEY (`clientId`, `appId`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of tb_app_client
-- ----------------------------

-- ----------------------------
-- Table structure for tb_article
-- ----------------------------
DROP TABLE IF EXISTS `tb_article`;
CREATE TABLE `tb_article`  (
  `articleId` int(12) NOT NULL AUTO_INCREMENT COMMENT '文章id',
  `title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '标题',
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '内容',
  `description` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '描述',
  `type` smallint(2) NOT NULL COMMENT '文章类型(0:markdown,1:富文本)',
  `coverId` int(12) NULL DEFAULT NULL COMMENT '封面图片',
  `categoryId` int(12) NOT NULL COMMENT '类别id',
  `userId` int(12) NOT NULL COMMENT '用户id',
  `audited` smallint(2) NOT NULL COMMENT '审核(0:草稿，1：审核中，2：审核通过，3：未通过审核)',
  `createTime` datetime NOT NULL COMMENT '创建时间',
  `updateTime` datetime NOT NULL COMMENT '更新时间',
  `delFlag` smallint(2) NOT NULL COMMENT '删除(0未删除，1已删除)',
  PRIMARY KEY (`articleId`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 22 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tb_article
-- ----------------------------
INSERT INTO `tb_article` VALUES (1, '小白学习nginx（一）--docker创建nginx容器', '## 拉取nginx镜像\n```\ndocker pull nginx\n```\n## 创建nginx容器\n```\ndocker run --name nginx -d \\\n-p 80:80 -p 443:443 \\\n-v /usr/local/docker/nginx/html:/usr/share/nginx/html:ro \\\n-v /usr/local/docker/nginx/logs:/var/log/nginx/:rw \\\n-v /usr/local/docker/nginx/config/conf.d:/etc/nginx/conf.d:rw \\\n-v /usr/local/docker/nginx/cert:/etc/nginx/ssl \\\n-d nginx\n```\n>注意点：\n>* 我并没有在/usr/local/docker/nginx目录下创建html、logs、和/config/conf.d目录,自动映射的\n\n## 进入nginx容器\n```\ndocker exec -it nginx bash\n```\n进入/etc/nginx，并查看nginx.conf配置文件，这个文件是nignx的根本配置文件\n```\ncd /etc/nginx\n\ncat nginx.conf\n```\nnginx.conf内容如下：\n```\nuser  nginx;\nworker_processes  auto;\n\nerror_log  /var/log/nginx/error.log notice;\npid        /var/run/nginx.pid;\n\n\nevents {\n    worker_connections  1024;\n}\n\n\nhttp {\n    include       /etc/nginx/mime.types;\n    default_type  application/octet-stream;\n\n    log_format  main  \'$remote_addr - $remote_user [$time_local] \"$request\" \'\n                      \'$status $body_bytes_sent \"$http_referer\" \'\n                      \'\"$http_user_agent\" \"$http_x_forwarded_for\"\';\n\n    access_log  /var/log/nginx/access.log  main;\n\n    sendfile        on;\n    #tcp_nopush     on;\n\n    keepalive_timeout  65;\n\n    #gzip  on;\n\n    include /etc/nginx/conf.d/*.conf; # 看这里，引入/etc/nginx/conf.d目录下所有的以conf为扩展名的配置文件\n}\n```\n退出nginx容器，在宿主机映射的配置文件目录下新建default.conf并编辑\n```\ncd /usr/local/docker/nginx/config/conf.d\n\nvi default.conf\n```\ndefault.conf的内容如下:\n```\nserver {\n    listen       80;\n    server_name  _; # _代表当前宿主机的地址\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html; # nginx代理的根目录,被我映射到了/usr/local/docker/nginx/html，所以可以在此目录下新建index.html当作默认网页\n        index  index.html index.htm;\n    }\n    \n    #代理配置\n    location /business {\n        proxy_pass  http://business.app.com;\n    }\n    \n    #代理配置\n    location /user {\n        proxy_pass  http://user.app.com;\n    }\n}\n```\n进入/usr/local/docker/nginx/html，新建index.html\n```\ncd /usr/local/docker/nginx/html\n\nvi index.html\n```\nindex.html的内容如下：\n```\nwelcome to nginx\n```\n检查nginx配置文件是否正确\n```\n// docker检查\ndocker exec nginx nginx -t\n```\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/092dd294deb24f48a567a91a7a32d0db~tplv-k3u1fbpfcp-watermark.image?)\n文件内容没有问题。\n\n重新加载nginx的配置文件，相当于重启nginx容器\n\n```\n docker exec nginx nginx -s reload\n```\n访问nginx,端口为80\n```\n192.168.57.128\n```\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a42c99236c145969555381556bd303c~tplv-k3u1fbpfcp-watermark.image?)', '小白学习nginx（一）--docker创建nginx容器', 0, 5, 2, 9, 0, '2023-06-09 13:29:18', '2023-06-09 13:29:18', 0);
INSERT INTO `tb_article` VALUES (2, '小白学习vue服务端渲染(一)--从零搭建vue服务端架构', '# 服务端渲染\n\n其实Vue的SSR（其实React也是一样）并不是传统的服务端渲染，而是一种全新的架构：**同构渲染**。那什么是传统的服务端渲染？又什么是同构渲染？\n\n## 传统的服务端渲染\n传统的服务端渲染这里用大白话说就是每一张的页面全部都是真实的。哎？什么是“每一张的页面全部都是真实的”？\n这里我们先了解一下SPA（Single Page Application），也就是传统的Vue-cli搭建出来的项目，真正的html文件只有一个，其他页面的所有内容全部都是js来呈现的。\n所以传统服务端渲染“每一张的页面全部都是真实的”这里就很好理解了，所有的页面切换都需要请求服务器，服务器吐出真正的html页面交由浏览器呈现。\n\n## 同构渲染\n同构渲染是一种糅合的传统的服务端渲染和SPA呈现方式的全新架构，真正的html页面，其实也是只有一张，当客户端去请求服务器时，服务器开始在本地启动SPA渲染出一张全新的页面，之后交给浏览器呈现。这样就能做到只有一张html但是能产生无数多的“真实页面 ”。但客户端交互怎么办？不要担心，服务端在本地启动SPA渲染时，已经将相关js的引用嵌入到了发送给客户端的html中，所以一旦将页面交给浏览器后，之后全部的操作，又回归到了SPA！\n也就是说，只有打开网站的首屏（注意不是首页）是一张真实页面，之后其他的所有页面，又全是交由js呈现的！\n\n# 使用场景\n**技术层面：**\n-   更快的首屏渲染速度\n-   更好的 SEO\n\n**业务层面：**\n-   不适合管理系统\n-   适合门户资讯类网站，例如企业官网、知乎、简书等\n-   适合移动网站\n# 如何实现 Vue SSR\n实现vue的服务端有两种方案：\n\n 1、基于 Vue SSR 官方文档提供的解决方案\n \n 2、使用Nuxt.js 开发框架\n \n 本博客使用的第一种方案。之所以选择自己手动搭建，是想要更深入的了解vue服务端渲染的原理。以及可以更灵活的扩展和优化项目。\n \n# 渐进式实现vue-ssr\n \n## 渲染一个 Vue 实例\n>目的：了解下如何使用 Vue SSR 将一个 Vue 实例渲染为 HTML 字符串\n\n首先，我们来学习一下服务端渲染中最基础的工作：**模板渲染**。 简单来说就是如何在服务端使用 Vue 的方式解析替换字符串。\n\n- 准备工作\n```script\n# 创建文件夹，进入创建的文件夹内，初始化包管理文件 package.json\nnpm init -y # -y 表示快速初始，不经过一些问题的回答，直接走默认回答\n# 安装 vue 及 vue-server-renderer 依赖包，这里使用的vue2\nnpm install vue@2 vue-server-renderer --save\n```\n- 根目录下创建 `server.js` 文件，将 Vue 实例渲染成 HTML 字符串\n```javascript\n// 第 1 步：创建一个 Vue 实例\nconst Vue = require(\'vue\')\nconst app = new Vue({\n    template:`\n        <div id=\"app\">\n            <h1>{{ message }}</h1>\n        </div>`,\n    data:{\n        message:\'vue实例\'\n    }\n})\n\n// 第 2 步：创建一个 renderer 渲染器\nconst renderer = require(\'vue-server-renderer\').createRenderer()\n\n// 第 3 步：将 Vue 实例渲染为 HTML\nrenderer.renderToString(app, (err, html) => {\n    if (err) throw err\n    // html 就是渲染出来的结果字符串\n    console.log(html); // <div id=\"app\" data-server-rendered=\"true\"><h1>拉勾教育</h1></div>\n})\n\n/* 在 2.5.0+，如果没有传入回调函数，则会返回 Promise：\nrenderer.renderToString(app)\n    .then((html) => {\n        console.log(html);\n        })\n    .catch((err) => {\n        console.error(err);\n        });\n*/\n```\n- 使用 node 运行 `server.js`\n```script\nnode server.js\n```\n执行结果如下:\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15a105c142bd4ad2b1c5a9b8b8221f69~tplv-k3u1fbpfcp-watermark.image?)\n\n通过渲染结果可以看到模板根节点中添加了`data-server-rendered=\"true\"`字段，主要用于将来客户端渲染激活接管的一个入口\n\n## 与服务器集成\n\n在 Node.js 服务器中使用时相当简单直接。我使用的是 [Express](https://expressjs.com/zh-cn/)，具体使用如下：\n- 首先，安装 Express 到项目中\n```script\nnpm install express --save\n```\n- 然后，使用 Express 创建一个基本的 Web 服务,在 Web 服务中渲染 Vue 实例\n修改之后的`server.js`如下:\n```javascript\n// server.js\nconst express = require(\'express\')\nconst server = express()\nconst Vue = require(\'vue\')\nconst renderer = require(\'vue-server-renderer\').createRenderer()\n\n// 添加路由,访问根路由\nserver.get(\'/\',(req, res)=>{\n    const app = new Vue({\n        template:`\n            <div id=\"app\">\n                <h1>{{ message }}</h1>\n            </div>`,\n        data:{\n            message:\'vue实例\'\n        }\n    })\n    renderer.renderToString( app, (err,html) => {\n        if(err){\n            res.status(500).end(err)\n        }\n        // res.end(html)\n        // 解决乱码:添加 html响应头或使用 meta 设置编码格式\n        res.setHeader(\'Content-Type\',\'text/html; charset=utf-8\')\n        res.end(`\n        <!DOCTYPE html>\n            <html>\n            <head>\n                <meta charset=\"utf-8\">\n                <meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\">\n                <meta name=\"renderer\" content=\"webkit\" />\n                <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n            </head>\n            <body>\n             ${html}\n            </body>\n        </html>`)\n    })\n})\nserver.listen(3000, ()=>{\n    console.log(\'server runing at port 3000\');\n})\n```\n- 启动 Web 服务，nodemon 启动服务，可以实时监听，热更新：\n```script\nnode server.js\n```\n运行结果如下所示：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ebe0532aa2b4b849e522b2c174e6196~tplv-k3u1fbpfcp-watermark.image?)\n\n## 使用一个页面模板\n\n将上面进一步优化，将模板提取为一个单独的页面\n- 根目录下创建一个页面模板 index.template.html，内容如下：\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n     <!-- 使用三花括号(triple-mustache)进行 HTML 不转义插值(non-HTML-escaped interpolation) -->\n    {{{ meta }}}\n     <!-- 使用双花括号(double-mustache)进行 HTML 转义插值(HTML-escaped interpolation) -->\n    <title>{{ title }}</title>\n</head>\n<body>\n    <!--vue-ssr-outlet-->\n</body>\n</html>\n```\n>注意：上面的 注释语句`<!--vue-ssr-outlet-->`，是固定语法。会作为 Vue 实例 转换的 html 字符串存放的位置，类似于占位。vue-ssr-outlet 前后不可以有空格。\n\n- 在 `server.js` 中，创建 renderer 渲染器时，添加一个 template 参数，指定模板。修改后的`server.js`如下：\n```\n/**\n* 服务端入口，仅运行于服务端 \n*/\n// 创建一个 express 的 server 实例\nconst express = require(\'express\')\nconst server = express()\nconst fs = require(\'fs\')\nconst { createBundleRenderer } = require(\'vue-server-renderer\')\n\nconst renderer = require(\'vue-server-renderer\').createRenderer({\n    // 添加template参数，读取文件是二进制形式，需要转码\n    template: fs.readFileSync(\'./index.template.html\',\'utf-8\')\n})\n\n// 添加路由\nserver.get(\'/\',(req, res)=>{\n    const app = new Vue({\n        template:`\n            <div id=\"app\">\n                <h1>{{ message }}</h1>\n                <h2>客户端动态交互</h2>\n                <div>\n                    <input v-model = \"message\">\n                </div>\n                <div>\n                    <button @click=\"onClick\">按钮</button>\n                </div>\n            </div>`,\n        data:{\n            message:\'vue ssr\'\n        },\n        methods:{\n            onClick(){\n                console.log(\'hello world\');\n            }\n        }\n    })\n    \n    renderer.renderToString( app, {\n        // 在模板中使用外部数据(renderToString的第二个参数，可选)\n        // 页面 title 将会是 \"Hello\"\n        title:\'Hello\',\n        // meta 标签也会注入\n        meta: `<meta name=\"description\" content=\"vue实例\">`\n    }, (err,html) => {\n        if(err){\n            res.status(500).end(\'Internal Server Error\')\n        }\n        // 解决乱码:添加 html响应头或使用 meta 设置编码格式\n        res.setHeader(\'Content-Type\',\'text/html; charset=utf-8\')\n        // html 将是注入应用程序内容的完整页面\n        res.end(html)\n    })\n})\n\nserver.listen(3000, () => {\n    console.log(\'server running at port 3000\');\n})\n```\n\n运行`server.js`后如下图：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83349166d0cf4fce8fdfc716b79e6a1b~tplv-k3u1fbpfcp-watermark.image?)\n\n可以看到，可以通过传入一个\"渲染上下文对象\"，作为 renderToString 函数的第二个参数，来提供插值数据，插入到模板中，但是服务端渲染只是把 vue 实例处理成纯静态的HTML字符串发送给客户端，在 vue 实例中，需要客户端动态交互的功能，本身并没有提供，例如`<input v-model = \"message\">` input 标签通过 v-model 绑定数据 message，当input 发生改变的时候，message 也会改变，所有绑定message的位置也随之变化，通过测试发现改变 input 内容改变后 message 值并未发生变化。\n\n>原因：服务端渲染出来的文件并没有客户端 js 相关内容，所以目前没有客户端交互的能力，如何实现呢？下面将详细介绍\n\n## 构建同构渲染 - [构建流程](https://ssr.vuejs.org/zh/guide/structure.html#%E9%81%BF%E5%85%8D%E7%8A%B6%E6%80%81%E5%8D%95%E4%BE%8B)\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6fdfdac59ba4351a868233492bc4400~tplv-k3u1fbpfcp-watermark.image?)\n\n>如上图：左边为应用的源代码 `source`，中间为 `Webpack` ，右边为 `NodeServer` 服务端。\n\n在我们的应用当中，目前只有 `server entry` (服务端入口)来处理服务端渲染，如果我们希望服务端渲染的内容拥有客户端动态交互的能力的话，还需要有一个客户端脚本的入口`client entry`，它专门来处理客户端渲染，也就是去接管服务端渲染的内容把它激活为一个动态页面。\n\n有了这两个入口之后需要 `Webpack` 对它们进行打包编译构建：对于 `server entry` 最终要打包为一个 `ServerBundle` 来做服务端渲染，同样的对于客户端入口 `client entry` 来说最终要打包为一个 `ClientBundle` 来接管服务端渲染好的静态页面对它进行激活。\n\n这就是同构应用实现的一个基本流程。\n\n## 构建同构渲染 - 源码结构\n\n我们需要使用 `webpack` 来打包我们的 `Vue` 应用程序。事实上，我们可能需要在服务器上使用 `webpack` 打包 `Vue` 应用程序，因为：\n\n- 通常 `Vue` 应用程序是由 `webpack` 和 `vue-loader` 构建，并且许多 `webpack` 特定功能不能直接在 `Node.js` 中运行（例如通过 `file-loader` 导入文件，通过 `css-loader` 导入 CSS）。\n- 尽管 `Node.js` 最新版本能够完全支持 ES2015 特性，我们还是需要转译客户端代码以适应老版浏览器。这也会涉及到构建步骤。\n\n所以基本看法是，对于客户端应用程序和服务器应用程序，我们都要使用 `webpack` 打包成服务器需要的`「服务器 bundle」`，然后用于服务器端渲染(SSR)，而`「客户端 bundle」`会发送给浏览器，用于混合静态标记。\n\n现在我们正在使用 `webpack` 来处理服务器和客户端的应用程序，大部分源码可以使用通用方式编写，可以使用 `webpack` 支持的所有功能。同时，在编写通用代码时，有一些[事项](https://ssr.vuejs.org/zh/guide/universal.html#%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94)要牢记在心。\n\n项目中src目录的基本结构\n\nsrc\\\n├── pages\\\n│ ├── Home.vue\\\n│ ├── About.vue\\\n│ └── Post.vue\\\n├── App.vue # 根组件\\\n├── app.js # 通用 entry(universal entry)\\\n├── entry-client.js # 仅运行于浏览器\\\n└── entry-server.js # 仅运行于服务器\n\n### App.vue\n```javascript\n<template>\n  <div id=\"app\">\n    <h1>{{ message }}</h1>\n    <h2>客户端动态交互</h2>\n    <div>\n      <input v-model=\"message\">\n    </div>\n    <div>\n      <button @click=\"onClick\">点击测试</button>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: \'App\',\n  data () {\n    return {\n      message: \'vue ssr\'\n    }\n  },\n  methods: {\n    onClick () {\n      console.log(\'Hello World!\')\n    }\n  }\n}\n</script>\n```\n\n### app.js\n\n`app.js` 是我们应用程序的「通用 entry」。在纯客户端应用程序中，我们将在此文件中创建根 Vue 实例，并直接挂载到 DOM。但是，对于服务器端渲染(SSR)，责任就会转移到纯客户端 `client-entry.js` 文件。app.js 简单地使用 export 导出一个 `createApp` 函数。\n```javascript\nimport Vue from \'vue\'\nimport App from \'./App.vue\'\n\n// 导出一个工厂函数，用于创建新的\n// 应用程序、router 和 store 实例\nexport function createApp() {\n    const app = new Vue({\n        // 根实例简单的渲染应用程序组件。\n        render: h => h(App)\n    })\n    // 后期还有导出 router 、store实例\n    return { app }\n}\n```\n\n>需要注意的是：**避免状态单例**。状态单例就是全局共用一个Vue实例。\n\n编写纯客户端 (client-only) 代码时，我们习惯于每次在新的上下文中对代码进行取值。但是 Node.js 服务器是一个长期运行的进程。当我们的代码进入该进程时，它将进行一次取值并留存在内存中。这意味着如果创建一个单例对象，它将在每个传入的请求之间共享。\n\n如基本示例所示，我们为每个请求创建一个新的根 Vue 实例。这与每个用户在自己的浏览器中使用新应用程序的实例类似。如果我们在多个请求之间使用一个共享的实例，很容易导致交叉请求状态污染 (cross-request state pollution)。\n\n因此，我们不应该直接创建一个应用程序实例，而是应该暴露一个可以重复执行的工厂函数，为每个请求创建新的应用程序、router 和 store 实例。\n\n### entry-client.js\n客户端 entry 只需创建应用程序，并且将其挂载到 DOM 中\n```javascript\n// 客户端入口\nimport { createApp } from \'./app\'\n\n// 客户端特定引导逻辑……\n\nconst { app } = createApp()\n\n// 这里假定 App.vue 模板中根元素具有 `id=\"app\"`\napp.$mount(\'#app\')\n```\n### entry-server.js\n服务器 entry 使用 default export 导出函数，并在每次渲染中重复调用此函数。此时，除了创建和返回应用程序实例之外，它不会做太多事情， 但是稍后我们将在此执行服务器端路由匹配 (server-side route matching) 和数据预取逻辑 (data pre-fetching logic)\n\n```javascript\n// 服务端入口\nimport { createApp } from \'./app\'\n\nexport default context => {\n  const { app } = createApp()\n  return app\n}\n```\n## 构建同构渲染 - 构建配置\n### 安装依赖\n1.  安装生产依赖\n```script\nnpm i vue@2 vue-server-renderer express cross-env\n```\n包                   | 说明                                                               |\n| ------------------- | ---------------------------------------------------------------- |\n| vue                 | Vue.js 核心库                                                       |\n| vue-server-renderer | Vue 服务端渲染工具                                                      |\n| express             | 基于 Node 的 Web 服务框架                                               |\n| cross-env           | 通过 npm scripts 设置跨平台环境变量,区分不同的打包环境，使用process.env.NODE_ENV获取当前的环境\n\n2.  安装开发依赖\n```script\nnpm i -D webpack@4 webpack-cli webpack-merge webpack-node-externals @babel/core@7 @babel/plugin-transform-runtime @babel/preset-env babel-loader css-loader url-loader file-loader rimraf vue-loader@15 vue-template-compiler friendly-errors-webpack-plugin\n```\n包                                                                            | 说明                         |\n| ---------------------------------------------------------------------------- | -------------------------- |\n| webpack                                                                      | webpack 核心包                |\n| webpack-cli                                                                  | ebpack 的命令行工具              |\n| webpack-merge                                                                | webpack 配置信息合并工具           |\n| webpack-node-externals                                                       | 排除 webpack 中的 Node 模块      |\n| rimraf                                                                       | 基于 Node 封装的一个跨平台 rm -rf 工具 |\n| friendly-errors-webpack-plugin                                               | 友好的 webpack 错误提示           |\n| @babel/core、@babel/plugin-transform-runtime、 @babel/preset-env、 babel-loader | Babel 相关工具（ES6转ES5）        |\n| vue-loader、 vue-template-compiler                                            | 处理 .vue 资源                 |\n| file-loader                                                                  | 处理字体资源                     |\n| css-loader                                                                   | 处理 CSS 资源                  |\n| url-loader                                                                   | 处理图片资源\n\n### 配置文件及打包命令\n- 初始化 webpack 打包配置文件，根目录下新建build文件夹。\n```\nbuild\n├── webpack.base.config.js   # 公共配置\n├── webpack.client.config.js # 客户端打包配置文件\n└── webpack.server.config.js # 服务端打包配置文件\n```\n`webpack.base.config.js`内容如下:\n```javascript\nconst path = require(\'path\')\nconst { VueLoaderPlugin } = require(\'vue-loader\')\nconst isProd = process.env.NODE_ENV === \'production\'\n\nfunction resolve(dir) {\n  return path.join(__dirname, \'..\', dir)\n}\n\nmodule.exports = {\n  mode: isProd ? \'production\' : \'development\',\n  context: path.resolve(__dirname, \'../\'),\n  devtool: isProd ? \'source-map\' : \'#cheap-module-source-map\',\n  output: {\n    path: path.resolve(__dirname, \'../dist\'),\n    publicPath: \'/dist/\',\n    // chunkhash 同属一个 chunk 中的文件修改了，文件名会发生变化\n    // contenthash 只有文件自己的内容变化了，文件名才会变化\n    filename: \'[name].[contenthash].js\',\n    // 此选项给打包后的非入口js文件命名，与 SplitChunksPlugin 配合使用\n    chunkFilename: \'[name].[contenthash].js\',\n  },\n  resolve: {\n    extensions: [\'.js\', \'.vue\', \'.json\', \'.css\'],\n    alias: {\n      public: resolve(\'public\'),\n      \'@\': resolve(\'src\'),\n    },\n  },\n  module: {\n    // https://juejin.cn/post/6844903689103081485\n    // 使用 `mini-css-extract-plugin` 插件打包的的 `server bundle` 会使用到 document。\n    // 由于 node 环境中不存在 document 对象，所以报错。\n    // 解决方案：样式相关的 loader 不要放在 `webpack.base.config.js` 文件\n    // 将其分拆到 `webpack.client.config.js` 和 `webpack.client.server.js` 文件\n    // 其中 `mini-css-extract-plugin` 插件要放在 `webpack.client.config.js` 文件配置。\n    rules: [\n      {\n        test: /\\.vue$/,\n        loader: \'vue-loader\',\n        options: {\n          compilerOptions: {\n            preserveWhitespace: false,\n          },\n        },\n      },\n      {\n        test: /\\.js$/,\n        loader: \'babel-loader\',\n        exclude: /node_modules/,\n      },\n      {\n        test: /\\.(png|svg|jpg|gif|ico)$/,\n        use: [\'file-loader\'],\n      },\n      {\n        test: /\\.(woff|eot|ttf)\\??.*$/,\n        loader: \'url-loader?name=fonts/[name].[md5:hash:hex:7].[ext]\',\n      },\n    ],\n  },\n  plugins: [new VueLoaderPlugin()],\n}\n```\n\n`webpack.client.config.js`内容如下：\n```javascript\nconst webpack = require(\'webpack\')\nconst base = require(\'./webpack.base.config\')\nconst CompressionPlugin = require(\'compression-webpack-plugin\')\nconst WebpackBar = require(\'webpackbar\')\nconst VueSSRClientPlugin = require(\'vue-server-renderer/client-plugin\')\nconst MiniCssExtractPlugin = require(\'mini-css-extract-plugin\')\nconst CssMinimizerPlugin = require(\'css-minimizer-webpack-plugin\')\n\nconst { merge } = require(\'webpack-merge\')\n\nconst isProd = process.env.NODE_ENV === \'production\'\n\nconst plugins = [\n    new webpack.DefinePlugin({\n        \'process.env.NODE_ENV\': JSON.stringify(\n            process.env.NODE_ENV || \'development\'\n        ),\n        \'process.env.VUE_ENV\': \'\"client\"\'\n    }),\n    new VueSSRClientPlugin(),\n    new MiniCssExtractPlugin({\n        filename: \'style.css\'\n    })\n]\n\nif (isProd) {\n    plugins.push(\n        // 开启 gzip 压缩 https://github.com/woai3c/node-blog/blob/master/doc/optimize.md\n        new CompressionPlugin(),\n        // 该插件会根据模块的相对路径生成一个四位数的hash作为模块id, 用于生产环境。\n        new webpack.HashedModuleIdsPlugin(),\n        new WebpackBar(),\n    )\n}\n\nconst config = {\n    entry: {\n        app: \'./src/entry-client.js\'\n    },\n    plugins,\n    optimization: {\n        runtimeChunk: {\n            name: \'manifest\'\n        },\n        splitChunks: {\n            cacheGroups: {\n                vendor: {\n                    name: \'chunk-vendors\',\n                    test: /[\\\\/]node_modules[\\\\/]/,\n                    priority: -10,\n                    chunks: \'initial\',\n                },\n                common: {\n                    name: \'chunk-common\',\n                    minChunks: 2,\n                    priority: -20,\n                    chunks: \'initial\',\n                    reuseExistingChunk: true\n                }\n            },\n        }\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.css$/,\n                use: [\n                    {\n                        loader: MiniCssExtractPlugin.loader,\n                        options: {\n                            // 解决 export \'default\' (imported as \'mod\') was not found\n                            // 启用 CommonJS 语法\n                            esModule: false,\n                        },\n                    },\n                    \'css-loader\'\n                ]\n            }\n        ]\n    },\n}\n\nif (isProd) {\n    // 压缩 css\n    config.optimization.minimizer = [\n        new CssMinimizerPlugin(),\n    ]\n}\n\nmodule.exports = merge(base, config)\n```\n\n`webpack.server.config.js`内容如下:\n```\nconst webpack = require(\'webpack\')\nconst base = require(\'./webpack.base.config\')\nconst nodeExternals = require(\'webpack-node-externals\') // Webpack allows you to define externals - modules that should not be bundled.\nconst VueSSRServerPlugin = require(\'vue-server-renderer/server-plugin\')\nconst WebpackBar = require(\'webpackbar\')\n\nconst { merge } = require(\'webpack-merge\')\n\nconst plugins = [\n    new webpack.DefinePlugin({\n        \'process.env.NODE_ENV\': JSON.stringify(process.env.NODE_ENV || \'development\'),\n        \'process.env.VUE_ENV\': \'\"server\"\'\n    }),\n    new VueSSRServerPlugin()\n]\n\nif (process.env.NODE_ENV == \'production\') {\n    plugins.push(\n        new WebpackBar()\n    )\n}\n\nmodule.exports = merge(base, {\n    target: \'node\',\n    devtool: \'#source-map\',\n    entry: \'./src/entry-server.js\',\n    output: {\n        filename: \'server-bundle.js\',\n        libraryTarget: \'commonjs2\'\n    },\n    externals: nodeExternals({\n        allowlist: /\\.css$/ // 防止将某些 import 的包(package)打包到 bundle 中，而是在运行时(runtime)再去从外部获取这些扩展依赖\n    }),\n    plugins,\n    module: {\n        rules: [\n            {\n                test: /\\.css$/,\n                use: [\n                    \'vue-style-loader\',\n                    \'css-loader\'\n                ]\n            }\n        ]\n    },\n})\n```\n\n- 在 package.json 的 scripts 中配置打包命令。\n```script\n\"build:client\": \"cross-env NODE_ENV=production webpack --config build/webpack.client.config.js\", \n\"build:server\": \"cross-env NODE_ENV=production webpack --config build/webpack.server.config.js\",\n\"build\": \"rimraf dist && npm run build:client && npm run build:server\",\n```\n\n- 运行测试\n\n客户端打包，命令执行及输出结果如下：\n```script\nnpm run build:client\n```\n\n服务端打包，命令执行及输出结果如下：\n```script\nnpm run build:server\n```\n\n同时打包客户端和服务端，命令执行及输出结果如下：\n```script\nnpm run build\n```\n\n### 启动应用\n\n修改`server.js`如下：\n```javascript\nconst Vue = require(\'vue\')\nconst express = require(\'express\')\nconst fs = require(\'fs\')\n\nconst serverBundle = require(\'./dist/vue-ssr-server-bundle.json\')\nconst template = fs.readFileSync(\'./index.template.html\', \'utf-8\')\n// 生成的客户端清单 (client manifest) \nconst clientManifest = require(\'./dist/vue-ssr-client-manifest.json\')\n// 创建一个渲染器\nconst renderer = require(\'vue-server-renderer\').createBundleRenderer(serverBundle, {\n    // 设置模板\n    template,\n    clientManifest\n})\n\n// 创建一个 experss 的 server 实例\nconst server = express()\n\n// 开头的路径，需要与 output 中设置的 publicPath 保持一致\nserver.use(\'/dist\', express.static(\'./dist\'))\n\n// 添加路由\nserver.get(\'/\', (req, res) => {\n    /**\n     * @param {Vue} \n     * @param {Object} \n     * @param {Function} \n     */\n    renderer.renderToString({\n        // 配置传到模板中的数据\n        title: \'vue ssr\',\n        meta: `<meta name=\"description\" content=\"vue-SSR\">`\n    }, (err, html) => {\n        if (err) {\n            return res.status(500).end(\'Internal Server Error\')\n        }\n        // html 就是渲染出来的结果字符串\n        // 添加响应头，解决编码问题\n        res.setHeader(\'Content-Type\', \'text/html; charset=utf8\')\n        // 结合了模板的完整内容\n        res.end(html)\n    })\n})\n\nserver.listen(3000, () => {\n    console.log(\'server running at port 3000\');\n})\n```\n\n### 解析渲染流程\n\n#### 服务端渲染\n\n服务端是如何渲染并输出 html 文件？服务端渲染主要结合 `serverBundle` 文件，具体的流程如下：\n\n从路由(server.js)这里着手，当客户端请求进来时候会被服务端路由匹配到，并调用 `renderer` 渲染器的 renderToString 方法进行渲染，把一个 vue 实例渲染成 html 字符串发送给客户端，但是在 `renderer.renderToString` 方法中并没有看到 vue 实例，那么这里的 vue 实例是怎么获取到的？\\\n通过代码可以看到 `renderer` 渲染器是通过 `createBundleRenderer` 方法创建出来，方法的第一个参数是 serverBundle 即打包生成的 `vue-ssr-server-bundle.json` 文件，文件的具体内容如下：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29c986d971694921acc039a7c3463b46~tplv-k3u1fbpfcp-watermark.image?)\n\n`server Bundle` 是 `Vue SSR` 构建的一个特殊的 JSON 文件,主要描述服务端打包的信息，包括如下内容：\n\n- entry：服务端打包的入口（`server-bundle.js` 在打包时候配置的文件名）\n- files：所有构建结果资源列表 （`server-bundle.js`: 即 `entry-server.js` 构建出来的结果文件）\n- maps：源代码 `source map` 信息，主要在开发调试中使用\n\n那么 `serverBundle` 是如何被使用的？\\\n`render` 在渲染的时候，会来加载 `serverbundle` 中的入口 `entry`，加载里面的代码并执行，就可以得到 `entry-server.js` 中创建的`vue`实例，把 `vue` 实例进行渲染，把渲染结果注入到 `template` 模板中（render的第二个参数），最后把数据发送到了客户端。\n\n#### 客户端渲染\n\n**客户端如何接管激活服务端渲染后的内容？**\\\n通过客户端构建打包出来的js脚本文件注入到页面（index.template.html）中，加载客户端脚本，但是我们在模板文件中并没有写这些代码，而是在构建结果输出到客户端页面中自动包含了这些脚本。\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19adaec9654e4401bbd7d11e03f019b5~tplv-k3u1fbpfcp-watermark.image?)\n\n**那么服务端是如何知道模板中需要引用加载客户端构建出来的结果呢？**\\\n通过代码可以看到，`createBundleRenderer` 中配置了参数 `clientManifest` 即 `vue-ssr-client-manifest.json` ，它是客户端打包资源的一个构建清单，清单中描述了客户端构建资源的相关信息，具体内容如下：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11c45c77d59f4768b4dfd68a93a93e8e~tplv-k3u1fbpfcp-watermark.image?)\n\n- publicPath：访问静态资源的根相对路径，与 webpack 配置中的 publicPath 一致\n- all：客户端打包所有构建出来的静态资源名称\n- initial：页面初始化时需要加载的文件，会在页面加载时配置到 preload(提前加载) 中（在渲染的时候，会把 initial 中的资源通过 script 方式自动的注入到模板页面的`<!--vue-ssr-outlet-->`之后）\n- async：页面跳转时需要加载的异步资源文件，会在页面加载时配置到 prefetch(预判加载) 中\n- modules：项目的各个模块包含的文件的序号，对应 all 中文件的顺序，moduleIdentifier 和 all 数组中文件的映射关系（modules对象是我们查找文件引用的重要数据）\n- modules作用：当客户端在运行的时候，假如加载了一个模块，这个模块他用到那些资源，vue就会根据信息去加载这些资源\n\n通过 script 方式引入到模板中的客户端打包的 app.js 文件是如何工作的？\n\n参考官方文档：[客户端激活 (client-side hydration)](https://ssr.vuejs.org/zh/guide/hydration.html)\n\n服务端渲染好内容想要拥有动态交互能力，需要客户端激活，接管服务端渲染好的内容，使其变为由 Vue 管理的动态 DOM 的过程。\n\n在 entry-client.js 中，我们用下面这行挂载(mount)应用程序：\n```javascript\n// 这里假定 App.vue template 根元素的 `id=\"app\"`\napp.$mount(\'#app\')\n```\n由于服务器已经渲染好了 HTML，客户端不会在进行重新渲染。而是需要”激活”这些静态的 HTML，然后使他们成为动态的（能够响应后续的数据变化），这个过程也称为“注水”。\n\n在浏览器中查看服务器渲染的输出结果，应用程序的根元素上添加了一个特殊的属性：\n```html\n<div id=\"app\" data-server-rendered=\"true\">\n```\ndata-server-rendered 特殊属性，让客户端 Vue 知道这部分 HTML 是由 Vue 在服务端渲染的，并且应该以激活模式进行挂载,而不是通过完整的渲染模式，需要注意在根组件的根元素中需要添加 `id=\"app\"`，否则应用程序将无法正常激活。\n\n在没有 data-server-rendered 属性的元素上，还可以向 $mount 函数的 hydrating 参数位置传入 true，来强制使用激活模式(hydration)：\n\n```javascript\n// 强制使用应用程序的激活模式\napp.$mount(\'#app\', true)\n```\n\n在开发模式下，Vue 将推断客户端生成的虚拟 DOM 树 (virtual DOM tree)，是否与从服务器渲染的 DOM 结构 (DOM structure) 匹配。如果匹配，就直接激活，无需重新渲染，如果无法匹配，它将退出混合模式，丢弃现有的 DOM 并从头开始渲染。**在生产模式下，此检测会被跳过，以避免性能损耗**。\n\n## 构建同构渲染 - 构建配置开发模式\n\n我们现在已经实现同构应用的基本功能了，但是这对于一个完整的应用来说还远远不够，例如如何处理同构应用中的路由、如何在服务端渲染中进行数据预取等功能。这些功能我们都会去对它进行实现，但是在实现它们之前我们先优化之前的代码，解决每次写完代码，都要重新打包构建，重新启动 Web 服务，让其变成一个编写完代码后自动构建并重启web服务器，自动刷新页面，下面我们来修改下：\n\n### 基本思路\n\n- 生产模式\n    - npm run build构建\n    - node server 启动应用\n\n- 开发模式\n    - 监视代码变动自动构建，热更新等功能\n    - node server 启动应用\n    \n#### 配置启动脚本`package.json`\n```script\n\"start\": \"cross-env NODE_ENV=production node server.js\",\n\"dev\": \"node server.js\"\n```\n\n#### 服务端配置 `server.js`\nrenderer 是通过打包的结果调用 createBundleRenderer 创建出来的。在生产模式下它是直接基于打包的结果创建的，但是在开发模式下 renderer 需要不断更新渲染。\n\n```javascript\n/**\n* 服务端入口，仅运行于服务端 \n*/\nconst express = require(\'express\')\n// 创建一个 experss 的 server 实例\nconst server = express()\nconst fs = require(\'fs\')\nconst { createBundleRenderer } = require(\'vue-server-renderer\')\nconst setupDevServer = require(\'./build/setup-dev-server\')\n\nconst isPro = process.env.NODE_ENV === \'production\'\nlet renderer\nlet onReady\n\nif (isPro) {\n    const template = fs.readFileSync(\'./index.html\', \'utf-8\')\n    // 生产模式，直接基于已构建好的包创建渲染器\n    const serverBundle = require(\'./dist/vue-ssr-server-bundle.json\')\n    const clientManifest = require(\'./dist/vue-ssr-client-manifest.json\')\n    // 创建一个渲染器\n    renderer = createBundleRenderer(serverBundle, {\n        template, // (可选) 设置页面模板\n        clientManifest // (可选) 客户端构建\n    })\n} else {\n    // 开发模式 --> 监视打包构建（客户端 + 服务端） --> 重新生成 Renderer 渲染器\n    onReady = setupDevServer(server, (serverBundle, template, clientManifest) => {\n        renderer = createBundleRenderer(serverBundle, {\n            template, // (可选) 设置页面模板\n            clientManifest // (可选) 客户端构建\n        })\n    })\n}\n\n// 开头的路径，需要与 output 中设置的 publicPath 保持一致\nserver.use(\'/dist\', express.static(\'./dist\'))\n\nconst render = async (req, res) =>{\n    try {\n        // renderToString支持promise\n        const html = await renderer.renderToString({\n            // 在模板中使用外部数据(可选第二个参数)\n            title:\'vue ssr\',\n            meta: `<meta name=\"description\" content=\"vue-SSR\">`,\n        })\n        res.setHeader(\'Content-Type\',\'text/html; charset=utf-8\')\n        res.end(html)\n    } catch (error) {\n        res.status(500).end(\'Internal Server Error\')\n    }\n}\n\n// 添加路由\nserver.get(\'/\', isPro\n    ? render // 生产模式：使用构建好的包直接渲染\n    : async (req, res) => {\n        // 等待有了 Renderer 渲染器以后，调用 render 函数\n        await onReady\n        render(req, res)\n    })\n\nserver.listen(3000, () => {\n    console.log(\'server running at port 3000\');\n})\n```\n\n#### 封装处理模块\n\n`build/setup-dev-server.js`，开发模式，自动构建，更新 Renderer 渲染器。\n```javascript\nconst fs = require(\'fs\')\nconst path = require(\'path\')\nconst resolve = file => path.resolve(__dirname, file)\nmodule.exports = (server, callback) => {\n    let ready\n    const onReady = new Promise(resolve => ready = resolve)\n\n    // 监视构建 --> 更新 Renderer\n    let template\n    let serverBundle\n    let clientManifest\n\n    // update更新函数\n    const update = ()=>{\n        // 当资源都构建好后，在调用callback，重新生成 Renderer渲染器（server.js）\n        if(template && serverBundle && clientManifest){\n            // 调用callback，意味着开发模式下打包构建成功了，让Promise变为resolve状态，onReady的Promise也就成功了，在server.js中渲染时候(路由)，如果是开发模式就直接onReady，调用render渲染\n            ready()\n            callback(serverBundle, template, clientManifest)\n        }\n    }\n    update() // 初始调用\n\n    // 处理模板文件：监视构建 template --> 调用 update --> 更新 Renderer 渲染器\n\n    // 服务端监视打包：监视构建 serverBundle --> 调用 update --> 更新 Renderer 渲染器\n\n    // 客户端构建：监视构建 clientManifest --> 调用 update --> 更新 Renderer 渲染器\n    return onReady\n}\n```\n\n##### 处理模板文件(监视构建 template)\n\n关于 Node 中的监视的问题：\n- fs.watch\n- fs.watchFile\n- 第三方包：[chokidar](https://github.com/paulmillr/chokidar)\n\nfs.watch、fs.watchFile不太好使用，推荐使用第三方包 chokidar 监听文件的变化,其内部也是封装了原生的监视模块，性能和功能上比原生好。\n\n安装第三方包：chokidar\n```script\nnpm i -D chokidar\n```\n\n`build/setup-dev-server.js`，监视构建 template，更新 Renderer 渲染器。\n\n```javascript\n// 处理模板文件：监视构建 template -> 调用 update -> 更新 Renderer 渲染器\nconst templatePath = resolve(\'../index.html\')  // 获取模板文件路径\ntemplate = fs.readFileSync(templatePath, \'utf-8\')  // 初始获取模板文件内容\nupdate() // 初始化\n// 监视资源变化，fs.watch、fs.watchFile不太好使用，推荐使用第三方包 chokidar 监听文件的变化\nchokidar.watch(templatePath).on(\'change\', (event, path) => {\n    // 文件发生改变后重新获取文件内容，调用update函数更新 Renderer\n    template = fs.readFileSync(templatePath, \'utf-8\')\n    update()\n});\n```\n\n##### 服务端监视打包(监视构建 serverBundle)\n\n`build/setup-dev-server.js`，监视构建 serverBundle，更新 Renderer 渲染器。\n\n```javascript\n// 服务端监视打包：监视构建 serverBundle -> 调用 update -> 更新 Renderer 渲染器\nconst serverConfig = require(\'./webpack.server.config.js\')\n// 使用webpack构建的实例\nconst serverCompiler = webpack(serverConfig)\nserverCompiler.watch({\n    // 监视打包的可选配置参数\n},(err, stats) => {\n    if(err) throw err\n    if(stats.hasErrors()) return\n    // require 引入的文件有缓存,此处使用读取文件方式（fs读取物理磁盘文件）\n    serverBundle = JSON.parse(fs.readFileSync(resolve(\'../dist/vue-ssr-server-bundle.json\'), \'utf-8\'))\n    update()\n})\n```\n\n开发环境频繁的磁盘读写，速度慢，将打包结果存储到内存中，提高速度，如何将打包结果存储到内存中？\n\n**将打包结果存储到内存中**\n\nwebpack 默认会把构建结果存储到磁盘中，对于生产模式构建来说是没有问题的；但是我们在开发模 式中会频繁的修改代码触发构建，也就意味着要频繁的操作磁盘数据，而磁盘数据操作相对来说是比较慢的，所以我们有一种更好的方式，就是 把数据存储到内存中，这样可以极大的提高构建的速度。两种方式：\n\n- 方案一：自己配置 [memfs](https://github.com/streamich/memfs)\\\n    memfs 是一个兼容 Node 中 fs 模块 API 的内存文件系统，通过它我们可以轻松的实现把 webpack 构建结果输出到内存中进行管理。\n\n1.  安装第三方包：memfs\n```script\nnpm install -D memfs\n```\n2.  `build/setup-dev-server.js`，监视构建 serverBundle，更新 Renderer 渲染器\n\n```javascript\nconst { createFsFromVolume, Volume } = require(\'memfs\') \n\n// 自定义 webpack 把数据写入内存中\nserverCompiler.outputFileSystem = createFsFromVolume(new Volume()) \n// memfs 模块去除了 join 方法，所以这里我们需要手动的给它提供 join 方法\nserverCompiler.outputFileSystem.join = path.join.bind(path) serverCompiler.watch({\n	// 监视构建的配置选项\n}, (err, stats) => {\n    // 每当构建成功，就会执行该回调函数  \n    if (err) {\n        throw err \n    }\n    if (stats.hasErrors()) return                    \n// 读取打包之后的最新结果 \n    serverBundle = JSON.parse(\n    	serverCompiler.outputFileSystem.readFileSync(resolve(\'../dist/vue-ssr-server-bundle.json\'), \'utf-8\')\n    )\n    // update 更新  \n    update()\n})\n```\n\n- 方案二：使用 [webpack-dev-middleware](https://github.com/webpack/webpack-dev-middleware)\n\n`webpack-dev-middleware` 作用是，以监听模式启动 webpack，将编译结果输出到内存中，然后将内存文件输出到 Express 服务中。\n\n1.  安装依赖：webpack-dev-middleware\n```script\nnpm i -D webpack-dev-middleware\n```\n2. 配置到构建流程中，`build/setup-dev-server.js`\n```javascript\nconst devMiddleware = require(\'webpack-dev-middleware\')\n// 服务端监视打包：监视构建 serverBundle -> 调用 update -> 更新 Renderer 渲染器\nconst serverConfig = require(\'./webpack.server.config.js\')\n// 使用webpack构建的实例\nconst serverCompiler = webpack(serverConfig)\n// 把数据存储到内存中，极大的提高构建的速度\n// devMiddleware构建完成后不会退出，以监视模式监视资源的变动，从新打包构建和手动调用watch类似\nconst serverDevMiddleware = devMiddleware(serverCompiler, {\n    // 配置 webpack-dev-middleware ^3.7.2 选项\n    // 这里我建议不要配置，因为服务端打包日志被清除后，无法跟踪服务端的异常\n    // logLevel: \'silent\' // 关闭日志输出 ，由 FriendlyErrorsWebpackPlugin（webpack.base.config.js） 处理\n})\n// done表示当每次编译结束的时候都会触发钩子\n// 参数1：插件名\nserverCompiler.hooks.done.tap(\'server\', ()=>{\n    // 读取内存中的文件\n    // serverDevMiddleware.fileSystem 获取到devMiddleware内部操作文件系统的对象，相当于nodejs中的fs\n    serverBundle = JSON.parse(\n        serverDevMiddleware.fileSystem.readFileSync(resolve(\'../dist/vue-ssr-server-bundle.json\'), \'utf-8\')\n    )\n    update()\n})\n```\n\n##### 客户端构建(监视构建 clientManifest)\n\n客户端打包和服务端打包类似，都是借助于 `webpack-dev-middleware`\n```javascript\nconst devMiddleware = require(\'webpack-dev-middleware\')\n// 客户端构建：监视构建 clientManifest -> 调用 update -> 更新 Renderer 渲染器\nconst clientConfig = require(\'./webpack.client.config.js\')\n// webpack构建实例\nconst clientCompiler = webpack(clientConfig)\nconst clientDevMiddleware = devMiddleware(clientCompiler, {\n    // 重要！输出资源的访问路径前缀，应该和 客户端打包输出的 publicPath 一致\n    publicPath:clientConfig.output.publicPath,\n    logLevel: \'silent\'\n})\n// 调用钩子，注册插件\nclientCompiler.hooks.done.tap(\'client\', ()=>{\n     // fileSystem 获取内部操作文件系统的对象 类似 NodeJS 的 fs（操纵磁盘中的文件）\n    clientManifest = JSON.parse(\n        clientDevMiddleware.fileSystem.readFileSync(resolve(\'../dist/vue-ssr-client-manifest.json\'), \'utf-8\')\n    )\n    update()\n})\n// 重要！！！将 clientDevMiddleware 挂载到 Express 服务中，提供对其内部内存中数据的访问\nserver.use(clientDevMiddleware)\n```\n##### 热更新\n\n热更新功能需要使用到 [webpack-hot-middleware](https://github.com/webpack-contrib/webpack-hot-middleware) 工具包\n\n- 安装依赖\n```script\nnpm install --save-dev webpack-hot-middleware\n```\n- `build/setup-dev-server.js` 配置热更新\n\n```javascript\nconst hotMiddleware = require(\"webpack-hot-middleware\")\n// 客户端构建：监视构建 clientManifest -> 调用 update -> 更新 Renderer 渲染器\nconst clientConfig = require(\'./webpack.client.config.js\')\n// ======================== 配置热更新 ======================== \n// 使用webpack-hot-middleware实现热更新（https://github.com/webpack-contrib/webpack-hot-middleware）\nclientConfig.plugins.push(new webpack.HotModuleReplacementPlugin())\nclientConfig.entry.app = [\n    \'webpack-hot-middleware/client?quiet=true&reload=true\', // 和服务端交互处理热更新一个客户端脚本\n    clientConfig.entry.app // 本来的脚本\n]\nclientConfig.output.filename = \'[name].js\' // 热更新模式下确保hash一致\nserver.use(hotMiddleware(clientCompiler, {\n    log: false // 关闭热更新本身的日志输出\n}));\n```\n\n>工作原理：\\\n>中间件将自身安装为 webpack 插件，并侦听编译器事件。\\\n>每个连接的客户端都有一个 Server Sent Events 连接，服务器将在编译器事件上向连接的>客户端 发布通知。\\\n>[MDN - 使用服务器发送事件](https://developer.mozilla.org/zh-CN/docs/Web/API/Server-sent_events/Using_server-sent_events)\\\n>[Server-Sent Events 教程](http://www.ruanyifeng.com/blog/2017/05/server-sent_events.html)\\\n>当客户端收到消息时，它将检查本地代码是否为最新。如果不是最新版本，它将触发 webpack 热更新模块重新加载。\n\n至此，服务端的热更新和内存打包优化已经配置好了，全新的`setup-dev-server.js`内容如下：\n```javascript\nconst fs = require(\'fs\')\nconst path = require(\'path\')\nconst webpack = require(\'webpack\')\nconst chokidar = require(\'chokidar\')\nconst devMiddleware = require(\'webpack-dev-middleware\')\nconst hotMiddleware = require(\'webpack-hot-middleware\')\nconst resolve = (file) => path.resolve(__dirname, file)\n\nconst serverConfig = require(\'./webpack.server.config.js\')\nconst clientConfig = require(\'./webpack.client.config.js\')\n\nmodule.exports = (server, callback) => {\n  let ready\n  const onReady = new Promise((resolve) => (ready = resolve))\n\n  // 监视构建 --> 更新 Renderer\n  let template\n  let serverBundle\n  let clientManifest\n\n  // update更新函数\n  const update = () => {\n    // 当资源都构建好后，在调用callback，重新生成 Renderer渲染器（server.js）\n    if (template && serverBundle && clientManifest) {\n      // 调用callback，意味着开发模式下打包构建成功了，让Promise变为resolve状态，onReady的Promise也就成功了，在server.js中渲染时候(路由)，如果是开发模式就直接onReady，调用render渲染\n      ready()\n      callback(serverBundle, template, clientManifest)\n    }\n  }\n\n  //update() // 初始调用\n\n  // 处理模板文件：监视构建 template -> 调用 update -> 更新 Renderer 渲染器\n  const templatePath = resolve(\'../index.html\') // 获取模板文件路径\n  template = fs.readFileSync(templatePath, \'utf-8\') // 初始获取模板文件内容\n  //update() // 初始化\n  // 监视资源变化，fs.watch、fs.watchFile不太好使用，推荐使用第三方包 chokidar 监听文件的变化\n  chokidar.watch(templatePath).on(\'change\', (event, path) => {\n    // 文件发生改变后重新获取文件内容，调用update函数更新 Renderer\n    template = fs.readFileSync(templatePath, \'utf-8\')\n    update()\n  })\n\n\n  // 服务端监视打包：监视构建 serverBundle -> 调用 update -> 更新 Renderer 渲染器\n  // 使用webpack构建的实例\n  const serverCompiler = webpack(serverConfig)\n  // 把数据存储到内存中，极大的提高构建的速度\n  // devMiddleware构建完成后不会退出，以监视模式监视资源的变动，从新打包构建和手动调用watch类似\n  const serverDevMiddleware = devMiddleware(serverCompiler, {\n    // 配置 webpack-dev-middleware ^3.7.2 选项\n    // 这里我建议不要配置，因为服务端打包日志被清除后，无法跟踪服务端的异常\n    // logLevel: \'silent\' // 关闭日志输出 ，由 FriendlyErrorsWebpackPlugin（webpack.base.config.js） 处理\n  })\n  // done表示当每次编译结束的时候都会触发钩子\n  // 参数1：插件名\n  serverCompiler.hooks.done.tap(\'server\', () => {\n    // 读取内存中的文件\n    // serverDevMiddleware.fileSystem 获取到devMiddleware内部操作文件系统的对象，相当于nodejs中的fs\n    serverBundle = JSON.parse(\n      serverDevMiddleware.fileSystem.readFileSync(\n        resolve(\'../dist/vue-ssr-server-bundle.json\'),\n        \'utf-8\',\n      ),\n    )\n    update()\n  })\n\n  \n  // ======================== 配置热更新 ========================\n  // 使用webpack-hot-middleware实现热更新（https://github.com/webpack-contrib/webpack-hot-middleware）\n  clientConfig.plugins.push(new webpack.HotModuleReplacementPlugin())\n  clientConfig.entry.app = [\n    \'webpack-hot-middleware/client?quiet=true&reload=true\', // 和服务端交互处理热更新一个客户端脚本\n    clientConfig.entry.app, // 本来的脚本\n  ]\n  clientConfig.output.filename = \'[name].js\' // 热更新模式下确保hash一致\n\n  // 客户端构建：监视构建 clientManifest -> 调用 update -> 更新 Renderer 渲染器\n  // webpack构建实例\n  const clientCompiler = webpack(clientConfig)\n  const clientDevMiddleware = devMiddleware(clientCompiler, {\n    // 重要！输出资源的访问路径前缀，应该和 客户端打包输出的 publicPath 一致\n    publicPath: clientConfig.output.publicPath,\n    logLevel: \'silent\'\n  })\n  // 调用钩子，注册插件\n  clientCompiler.hooks.done.tap(\'client\', () => {\n    // fileSystem 获取内部操作文件系统的对象 类似 NodeJS 的 fs（操纵磁盘中的文件）\n    clientManifest = JSON.parse(\n      clientDevMiddleware.fileSystem.readFileSync(\n        resolve(\'../dist/vue-ssr-client-manifest.json\'),\n        \'utf-8\',\n      ),\n    )\n    update()\n  })\n\n  server.use(\n    hotMiddleware(clientCompiler, {\n      log: false, // 关闭热更新本身的日志输出\n    }),\n  )\n  \n  // 重要！！！将 clientDevMiddleware 挂载到 Express 服务中，提供对其内部内存中数据的访问\n  server.use(clientDevMiddleware)\n\n  // 客户端构建：监视构建 clientManifest --> 调用 update --> 更新 Renderer 渲染器\n  return onReady\n}\n```\n\n## [编写通用代码](https://ssr.vuejs.org/zh/guide/universal.html#%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94)\n\n到此为止我们终于把实现 Vue SSR 同构应用的基础环境搭建起来，虽然还有很多不足之处，但是也能满足我们当前的基本使用了。接下来把内容的核心转移到 Vue SSR 本身上，了解一下编写通用应用的注意事项，对于如何正确的使用 Vue SSR 是非常有帮助的。\n\n在这些注意事项中，有些其实已经在前面的学习过程中了解过了，而有些还没有接触过，所以在这里通 过官方文档做一个简单的总结\n\n### 服务器上的数据相应\n\n在纯客户端应用程序 (client-only app) 中，每个用户会在他们各自的浏览器中使用新的应用程序实例。对于服务器端渲染，我们也希望如此：每个请求应该都是全新的、独立的应用程序实例，以便不会有交叉请求造成的状态污染 (cross-request state pollution),例如 app.js 代码\n```javascript\n// 导出一个工厂函数，用于创建新的应用程序、router、store实例\nexport function createApp () {\n  // 创建实例的代码放在函数中，每次请求进来，或者有不同的用户调用函数创建一个独立的vue实例处理请求，不会出现类似于状态污染的问题\n  const app = new Vue({\n    // 根实例简单的渲染应用程序\n    render: h => h(App)\n  })\n  return { app }\n}\n\n// 如果所有请求都共享了同一个vue实例，会造成状态的交叉污染\nconst app = new Vue({\n  render: h => h(App)\n})\n```\n因为实际的渲染过程需要确定性，所以我们也将在服务器上“预取”数据 (“pre-fetching” data) - 这意味着在我们开始渲染时，我们的应用程序就已经解析完成其状态。也就是说，将数据进行响应式的过程在服务器上是多余的，所以默认情况下禁用。禁用响应式数据，还可以避免将「数据」转换为「响应式对象」的性能开销。\n\n### 组件生命周期钩子函数\n\n由于没有动态更新，所有的生命周期钩子函数中，只有 `beforeCreate` 和 `created` 会在服务器端渲染 (SSR) 过程中被调用。这就是说任何其他生命周期钩子函数中的代码（例如 beforeMount 或 mounted），只会在客户端执行。\n\n此外还需要注意的是，你应该避免在 `beforeCreate` 和 `created` 生命周期时产生全局副作用的代码，例如在其中使用 setInterval 设置 timer。在纯客户端 (client-side only) 的代码中，我们可以设置一个 timer，然后在 `beforeDestroy` 或 `destroyed` 生命周期时将其销毁。但是，由于在 SSR 期间并不会调用销毁钩子函数，所以 timer 将永远保留下来。为了避免这种情况，请将副作用代码移动到 `beforeMount` 或 `mounted` 生命周期中。\n\n### 访问特定平台(Platform-Specific) API\n\n通用代码不可接受特定平台的 API，因此如果你的代码中，直接使用了像 window 或 document，这种仅浏览器可用的全局变量，则会在 Node.js 中执行时抛出错误，反之也是如此。\n\n对于共享于服务器和客户端，但用于不同平台 API 的任务(task)，建议将平台特定实现包含在通用 API 中，或者使用为你执行此操作的 library。例如，[axios](https://github.com/axios/axios) 是一个 HTTP 客户端，可以向服务器和客户端都暴露相同的 API。\n\n对于仅浏览器可用的 API，通常方式是，在「纯客户端 (client-only)」的生命周期钩子函数中惰性访问 (lazily access) 它们。\n\n请注意，考虑到如果第三方 library 不是以上面的通用用法编写，则将其集成到服务器渲染的应用程序中，可能会很棘手。你可能要通过模拟 (mock) 一些全局变量来使其正常运行，但这只是 hack 的做法，并且可能会干扰到其他 library 的环境检测代码。\n\n### 区分运行环境\n\n[webpack DefinePlugin](https://webpack.js.org/plugins/define-plugin/)\n\n区分运行环境:\n```javascript\nnew webpack.DefinePlugin({  \n    \'process.client\': true,  \n    \'process.server\': false \n});\n```\n\n### 自定义指令\n\n大多数自定义指令直接操作 DOM，因此会在服务器端渲染 (SSR) 过程中导致错误。有两种方法可以解决这个问题：\n\n- 推荐使用组件作为抽象机制，并运行在「虚拟 DOM 层级(Virtual-DOM level)」（例如，使用渲染函数(render function)）。\n- 如果你有一个自定义指令，但是不是很容易替换为组件，则可以在创建服务器 renderer 时，使用 directives 选项所提供”服务器端版本(server-side version)”\n\n## [路由和代码分割](https://ssr.vuejs.org/zh/guide/routing.html#%E4%BD%BF%E7%94%A8-vue-router-%E7%9A%84%E8%B7%AF%E7%94%B1)\n\n接下来我们来了解如何处理通用应用中的路由,和纯客户端的使用方式基本一致，使用vue-router,只需要在少许的位置做一些配置即可。通过查看文档来具体演示下:\n\n### 配置VueRouter - router/index.js\n- 安装\n```script\nnpm i vue-router@3\n```\n- 配置 VueRouter (路由规则)`router/index.js`\n```javascript\nimport Vue from \'vue\'\nimport vueRouter from \'vue-router\'\n// webpack中配置@指向src\nimport Home from \'@/pages/Home\'\n\nVue.use(vueRouter)\n\nexport function createRouter () {\n  return new vueRouter({\n    // 同构应用不能使用 hash 路由，应该使用 history 模式，兼容前后端\n    mode: \'history\',\n    routes: [\n        {\n            path: \'/\',\n            name: \'Home\',\n            component: Home\n        },{\n            path: \'/about\',\n            name: \'About\',\n             // 懒加载路由 按需加载，异步的\n            component: ()=> import(\'@/pages/About\')\n        },{\n            path: \'/posts\',\n            name: \'Posts\',\n            component: ()=> import(\'@/pages/Posts\')\n        },{\n            path: \'*\',\n            name: \'error404\',\n            component: ()=> import(\'@/pages/404\')\n        }\n    ]\n  })\n}\n```\n\n### 将路由注册到根实例\n\n- 注册路由 `src/app.js`\n\n```javascript\n// 通用 entry\nimport Vue from \'vue\'\nimport App from \'./App.vue\'\nimport { createRouter } from \'./router\'\n\n// 导出一个工厂函数，用于创建新的\n// 应用程序、router 和 store 实例\nexport function createApp () {\n  // 创建router实例\n  const router = createRouter()\n  const app = new Vue({\n    // 注入router到根vue实例\n    router,\n    // 根实例简单的渲染应用程序组件。\n    render: h => h(App)\n  })\n  // 返回app和router\n  return { app, router }\n}\n```\n\n### 适配服务端入口\n\n- `entry-server.js`\n\n```javascript\n// 服务端启动入口\nimport { createApp } from \'./app\'\n\n// 官方示例\nexport default context => {\n  // 因为有可能会是异步路由钩子函数或组件，所以我们将返回一个 Promise，\n    // 以便服务器能够等待所有的内容在渲染前，就已经准备就绪。\n  return new Promise((resolve, reject) => {\n    const { app, router } = createApp()\n\n    // 设置服务器端 router 的位置（服务端渲染时候这个过程是看不到）\n    router.push(context.url)\n\n    // 等到 router 将可能的异步组件和钩子函数解析完\n    router.onReady(() => {\n      /* 在router中有配置404情况，此处代码可以省略\n      // 获取匹配路由的组件\n      const matchedComponents = router.getMatchedComponents()\n      // 匹配不到的路由，执行 reject 函数，并返回 404\n      if (!matchedComponents.length) {\n        // 这样处理就可以在server中获取到状态码，进行404的处理  \n        return reject({ code: 404 })\n      }*/\n      \n      // Promise 应该 resolve 应用程序实例，以便它可以渲染\n      resolve(app)\n    }, reject)\n  })\n}\n\n// 使用async/await改造上述代码\nexport default async context => {\n    const { app, router } = createApp()\n    // 用于设置服务器端router的位置\n    router.push(context.url)\n    // this的指向router\n    await new Promise(router.onReady.bind(router))\n    // async对于非Promise的数据，会将他把装在Promise中，成功后返回对应的数据\n    return app\n}\n```\n\n### 服务端适配\n\n- 进行服务端 server 适配 `server.js`\n\n```\n/**\n* 服务端入口，仅运行于服务端 \n*/\n// 创建一个 express 的 server 实例\nconst express = require(\'express\')\nconst server = express()\nconst fs = require(\'fs\')\nconst { createBundleRenderer } = require(\'vue-server-renderer\')\nconst setupDevServer = require(\'./build/setup-dev-server\')\n\nconst isPro = process.env.NODE_ENV === \'production\'\nlet renderer\nlet onReady\n\nif (isPro) {\n    const template = fs.readFileSync(\'./index.html\', \'utf-8\')\n    // 生产模式，直接基于已构建好的包创建渲染器\n    const serverBundle = require(\'./dist/vue-ssr-server-bundle.json\')\n    const clientManifest = require(\'./dist/vue-ssr-client-manifest.json\')\n    // 创建一个渲染器\n    renderer = createBundleRenderer(serverBundle, {\n        template, // (可选) 设置页面模板\n        clientManifest // (可选) 客户端构建\n    })\n} else {\n    // 开发模式 --> 监视打包构建（客户端 + 服务端） --> 重新生成 Renderer 渲染器\n    onReady = setupDevServer(server, (serverBundle, template, clientManifest) => {\n        renderer = createBundleRenderer(serverBundle, {\n            template, // (可选) 设置页面模板\n            clientManifest // (可选) 客户端构建\n        })\n    })\n}\n\n// 开头的路径，需要与 output 中设置的 publicPath 保持一致\nserver.use(\'/dist\', express.static(\'./dist\'))\n\nconst render = async (req, res) =>{\n  try {\n      // renderToString支持promise\n      const html = await renderer.renderToString({\n          // 在模板中使用外部数据(可选第二个参数)\n          title:\'vue ssr\',\n          meta: `<meta name=\"description\" content=\"vue-SSR\">`,\n          // entry-server.js用于设置服务器端router的位置\n          url: req.url\n      })\n      res.setHeader(\'Content-Type\',\'text/html; charset=utf-8\')\n      res.end(html)\n  } catch (error) {\n    console.log(\'err: \', error)\n      res.status(500).end(\'Internal Server Error\')\n  }\n}\n\n// 添加路由\n// 服务端路由设置为 *，意味着所有的路由都会进入这里，不然会导致刷新页面，获取不到页面的bug\n// 并且vue-router设置的404页面无法进入\nserver.get(\'*\', isPro\n    ? render // 生产模式：使用构建好的包直接渲染\n    : async (req, res) => {\n        // 等待有了 Renderer 渲染器以后，调用 render 函数\n        await onReady\n        render(req, res)\n    })\n\nserver.listen(3000, () => {\n    console.log(\'server running at port 3000\');\n})\n```\n\n### 适配客户端入口\n\n路由器必须要提前解析路由配置中的异步组件，才能正确地调用组件中可能存在的路由钩子。\n\n`entry-client.js`\n\n```javascript\n// 客户端入口\nimport { createApp } from \'./app\'\n\n// 客户端特定引导逻辑……\n\nconst { app, router } = createApp()\n\n// 这里假定 App.vue 模板中根元素具有 `id=\"app\"`\nrouter.onReady(() => {\n  app.$mount(\'#app\')\n})\n```\n\n### 配置路由出口\n\n根组件中，设置路由的出口`src/App.vue`,如果没有路由出口的话，匹配到的路由组件就不知道要渲染到哪里。\n```javascript\n<template>\n    <div id=\"app\">\n        <ul>\n            <li>\n                <router-link to=\'/\'>Home</router-link>\n            </li>\n            <li>\n                <router-link to=\'/about\'>About</router-link>\n            </li>\n            <li>\n                <router-link to=\"/posts\">Posts</router-link>\n            </li>\n        </ul>\n        <!-- 路由出口 -->\n        <router-view/>\n    </div>\n</template>\n\n<script>\n    export default {\n        name: \"App\"\n    };\n</script>\n```\n\n到此位置路由相关配置已经完成，可以启动项目测试。\n\n### 总结\n\n测试路由导航，可以看到正常工作，那说明我们同构应用中的路由产生作用了。\n\n现在我们的应用就非常的厉害了，**当你`首次`访问页面的时候，它是通过服务端渲染出来的**，服务端渲染拥有了更快的渲染速度以及更好的 SEO，当服务端把渲染的内容发送到客户端后，客户端通过 Vue 结合 Vue Router 把当前内容激活，摇身一变成为了一个客户端单页面 SPA 应用，之后的页面导航交互是通过客户端交互的方式处理，不需要重新刷新整个页面。这样我们的网站就既拥有了更好的渲染速度和SEO，也拥有了单页应用中更好的用户体验。\n\n除此之外，我们在路由中配置的异步组件（也叫路由懒加载）也是非常有意义，这些异步组件会被分割为独立的 chunk（也就是单独的文件），只有在需要的时候才会进行加载。这样就能够避免在初始渲染的时候客户端加载的脚本过大导致激活速度变慢的问题。\n\n>首次这个词需要注意，下面会演示这个问题。\n\n运行项目，验证路由。来看一下在运行期间这些chunk文件是如何加载的。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e852d5bb8db4c7a8c9bc2bfafd15f49~tplv-k3u1fbpfcp-watermark.image?)\n\n我们会发现除了 app 主资源外，其它的资源也被下载下来了，这里可能会有个疑问：不是应该在需要的时候才加载吗？为什么一上来就加载了？\n\n原因是在页面的头部中的带有 preload 和 prefetch 的 link 标签。\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/996a7ce2e82f438196fd2f9d4a8f9ca2~tplv-k3u1fbpfcp-watermark.image?)\n\n我们期望客户端 JavaScript 脚本尽快加载尽早的接管服务端渲染的内容，让其拥有动态交互能力，但是如果把这些资源以 script 标签替代 link 标签这里这里的话，浏览器会去下载它，然后执行里面的代码，这个过程会阻塞页面的渲染。所以看到真正的 script 标签是在页面的底部的。\n\n```html\n<link rel=\"preload\" href=\"/dist/app.js\" as=\"script\">\n<link rel=\"prefetch\" href=\"/dist/0.js\">\n<link rel=\"prefetch\" href=\"/dist/1.js\">\n<link rel=\"prefetch\" href=\"/dist/2.js\">\n```\n\n这部分代码是告诉浏览器可以去预加载这个资源。但是不要执行里面的代码，也不要影响网页的正常渲染。直到遇到真正的 script 标签加载该资源的时候才会去执行里面的代码，这个时候可能已经预加载好了，直接使用就可以了，如果没有加载好，也不会造成重复加载，所以不用担心这个问题。\n\n- prefetch 资源是加载下一个页面可能用到的资源，浏览器会在空闲的时候对其进行加载，所以它并不一定会把资源加载出来\n- preload 当前页面一定会用到的资源，对其进行预加载。所以当我们去访问 about 页面的时候，它的资源是通过 prefetch 预取过来的（prefetch不稳定，页面的js可能是其加载好的），提高了客户端页面导航的响应速度。\n\n## 管理页面 Head\n\n无论是服务端渲染还是客户端渲染，它们都使用的同一个页面模板。页面中的 body 是动态渲染出来的，但是页面的 head 是写死的，如果我们希望不同的页面可以拥有自己的 head 内容，例如页面的 title、meta 等内容，如何处理呢？ 下面我们来了解一下如何让不同的页面来定制自己的 head 头部内容。\n\n官方文档这里专门描述了关于页面 [Head](https://ssr.vuejs.org/zh/guide/head.html) 的处理，相对于来讲更原生一些，使用比较麻烦，有兴趣的同学可以了解一下。\n\n我这里主要给大家介绍一个第三方解决方案：[vue-meta](https://vue-meta.nuxtjs.org/guide/)\n\nVue Meta 是一个支持 SSR 的第三方 Vue.js 插件，可让你轻松的实现不同页面的 head 内容管理。 使用它的方式非常简单，而只需在页面组件中使用 **metaInfo** 属性配置页面的 head 内容即可。\n\n使用 vue-meta 进行配置具体步骤如下：\n- 安装 vue-meta 依赖\n```script\nnpm i -D vue-meta\n```\n- 在通用入口 `app.js` 中通过插件的方式将 vue-meta 注册到 Vue 中。\n```javascript\nimport VueMeta from \'vue-meta\'\n// 注册插件\nVue.use(VueMeta)\n\nVue.mixin({\n  metaInfo:{\n    // 混入选项 %s 为用户自定义数据\n    titleTemplate:\'%s - vue SSR\'\n  }\n})\n```\n- 在服务端渲染入口 `src/entry-server.js` 模块中适配 `vue-meta`\n\n```javascript\nexport default async context => {\n    const { app, router } = createApp()\n    const meta = app.$meta()\n    // 设置服务端router位置\n    router.push(context.url)\n    context.meta = meta // 将meta放到html模板中\n ...\n}\n```\n- 在模板页面index.html中注入 meta 信息\n```html\n<head>\n    <!-- 公共内容 -->\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n     <!-- 动态注入的内容 -->\n    {{{ meta.inject().title.text() }}}\n    {{{ meta.inject().meta.text() }}}\n</head>\n```\n- 组件(src/pages/Home.vue) 中，配置 metaInfo\n```\nexport default {\n  name: \'HomePage\',\n  metaInfo: {\n    title: \'首页\'\n  }\n}\n```\n页面显示效果如下所示:\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/54772ce43011416e8fb2bf422a6d63ad~tplv-k3u1fbpfcp-watermark.image?)\n\n## 数据预取和状态管理\n\n接下来我们来了解一下服务端渲染中的数据预取和状态管理。[官方文档](https://ssr.vuejs.org/zh/guide/data.html)中的描述比较枯燥，无法在很短的时间内搞清楚它到底要做什么，所以我们这里通过一个实际的业务需求来引入这个话题。\\\n我们的需求就是：\n\n- 已知有一个数据接口，接口返回一个文章列表数据\n- 我们想要通过服务端渲染的方式来把异步接口数据渲染到页面中\n\n这个需求看起来是很简单，无非就是在页面发请求拿数据，然后在模板中遍历出来，如果是纯客户端渲染的话确实就是这样的，但是想要通过服务端渲染的方式来处理的话就比较麻烦了，下面我们来具体实现下。\n\n### 思路分析\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7af5523379214a4ea7afe77ad6cb09f8~tplv-k3u1fbpfcp-watermark.image?)\n\n也就是说我们要在服务端获取异步接口数据(url:`https://cnodejs.org/api/v1/topics`)，交给 Vue 组件去渲染。我们首先想到的是在组件的生命周期钩子中请求获取数据渲染页面，既在组件中添加生命周期钩子beforeCreate 和 created（服务端渲染仅支持这两个钩子函数的调用）。\n\n那么下一个问题是如何在服务端发送请求？\\\n依然使用 axios，axios 既可以运行在客户端也可以运行在服务端，因为它对不同的环境做了适配处理，在客户端是基于浏览器的 XMLHttpRequest 请求对象，在服务端是基于 Node.js 中的 http 模块实现，无论是底层是什么，上层的使用方式都是一样的，具体代码如下：\n\n`src/pages/Post.vue`:\n```javascript\n<script>\nimport axios from \'axios\'\n\nexport default {\n  name: \'PostList\',\n  metaInfo: {\n    title: \'Posts\'\n  },\n  data () {\n    return {\n      posts: []\n    }\n  }, \n // beforeCreate是获取不到data中的数据，所以将请求放到created中\n // 服务端渲染只支持 beforeCreate 和 created，不会等待 beforeCreate 和 created 中的异步操作，这种做法在服务端渲染中是不会工作的\n  async created () {\n    console.log(\'Posts Created Start\')\n    const { data } = await axios({\n      method: \'GET\',\n      url: \'https://cnodejs.org/api/v1/topics\'\n    })\n    // 不支持响应式数据\n    this.posts = data.data\n    console.log(\'Posts Created End\')\n  }\n}\n</script>\n```\n\n上述代码的这种做法只会在客户端工作，在服务端渲染中是不会工作的，原因是因为：服务端渲染期间确实会调用created生命周期钩子函数，但是他不会等待其中的异步操作，即便是可以获取到接口返回的异步数据，服务端也不支持这种响应式的操作。\n\n我们可以来验证下，上述代码的运行结果如下：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/754e7d53cd4e48d381184f1eda305a90~tplv-k3u1fbpfcp-watermark.image?)\n\n在浏览中展示的内容并不是通过服务端渲染过来，服务端返回的内容没有列表数据，列表的数据是通过后期客户端方式加载进来的\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71e1cee006c249f9a0bacf7b7a0c8e2a~tplv-k3u1fbpfcp-watermark.image?)\n\n这里可能会有个疑问，created 是不是在服务端没有调用呢？\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a30c6ed449142d4b1b61bfdf2f587e0~tplv-k3u1fbpfcp-watermark.image?)\n\n通过打印日志可以看到，created 在服务端确实被调用执行了，只是没有作用。\n\n接下来的问题就是：如果我们希望服务端渲染的时候就拿到数据，渲染后的结果就是完整的页面该怎么实现呢？\n\n官方文档给出的解决办法：为了解决这个问题，获取的数据需要位于视图组件之外，即放置在专门的数据预取存储容器(data store)或“状态容器(state container)”中。首先，在服务器端，我们可以在渲染之前预取数据，并将数据填充到 `store` 中。此外，我们将在 `HTML 中序列化(serialize)和内联预置(inline)状态`。这样，在挂载(mount)到客户端应用程序之前，可以直接从 store 获取到内联预置(inline)状态。\n\n简单来说：它的核心思路就是把在服务端渲染期间获取的数据存储到外部容器 Vuex 中，然后把容器中的数据同步到客户端，这样就保持了前后端渲染的数据状态同步，避免了客户端重新渲染的问题，所以接下来要做的第一件事就是基于 Vuex 创建容器。\n\n### 数据预取\n1.  通过 Vuex 创建容器实例，并挂载到 Vue 根实例\n\n- 安装 vuex\n```script\nnpm install vuex@3\n```\n- 创建 Vuex 容器 store/index.js\n\n```javascript\nimport Vue from \'vue\'\nimport Vuex from \'vuex\'\nimport axios from \'axios\'\n\nVue.use(Vuex)\n\nexport const createStore =  () =>{\n    return new Vuex.Store({\n        state:{\n            // 避免交叉污染\n            posts:[]\n        },\n        actions: {\n         // 在服务端渲染期间务必让 action 返回一个 Promise\n         // async 默认返回 Promise\n          async getPosts({commit}){\n              const { data } = await axios.get(\'https://cnodejs.org/api/v1/topics\')\n              commit(\'setPost\', data.data)\n            }\n        },\n        mutations: {\n            setPost(state , data){\n                state.posts = data\n            }\n        }\n    })\n}\n```\n- 在 app.js 中将 Vuex 容器挂载到 Vue 根实例\n```javascript\n// 通用 entry\nimport Vue from \'vue\'\nimport App from \'./App.vue\'\nimport { createRouter } from \'./router\'\nimport { createStore } from \'./store/index\'\n\n// 导出一个工厂函数，用于创建新的\n// 应用程序、router 和 store 实例\nexport function createApp () {\n  const store = createStore ()\n  const app = new Vue({\n    // 注入router到根vue实例\n    router,\n    // 把容器挂载到 Vue 根实例中\n    store,\n    // 根实例简单的渲染应用程序组件。\n    render: h => h(App)\n  })\n  // 返回app和router,store实例\n  return { app, router, store}\n}\n```\n2.  在组件中使用 serverPrefetch 触发容器中的 action\n```javascript\n<template>\n  <div>\n    <h1>Post List</h1>\n    <ul>\n      <li v-for=\"post in posts\" :key=\"post.id\">{{ post.title }}</li>\n    </ul>\n  </div>\n</template>\n\n<script>\nimport { mapState, mapActions } from \'vuex\'\n\nexport default {\n  computed: {\n    ...mapState([\'posts\'])\n  },\n  // Vue SSR 特殊为服务端渲染提供的一个生命周期钩子函数(渲染之前调用)\n  serverPrefetch () {\n    // 发起 action，返回 Promise\n    // this.$store.dispatch(\'getPosts\')\n    return this.getPosts()\n  },\n  methods: {\n    ...mapActions([\'getPosts\'])\n  }\n}\n</script>\n```\n运行结果如下：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e56d72c061c493caa9ec4a65eeb2dfd~tplv-k3u1fbpfcp-watermark.image?)\n\n通运行结果可以看出服务端渲染的页面中存在列表数据，但是浏览器中却没有展示出来，原因是因为此时我们拿到的数据只是存储在了服务端的 Vuex 容器当中了，并没有把数据同步到客户端的 Vuex 容器当中，导致两个端数据不同步，合并失败从而使得客户端重新渲染。\n\n### 将预取数据同步到客户端\n\n1.  在服务端渲染应用入口中将容器状态序列化到页面中\n\n接下来我们要做的就是把在服务端渲染期间所获取填充到容器中的数据同步到客户端容器中，从而避免两个端状态不一致导致客户端重新渲染的问题。\n\n- 将容器中的 state 转为 JSON 格式字符串\n- 生成代码： window.**INITIALSTATE** = 容器状态 语句插入模板页面中\n- 客户端通过 window.**INITIALSTATE** 获取该数据\n\n具体实现如下：\n- src/entry-server.js\n\n服务端渲染的入口中在router 将可能的异步组件和钩子函数解析完之后增加代码\n```javascript\nconst { app, router,store } = createApp()\n // 服务端渲染完毕后被调用，当被调用时候也就可以拿到服务端渲染好的容器状态数据\ncontext.rendered = () => {\n// Renderer 会把 context.state 数据对象内联到页面模板中\n// 最终发送给客户端的页面中会包含一段脚本：window.__INITIAL_STATE__ = context.state\n// 客户端就要把页面中的 window.__INITIAL_STATE__ 拿出来填充到客户端 store 容器中\n    context.state = store.state\n}\n```\n\n这步之后，我们所设置的容器 state 被内联到了模板中，通过这种方式传递给客户端\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3db9ad83a004b11b5d066d11147aa67~tplv-k3u1fbpfcp-watermark.image?)\n\n2.  在客户端渲染入口中把服务端传递过来的状态数据填充到客户端 Vuex 容器中\n-   src/entry-client.js\n```\n// 客户端启动入口 \nimport { createApp } from \'./app\'  \n// 客户端特定引导逻辑……  \nconst { app, router, store} = createApp()  \n\nif (window.__INITIAL_STATE__) {     \n    // 替换容器的数据状态     \n    store.replaceState(window.__INITIAL_STATE__)   \n} \n...\n```\n最终运行结果：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7721b4650684f90856e7a03e31b0efd~tplv-k3u1fbpfcp-watermark.image?)\n\n服务端渲染好内容后，客户端不在重新渲染，而是接管服务器渲染好的动态的内容交互，客户端通过服务端传递进来的 `window.__INITIAL__STATE` 将数据同步到客户端的 `Vuex` 中，数据状态和服务端保持一致，那么也可以在客户端修改数据内容。\n\n>备注：本教程服务端数据获取与渲染的实现是基于在浏览器地址栏输入对应的路由地址进行测试的。\n\n正如备注所言，这里出现的两个问题：\n- 服务端渲染只有首次，即只有第一次打开网页的时候，会进行服务端渲染。这就导致了只有第一次服务端渲染获取的数据会通过store同步到客户端。\n- 由于只有第一次渲染会进行服务端渲染，导致network的网页数据一直都是首次渲染的数据，不会更新。\n\n第一个问题的解决方案是，在客户端入口(entry-client.js)文件中配置一个方法，方法名我命名成了asyncData，通过Vue.mixin混入到整个项目，页面挂载前和路由更新时，去进行store更新。同时在服务端入口文件配置当服务端获取完数据后，再写入到服务端的store中(服务端其实和客户端共用一个store配置，只不过在客户端渲染的时候进行了替换)\n\n具体实现代码如下：\n`entry-client.js`\n```javascript\n// 客户端入口\nimport Vue from \'vue\'\nimport { createApp } from \'./app\'\n\n// 客户端特定引导逻辑……\n\nconst { app, router, store } = createApp()\n\nVue.mixin({\n  // 组件挂载前\n  beforeMount() {\n      const { asyncData } = this.$options\n      if (asyncData) {\n          // 将获取数据操作分配给 promise\n          // 以便在组件中，我们可以在数据准备就绪后\n          // 通过运行 `this.dataPromise.then(...)` 来执行其他任务\n          this.dataPromise = asyncData({\n              store: this.$store,\n              route: this.$route\n          })\n      }\n  },\n\n  // 路由更新前\n  beforeRouteUpdate(to, from, next) {\n      const { asyncData } = this.$options\n      if (asyncData) {\n          asyncData({\n              store: this.$store,\n              route: to\n          }).then(next).catch(next)\n      } else {\n          next()\n      }\n  }\n})\n\nif (window.__INITIAL_STATE__) {\n  // 将window.__INITIAL_STATE__的数据替换到客户端的store中\n  store.replaceState(window.__INITIAL_STATE__)\n}\n\n// 这里假定 App.vue 模板中根元素具有 `id=\"app\"`\nrouter.onReady(() => {\n  app.$mount(\'#app\')\n})\n```\n\n`entry-server.js`:\n```javascript\n// entry-server.js\nimport { createApp } from \'./app\'\n\n// 使用async/await改造上述代码\nexport default async (context) => {\n  const { app, router, store } = createApp()\n  const meta = app.$meta()\n  // 用于设置服务器端router的位置\n  router.push(context.url)\n  context.meta = meta\n\n  // this的指向router\n  await new Promise(router.onReady.bind(router))\n\n  const matchedComponents = router.getMatchedComponents()\n\n  // 这里等待所有匹配组件的asyncData执行完成\n  await Promise.all(\n    matchedComponents.map((component) => {\n      if (component.asyncData) {\n        return component.asyncData({\n          store,\n          route: router.currentRoute,\n        })\n      }\n    })\n  )\n\n  context.rendered = () => {\n    // Renderer 会把 context.state 数据对象内联到页面模板中\n    // 最终发送给客户端的页面中会包含一段脚本：window.__INITIAL_STATE__ = context.state\n    // 客户端就要把页面中的 window.__INITIAL_STATE__ 拿出来填充到客户端 store 容器中\n    context.state = store.state\n  }\n  // async对于非Promise的数据，会将他把装在Promise中，成功后返回对应的数据\n  return app\n}\n```\n\n在组件`Post.vue`中使用：\n```javascript\n<template>\n  <div>\n    <h1>Post List</h1>\n    <ul>\n      <li v-for=\"post in posts\" :key=\"post.id\">{{ post.title }}</li>\n    </ul>\n  </div>\n</template>\n\n<script>\nimport { mapState, mapActions } from \'vuex\'\n\nexport default {\n  computed: {\n    ...mapState([\'posts\'])\n  },\n  asyncData ({ store, route }) {\n    // 这里必须使用方法注入的store\n    return store.dispatch(\'getPosts\')\n  },\n  // Vue SSR 特殊为服务端渲染提供的一个生命周期钩子函数(渲染之前调用)\n  // serverPrefetch () {\n  //   // 发起 action，返回 Promise\n  //   // this.$store.dispatch(\'getPosts\')\n  //   console.log(\'serverPrefetch\')\n  //   return this.getPosts()\n  // },\n  methods: {\n    ...mapActions([\'getPosts\'])\n  }\n}\n</script>\n```\n这个解决办法，是没法观察到network的实时更新的，因为这里并没有在路由跳转的时候，进行服务端渲染，只是进行了数据的更新。\n\n第二种解决办法，是使用原生js的window.location.href进行路由跳转，这样每次路由跳转都会进行服务端跳转了，使用示例：\n```\n<template>\n    <div id=\"app\">\n        <ul>\n            <li>\n                <router-link to=\'/\'>Home</router-link>\n            </li>\n            <li>\n                <router-link to=\'/about\'>About</router-link>\n            </li>\n            <li>\n                <span @click=\"toPost\">Posts</span>\n                <!-- <router-link to=\"/posts\">Posts</router-link> -->\n            </li>\n        </ul>\n        <!-- 路由出口 -->\n        <router-view></router-view>\n    </div>\n</template>\n\n<script>\n    export default {\n      name: \"App\",\n      methods: {\n        toPost () {\n          location.href = \'/posts\' // 这里的地址可以直接写vue-router配置的path\n        }\n      }\n    };\n</script>\n```\n\n### 设置favicon.ico\n默认情况下，不配置favicon.ico，但服务端会报个404页面，为避免，我们需要设置。\n\n先安装依赖`serve-favicon`:\n```script\nnpm i serve-favicon\n```\n\n在根目录下新建static目录，放置favicon。然后在`server.js`进行配置:\n```javascript\nserver.use(favicon(\'./static/favicon.ico\'))\n```\n\n重启项目，就能看到网站已经有了图标。\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8e963da8f0a4952b2de3a92cc1e0998~tplv-k3u1fbpfcp-watermark.image?)\n\n**该方式设置图标的缺陷是，当项目是采用nginx代理时，图标会丢失，因为nginx代理不会去加载对应的非express的静态文件。**\n\n解决办法是：先用express.static去将打包后的dist设置成express的静态资源，然后将图标打包进dist，再在html文件中使用如下，将图标引入：\n```\n<link  rel=\"shortcut icon\" href=\"/dist/static/favicon.ico\" type=\"image/x-icon\">\n```\n\n## [项目源码](https://github.com/perosnal-javascripts/custom-vue-ssr)', '小白学习vue服务端渲染(一)--从零搭建vue服务端架构', 0, 4, 1, 9, 0, '2023-06-09 15:52:04', '2023-06-09 15:52:04', 0);
INSERT INTO `tb_article` VALUES (3, '小白学习gitlab+jenkins进行自动化构建(docker)之vue项目', '## 前言\n\n之前，我写过一篇如何使用jenkins+docker自动化构建springboot的项目的博文，极大的减少了后端开发部署的工作。所以，我打算将前端项目也进行自动化构建，但目前不采用容器化部署，容器化部署后期再做。\n\nspringboot的自动化构建参考这篇博文：[小白学习gitlab+jenkins进行自动化构建(docker)之springboot项目](https://juejin.cn/post/7073478980099112996)\n\n## 准备\n\n### 安装nodejs和创建nginx容器\n\n### nginx安装\nnginx采用的是容器化部署，容器部署参考这篇博文：[小白学习nginx（一）--docker创建nginx容器](https://juejin.cn/post/7039717798922158117)\n\n#### nodejs的安装\n\n[通过官方查询需要安装的版本](https://github.com/nodesource/distributions)\n\n由于我本地的nodejs版本是v12.16.0，所以我安装的是nodejs-v12, 安装命令如下:\n\n```\ncurl -fsSL https://deb.nodesource.com/setup_12.x | bash -\napt-get install -y nodejs\n```\n一般npm远程仓库下载依赖相当慢，所以我这里将npm的代理改成了我自己安装的nexus私服中的npm仓库\n\n```\nnpm config set registry http://192.168.57.128/:9081/repository/group-npm/\n```\n\n也可以在jenkins安装nodejs, 原因我会在下面实际操作的教程中说明\n\n### 新建一个jenkins任务\n\n本案例是对vue项目进行自动化构建，因此新建的任务的类型选择构建一个自由风格的软件项目\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c37159e06d6f47b1a3735bcf398673e3~tplv-k3u1fbpfcp-watermark.image?)\n\n### 源码管理\n\n进入刚刚新建的任务，进行源码管理的配置\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8559afdc49174067825eb6843355b869~tplv-k3u1fbpfcp-watermark.image?)\n\n### 构建触发器\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cbf0aecbf9da405dadc49af263dd9a13~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af4258d5e6854481b86429e5ccc0be0c~tplv-k3u1fbpfcp-watermark.image?)\n\n### 构建环境\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1144227311384d50a9a7b27813633663~tplv-k3u1fbpfcp-watermark.image?)\n\n如果选择执行shell的方式，还需要在系统管理->全局工具配置中安装nodejs\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94ba88f67d574cbaa801a7502f087281~tplv-k3u1fbpfcp-watermark.image?)\n\n### 构建后操作\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a7221ae17534491a80d26e7b4aeb796~tplv-k3u1fbpfcp-watermark.image?)\n\n### gitlab配置\n\n选择要构建的项目，settings->webhooks\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82f1fbd3a85a4e118435a1f943b2a836~tplv-k3u1fbpfcp-watermark.image?)\n\n至此，配置完成，在gitlab上刚刚添加的webhook选择push event点击测试，测试成功如下图：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82dd619da61b40a1b94427770260a6e0~tplv-k3u1fbpfcp-watermark.image?)\n\n输入ip+端口进行访问（我在nginx里配置了）,访问成功如下图：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6c6c11066574bef9ab60b2c7237debc~tplv-k3u1fbpfcp-watermark.image?)\n\n## 总结\n\n经过上述步骤，已经完成了jenkins+gitlab自动化构建和部署vue项目，极大的减少了开发者的工作，提升了方便性。', '小白学习gitlab+jenkins进行自动化构建(docker)之vue项目', 0, 6, 2, 9, 0, '2023-06-09 16:03:31', '2023-06-09 16:03:31', 0);
INSERT INTO `tb_article` VALUES (4, '小白学习gitlab+jenkins进行自动化构建(docker)之springboot项目', '## 前言\ngitlab和jenkins的安装参考我的另外两篇博客：\n* gitlab安装：[小白搭建gitlab(docker)](https://juejin.cn/post/7032898607686778910)\n* jenkins安装：[小白学习搭建jenkins(docker)](https://juejin.cn/post/7032891246490157093/)\n\n## 在Jenkins上安装必要的插件\n所需插件：`Maven Integration`、`Pipeline Maven Integration`、`Gitlab`、`GitLab Authentication`、`SSH`、`Publish Over SSH`、`Docker`\n\n点击 Manage Jenkins（系统管理） ——> Manage Plugins（插件管理）\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5d15509337b44198064ba2bd41f221e~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Maven插件\n\n点击可选插件 ——> 过滤Maven Integration插件 ——> 勾选Maven Integration和Pipeline Maven Integration ——> 点击直接安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e496dbb12972454789d19546d660c88d~tplv-k3u1fbpfcp-watermark.image?)\n\n如图开始安装插件：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/134fef5f496c468b8dad342454c83b45~tplv-k3u1fbpfcp-watermark.image?)\n\n安装完成后，即可在插件管理下的已安装选项卡下看到刚刚已经安装的插件。\n\n#### 安装Gitlab插件\n\n点击可选插件 ——> 过滤Gitlab插件 ——> 勾选Gitlab和Gitlab Authentication ——> 点击直接安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6171674e55b428c9eba7be7cc2f516c~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装SSH插件和Publish Over SSH插件\n安装Publish Over SSH插件的原因：因为本方式是使用docker启动jenkins服务，所以在jenkins后续执行构建任务时候，需要在build成功后，将服务的jar包（以spring boot服务为例）拷贝到Dockerfile所在服务器的指定目录，进行微服务的启动；所以，此处需要配置SSH服务器的连接，意思就是在jenkins的任务结束后，去执行指定的服务器上的shell命令，做spring boot或cloud服务的镜像的构建，容器的运行，等一系列的事情。\n\n点击可选插件 ——> 过滤SSH插件 ——> 勾选SSH和Publish Over SSH ——> 点击直接安装\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d21ba2054860482b8b07684f48468538~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Docker插件\n\n点击可选插件 ——> 过滤Docker插件 ——> 勾选Docker ——> 点击直接安装\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1501abfe94b431a91e5692c41d12f72~tplv-k3u1fbpfcp-watermark.image?)\n\n插件全部安装完成后，可以重启一下Jenkins。\n\n## 相关配置\n\n#### 添加凭据\n\n点击 Manage Jenkins（系统管理） ——> Manage Credentials（凭据管理）\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0d3890020d34004adb05cab48310dd1~tplv-k3u1fbpfcp-watermark.image?)\n\n点击添加凭据 ——> 输入宿主机服务器的用户名和密码等信息并保存\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8eb6e5330d2140cb9705256fc722dc9d~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 配置SSH remote hosts\n\n这个配置是干什么的呢？配置SSH连接Dockerfile所在服务器的相关信息，并添加凭证，最后测试连接并保存，以备后面使用！！！\n\n点击 Manage Jenkins（系统管理） ——> 系统配置\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3813b66e9134305a1acb1d7515110bd~tplv-k3u1fbpfcp-watermark.image?)\n\n找到配置 ——> 下拉选择SSH remote hosts\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7436757a876049db93e6b255662001f2~tplv-k3u1fbpfcp-watermark.image?)\n\n如下图，输入对应的信息，并校验是否连接成功！成功后，点击应用 ——> 点击保存\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3559c64c918c4355aaff8d136e689da9~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 配置Publish over SSH\n\n找到配置 ——> 下拉选择Publish over SSH，进行相关配置即可。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0bb12f108302405ba90bb33e80fd0d5e~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78ad24f26a2a46b68ea44ea1c6ceb537~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de7ba1ca4a074ad1bb6f6a4b8fe71ee3~tplv-k3u1fbpfcp-watermark.image?)\n\n这里配置的数据，目前只能在Post Steps中选中send files or execute commands over ssh使用，要想能够在execute shell script on remote host using ssh方式中使用，需要再配置一份SSH remote hosts和它配套使用\n\n## 全局工具配置\n\n由于我们要实现的是SpringBoot项目的自动化部署操作，所以需要安装JDK、Git、Maven、Docker。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0dec279d6d44a83b2138cd7663e0995~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装JDK\n\n可以安装多个，根据项目JDK版本需求。\n\n输入自定义JDK名称 ——> 勾选自动安装 ——> 输入Oracle账户、密码 ——> 选择JDK版本 ——> 勾选同意协议\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72aa67fd5a494228840c5bef060e36b8~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Git\n\n输入自定义Git名称 ——> 勾选自动安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b49eb7bd11d48ab9ffce4f29431c216~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Maven\n\n输入自定义名称 ——> 勾选自动安装 ——> 选择版本\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5394195a98b647189dfaa5cd74b1a0b0~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Docker\n\n输入自定义名称 ——> 勾选自动安装\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/893704cbe8fe449fb615534bf9e82cea~tplv-k3u1fbpfcp-watermark.image?)\n\n最后，点击应用 ——> 点击保存即可。\n\n## 新建Jenkins任务\n\n### 点击新建任务，输入名称\n\n注意：本名称必须和项目名称一致，因为本名称会在jenkins工作空间下生成目录，类似于IDEA或Eclipse的工作空间的概念。所以，一般情况下，保证本名称=项目名称=docker镜像名称=docker容器名称 这样能尽可能的减轻jenkins配置的shell命令的复杂性！（空间命名要小写：因为镜像名不允许存在大写字母）\n\n选择构建一个Maven项目（因为是Spring Boot的服务）\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5a510bcf4ac49159f3f3b2960ae4fc5~tplv-k3u1fbpfcp-watermark.image?)\n\n### 源码管理\n\n输入描述信息，源码管理选择Git，从gitlab复制克隆地址（http协议的）粘贴到Repository URL中。未添加凭证会报授权失败的错误。错误如下：\n```\n![]()无法连接仓库：Command \"git ls-remote -h -- http://192.168.57.128:8880/root/video-book-backend.git HEAD\" returned status code 128:\\\nstdout:\\\nstderr: remote: HTTP Basic: Access denied\\\nfatal: Authentication failed for \'http://192.168.57.128:8880/root/video-book-backend.git/\'\n```\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94c2477c80724a959f8bb9f461814f41~tplv-k3u1fbpfcp-watermark.image?)\n\n添加gitlab凭证：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e08c1c343564fda9d5c599e985c38f5~tplv-k3u1fbpfcp-watermark.image?)\n\n### 构建触发器\n\n接下来将会生成供gitlab配置webhook使用的URL和Token，请记录下来，后面会使用。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1016fa1f35f24be7bf16ebe0a503bb8e~tplv-k3u1fbpfcp-watermark.image?)\n\n点击高级，拉下来找到Generate并点击，生成一串Secret Token。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13fb693d0ed14c63b8b613cccc7cd5b9~tplv-k3u1fbpfcp-watermark.image?)\n\n### 添加webhook\n\n前往gitlab，进入要构建的项目，在setting中选择Webhooks，输入URL和Secret Token 这两在上面图中已经给你标注了，去掉Enable SSL verification的勾选。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/904006704c604f6da4f2d1989200d462~tplv-k3u1fbpfcp-watermark.image?)\n\n点击Add webhook，如图表示成功添加了webhook：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6928c377f94748d0b70f57189e42e6cd~tplv-k3u1fbpfcp-watermark.image?)\n\n如果添加不成功解决方案请参考：[解决 Url is blocked: Requests to the local network are not allowed](https://www.cnblogs.com/zhongyuanzhao000/p/11379098.html)\n\n### 构建环境\n\n勾选Add timestamps to the Console Output，等下可以看到控制台打印的信息，这个根据自己的需求勾选。\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/badcdddabcc643b19f5a41fdc9f3416e~tplv-k3u1fbpfcp-watermark.image?)\n\n### Pre Steps(构建之前的步骤)\n\n配置前一步需要做的事情是：清理本项目在jenkins的workspace中的历史文件夹。\n\n你可以不用知道WORKSPACE具体的地址在哪里，因为下方有链接可以查看到当前jenkins中有哪些可用的变量供你使用。\n\n默认WORKSPACE地址：`/var/jenkins_home/workspace`（如果你jenkins是docker启动的，并且挂载了目录在宿主机，那你在宿主机也是可以看到的，即 `/usr/local/docker/workspace`）\n\n本处选择的是执行shell，则表示本处配置的shell命令，是默认在jenkins容器中执行的，而不是在宿主机上。\n\n下拉选择执行 shell：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c2e1bd362944ff2aab0a62646bae53d~tplv-k3u1fbpfcp-watermark.image?)\n\n在执行shell的命令中输入以下命令，设置全局变量：\n```\nSERVER_NAME_1=video-book-backend\necho \"=========================>>>>>>>工作空间WORKSPACE的地址：$WORKSPACE \"\ncd $WORKSPACE\necho \"=========================>>>>>>>进入工作空间WORKSPACE，清除工作空间中原项目的工作空间$SERVER_NAME_1 \"\nrm -rf $SERVER_NAME_1\necho \"=========================>>>>>>>清除工作空间中原项目的工作空间$SERVER_NAME_1 ......成功success\"\n```\n注意：本处的SERVER_NAME_1=jenkins-docker-gitlab-springboot是配置项目的名称(和gitlab中的项目名保持一致)\n\n### Build(构建)\n\n我们是SpringBoot项目，所以用到maven，这里设置一下全局操作，clean项目，并打成jar包，所以这里输入：`clean package`\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a41ff4b5061f48f39de4738c6282ec78~tplv-k3u1fbpfcp-watermark.image?)\n\n### Post Steps(执行任务)\n\n只在jenkins构建成功后，才执行这一步。\n\n因为最后的构建成功的maven项目的jar包是以docker启动服务为目的，所以最后的docker操作，一定是在jenkins容器以外的服务器上运行的，可能是本机宿主机，也可能是远程的服务器，这个根据自己的情况去配置。\n\n本处选择，在远程的SSH执行shell脚本。\n\n选中只有构建成功才执行这些命令，然后选择Execute shell script on remote host using ssh。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c25a57ddb8f4b10b31e4832503d4af2~tplv-k3u1fbpfcp-watermark.image?)\n\nshell命令:\n```\n# =====================================================================================\n# =================================定义初始化变量======================================\n# =====================================================================================\n\n# 操作/项目路径(Dockerfile存放的路径，Dockerfile一般都放在项目的根目录下)\n# 如果Dockerfile放在项目根目录的子目录下，则子目录不能与项目同名\n# 会导致在复制jar包的时候，覆盖子目录为jar包,同时没有扩展名jar,原因我暂时不知道\n# 目前我的做法是将Dockerfile放在项目根目录下\nBASE_PATH=/usr/local/docker/jenkins/workspace/video-book-backend\n\n# jenkins构建好的源jar路径\n# 这个路径是jenkins容器挂载在宿主机上的路径\n# 我的jenkins的目录被我挂载在了/usr/local/docker/jenkins上\nSOURCE_PATH=/usr/local/docker/jenkins/workspace\n\n# docker镜像、docker容器、Dockerfile同目录下的jar名字[用它build生成image的jar]、jenkins的workspace下的项目名称\n# 注意统一名称！！！！！\nSERVER_NAME=video-book-backend\n\n# 容器id  [grep -w 全量匹配容器名] [awk 获取信息行的第一列，即容器ID]  [无论容器启动与否，都获取到]\nCID=$(docker ps -a | grep -w \"$SERVER_NAME\" | awk \'{print $1}\')\n\n# 镜像id  [grep -w 全量匹配镜像名] [awk 获取信息行的第三列，即镜像ID]\nIID=$(docker images | grep -w \"$SERVER_NAME\" | awk \'{print $3}\')\n\n# 源jar完整地址[jenkins构建成功后，会在自己的workspace/项目/target下生成maven构建成功的jar包，获取jar包名的完整路径]\n# 例如：/usr/local/docker/jenkins/workspace/video-book-backend/target/video-book-backend-0.0.1-SNAPSHOT.jar\nSOURCE_JAR_PATH=$(find \"$SOURCE_PATH/$SERVER_NAME/target/\"  -name \"*$SERVER_NAME*.jar\" )\n\nDATE=`date +%Y%m%d%H%M%S`\n\n# =====================================================================================\n# ============================对原本已存在的jar进行备份================================\n# =====================================================================================\n\n# 备份\nfunction backup(){\n    if [ -f \"$BASE_PATH/$SERVER_NAME.jar\" ]; then\n        echo \"=========================>>>>>>>$SERVER_NAME.jar 备份...\"\n            mv $BASE_PATH/$SERVER_NAME.jar $BASE_PATH/backup/$SERVER_NAME-$DATE.jar\n        echo \"=========================>>>>>>>备份老的 $SERVER_NAME.jar 完成\"\n\n    else\n        echo \"=========================>>>>>>>老的$BASE_PATH/$SERVER_NAME.jar不存在，跳过备份\"\n    fi\n}\n\n# =====================================================================================\n# =========================移动最新源jar包到Dockerfile所在目录=========================\n# =====================================================================================\n\n\n \n# 查找源jar文件名，进行重命名，最后将源文件移动到Dockerfile文件所在目录\nfunction transfer(){\n      \n    echo \"=========================>>>>>>>源文件完整地址为 $SOURCE_JAR_PATH\"\n\n    echo \"=========================>>>>>>>重命名源文件\"\n        mv $SOURCE_JAR_PATH  $SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar\n\n    echo \"=========================>>>>>>>最新构建代码 将$SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar 迁移至 $BASE_PATH\"\n        cp $SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar $BASE_PATH\n        \n    echo \"=========================>>>>>>>迁移完成Success\"\n\n}\n \n# =====================================================================================\n# ==================================构建最新镜像=======================================\n# =====================================================================================\n\n# 构建docker镜像\nfunction build(){\n    \n    # 无论镜像存在与否，都停止原容器服务，并移除原容器服务\n    echo \"=========================>>>>>>>停止$SERVER_NAME容器，CID=$CID\"\n    docker stop $CID\n\n    echo \"=========================>>>>>>>移除$SERVER_NAME容器，CID=$CID\"\n    docker rm $CID\n\n    # 无论如何，都去构建新的镜像\n    if [ -n \"$IID\" ]; then\n        echo \"=========================>>>>>>>存在$SERVER_NAME镜像，IID=$IID\"\n\n        echo \"=========================>>>>>>>移除老的$SERVER_NAME镜像，IID=$IID\"\n        \n        docker rmi $IID\n\n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，开始---->\"\n        \n        cd $BASE_PATH\n        docker build -t $SERVER_NAME .\n        \n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，完成---->\"\n\n    else\n        echo \"=========================>>>>>>>不存在$SERVER_NAME镜像，构建新的镜像，开始--->\"\n        \n        cd $BASE_PATH\n        docker build -t $SERVER_NAME .\n        \n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，结束--->\"\n    fi\n}\n \n\n# =====================================================================================\n# ==============================运行docker容器，启动服务===============================\n# =====================================================================================\n\n# 运行docker容器\nfunction run(){\n    backup\n    transfer\n    build\n\n    # 创建容器\n    docker run --name $SERVER_NAME -itd --net=host -v /etc/localtime:/etc/localtime:ro  -v /etc/timezone:/etc/timezone:ro  $SERVER_NAME \n\n}\n \n# 入口\nrun\n```\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e67ba6d7cf14d52b00009c09afc9349~tplv-k3u1fbpfcp-watermark.image?)\n\nOK，到这里基本的任务已经新建成功，至于后续的两个步骤，根据自己的需求自行配置，没有难度的。\n\n点击应用，保存。\n\n### 测试\n\n测试push事件触发自动化构建和部署，点击test下拉选择push events，出现HTTP 200表示OK了。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e85f532d1c2b4643996604347b945f51~tplv-k3u1fbpfcp-watermark.image?)\n\n回到Jenkins可以看到任务列表，查看构建信息等。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f954757d41324660ae01ff5de6afe17e~tplv-k3u1fbpfcp-watermark.image?)\n\n待Jenkins构建成功之后，在服务器上执行命令：`docker ps`，可以看到我们启动起来的 SpringBoot 容器：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8556de2ce136416ea36e817b661c2f80~tplv-k3u1fbpfcp-watermark.image?)\n\n## 邮件通知\n\n有时候团队合作，我们希望能通过邮件通知每一个开发者，项目是否构建成功。jenkins/jenkins:2.332.1默认安装了`# Email Extension Template`这个插件，还需要安装`Email Extension Template`这个插件\n\n系统管理->插件管理->可选插件->搜索`Email Extension Template`\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51c60941d3d3422e88db89b5188a3168~tplv-k3u1fbpfcp-watermark.image?)\n\n直接安装\n\n### 配置Email(Jenkins自带)\n\n#### 2.1 基础信息查询\n\n>找到所要配置邮箱的基础信息，这里以QQ邮箱为例\n\n1. 通过网页端QQ邮箱的设置进入到邮箱客户端设置页面\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f31038ef147f4c728540bc581f64d522~tplv-k3u1fbpfcp-watermark.image?)\n\n2. 找到邮箱的基础信息\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5694801b0ed74685a76cade6b358c5fc~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 2.2 Jenkins邮件通知配置\n\n在Jenkins：`系统管理->系统配置`中，最底部找到`邮件通知`，打开`高级`,注意到在配置的下方有个\"通过发送测试邮件测试配置\"，我们可以讲其勾选，填入邮箱地址，点击`Test configuration`来先测试一下邮件的发送。\n\n> 这边最好先保存一下再测试，否则出错，又得重配。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6420215d674647fb824854fd68a3efd6~tplv-k3u1fbpfcp-watermark.image?)\n\n如果报错如下：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8481f74294404047a2671bc8e2a3297e~tplv-k3u1fbpfcp-watermark.image?)\n\n这是因为我们还需要在设置`Jenkins Location`中配置`系统管理员邮件地址`，此地址要和`邮件通知`中的`用户名`一致\n\n### 配置Email(Extended E-mail Notification)\n\n>记得文章一开头提到的下载Extended插件，没错，Jenkins系统设置里还可以通过`Extended E-mail Notification`对邮件发送进行模板格式的自定义\n\n#### 3.1 基础信息配置\n\n基础信息配置与上述一致,唯一要注意的是这里需要重新生成一个授权码\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cb0934380904b098a035e54297946d4~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 3.2 模板格式配置\n\n接3.1配置继续。这里主要就是配置展示的模板格式，常用的格式化的参数有：\n```\n- $BUILD_STATUS – 构建结果\n- $PROJECT_NAME – 构建脚本名称\n- $BUILD_NUMBER – 构建脚本编号\n- $JOB_DESCRIPTION – 构建项目描述 \n- $CAUSE – 脚本启动原因\n- $BUILD_URL – 脚本构建详情URL地址\n```\n\n这里选择以HTML的格式展示，填入模板：\n```\n<!DOCTYPE html>    \n<html>    \n<head>    \n<meta charset=\"UTF-8\">    \n<title>${ENV, var=\"JOB_NAME\"}-第${BUILD_NUMBER}次构建日志</title>    \n</head>    \n    \n<body leftmargin=\"8\" marginwidth=\"0\" topmargin=\"8\" marginheight=\"4\"    \n    offset=\"0\">    \n    <table width=\"95%\" cellpadding=\"0\" cellspacing=\"0\"  style=\"font-size: 11pt; font-family: Tahoma, Arial, Helvetica, sans-serif\">    \n        <tr>    \n            本邮件由系统自动发出，无需回复！<br/>            \n            各位同事，大家好，以下为${PROJECT_NAME}项目构建信息</br> \n            <td><font color=\"#CC0000\">构建结果 - ${BUILD_STATUS}</font></td>   \n        </tr>    \n        <tr>    \n            <td><br />    \n            <b><font color=\"#0B610B\">构建信息</font></b>    \n            <hr size=\"2\" width=\"100%\" align=\"center\" /></td>    \n        </tr>    \n        <tr>    \n            <td>    \n                <ul>    \n                    <li>项目名称 ： ${PROJECT_NAME}</li>    \n                    <li>构建编号 ： 第${BUILD_NUMBER}次构建</li>    \n                    <li>触发原因： ${CAUSE}</li>    \n                    <li>构建状态： ${BUILD_STATUS}</li>    \n                    <li>构建日志： <a href=\"${BUILD_URL}console\">${BUILD_URL}console</a></li>    \n                    <li>构建  Url ： <a href=\"${BUILD_URL}\">${BUILD_URL}</a></li>    \n                    <li>工作目录 ： <a href=\"${PROJECT_URL}ws\">${PROJECT_URL}ws</a></li>    \n                    <li>项目  Url ： <a href=\"${PROJECT_URL}\">${PROJECT_URL}</a></li>    \n                </ul>    \n\n<h4><font color=\"#0B610B\">失败用例</font></h4>\n<hr size=\"2\" width=\"100%\" />\n$FAILED_TESTS<br/>\n\n<h4><font color=\"#0B610B\">最近提交(#$SVN_REVISION)</font></h4>\n<hr size=\"2\" width=\"100%\" />\n<ul>\n${CHANGES_SINCE_LAST_SUCCESS, reverse=true, format=\"%c\", changesFormat=\"<li>%d [%a] %m</li>\"}\n</ul>\n详细提交: <a href=\"${PROJECT_URL}changes\">${PROJECT_URL}changes</a><br/>\n\n            </td>    \n        </tr>    \n    </table>    \n</body>    \n</html>\n```\n\n如下图：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8b10b649f4943e1944fc094c72a3d2e~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 3.3 触发条件配置\n\n我们还可以在`Default Triggers`中根据自己的需要配置邮件的触发条件\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4328af1e2934c81b61f8c0429b6313b~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16835dfc64334f0e93a6cb7fd262922a~tplv-k3u1fbpfcp-watermark.image?)\n\n>这里为了防止因为构建一直尝试结果均为失败而造成的邮件轰炸，可以设置邮件仅第一次或第二次构建结果为失败时才发送邮件，后续失败的邮件将不再发送。我选择的是每一次失败和构建成功都会发邮件通知\n\n#### 3.4 jenkins的任务中配置邮件通知\n\n1. 在对应的任务中的构建设置中，勾选`E-mail Notification Recipients`\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/224fb406029d46d489cb6192848fdb6e~tplv-k3u1fbpfcp-watermark.image?)\n\n2. 在对应的任务中的构建后操作中，下拉选择`Editable Email Notification`\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1abc14189c874a818e5fe42a90371e43~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/594c71d3301544e48f6cc7468724b964~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b633844afb7a43e488cd3ab81d7c08a9~tplv-k3u1fbpfcp-watermark.image?)\n\n至此，jnekins的自动化构建的邮件通知已配置完成，在gitlab点击push event发起构建进行测试。\n\n发送成功的话，可看到如下图的提示：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a26d60de670c48ca991975dc2d20fa20~tplv-k3u1fbpfcp-watermark.image?)\n\n## 总结\n\n经过多款插件的安装配置，逐步掌握了如何上床Spring Boot项目到Gitlab中，并使用Jenkins自动构建任务，另外依托于Docker，让这一切变得更加方便，希望大家都多多思考，让机器自动干活，减少我们IT从业人员的重复、繁琐的工作量。\n\n\n', '小白学习gitlab+jenkins进行自动化构建(docker)之springboot项目', 0, 7, 2, 9, 0, '2023-06-09 16:56:30', '2023-06-09 16:56:30', 0);
INSERT INTO `tb_article` VALUES (5, '小白学习gitlab+jenkins进行自动化构建(docker)之springboot项目', '## 前言\ngitlab和jenkins的安装参考我的另外两篇博客：\n* gitlab安装：[小白搭建gitlab(docker)](https://juejin.cn/post/7032898607686778910)\n* jenkins安装：[小白学习搭建jenkins(docker)](https://juejin.cn/post/7032891246490157093/)\n\n## 在Jenkins上安装必要的插件\n所需插件：`Maven Integration`、`Pipeline Maven Integration`、`Gitlab`、`GitLab Authentication`、`SSH`、`Publish Over SSH`、`Docker`\n\n点击 Manage Jenkins（系统管理） ——> Manage Plugins（插件管理）\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5d15509337b44198064ba2bd41f221e~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Maven插件\n\n点击可选插件 ——> 过滤Maven Integration插件 ——> 勾选Maven Integration和Pipeline Maven Integration ——> 点击直接安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e496dbb12972454789d19546d660c88d~tplv-k3u1fbpfcp-watermark.image?)\n\n如图开始安装插件：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/134fef5f496c468b8dad342454c83b45~tplv-k3u1fbpfcp-watermark.image?)\n\n安装完成后，即可在插件管理下的已安装选项卡下看到刚刚已经安装的插件。\n\n#### 安装Gitlab插件\n\n点击可选插件 ——> 过滤Gitlab插件 ——> 勾选Gitlab和Gitlab Authentication ——> 点击直接安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6171674e55b428c9eba7be7cc2f516c~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装SSH插件和Publish Over SSH插件\n安装Publish Over SSH插件的原因：因为本方式是使用docker启动jenkins服务，所以在jenkins后续执行构建任务时候，需要在build成功后，将服务的jar包（以spring boot服务为例）拷贝到Dockerfile所在服务器的指定目录，进行微服务的启动；所以，此处需要配置SSH服务器的连接，意思就是在jenkins的任务结束后，去执行指定的服务器上的shell命令，做spring boot或cloud服务的镜像的构建，容器的运行，等一系列的事情。\n\n点击可选插件 ——> 过滤SSH插件 ——> 勾选SSH和Publish Over SSH ——> 点击直接安装\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d21ba2054860482b8b07684f48468538~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Docker插件\n\n点击可选插件 ——> 过滤Docker插件 ——> 勾选Docker ——> 点击直接安装\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1501abfe94b431a91e5692c41d12f72~tplv-k3u1fbpfcp-watermark.image?)\n\n插件全部安装完成后，可以重启一下Jenkins。\n\n## 相关配置\n\n#### 添加凭据\n\n点击 Manage Jenkins（系统管理） ——> Manage Credentials（凭据管理）\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0d3890020d34004adb05cab48310dd1~tplv-k3u1fbpfcp-watermark.image?)\n\n点击添加凭据 ——> 输入宿主机服务器的用户名和密码等信息并保存\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8eb6e5330d2140cb9705256fc722dc9d~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 配置SSH remote hosts\n\n这个配置是干什么的呢？配置SSH连接Dockerfile所在服务器的相关信息，并添加凭证，最后测试连接并保存，以备后面使用！！！\n\n点击 Manage Jenkins（系统管理） ——> 系统配置\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3813b66e9134305a1acb1d7515110bd~tplv-k3u1fbpfcp-watermark.image?)\n\n找到配置 ——> 下拉选择SSH remote hosts\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7436757a876049db93e6b255662001f2~tplv-k3u1fbpfcp-watermark.image?)\n\n如下图，输入对应的信息，并校验是否连接成功！成功后，点击应用 ——> 点击保存\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3559c64c918c4355aaff8d136e689da9~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 配置Publish over SSH\n\n找到配置 ——> 下拉选择Publish over SSH，进行相关配置即可。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0bb12f108302405ba90bb33e80fd0d5e~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78ad24f26a2a46b68ea44ea1c6ceb537~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de7ba1ca4a074ad1bb6f6a4b8fe71ee3~tplv-k3u1fbpfcp-watermark.image?)\n\n这里配置的数据，目前只能在Post Steps中选中send files or execute commands over ssh使用，要想能够在execute shell script on remote host using ssh方式中使用，需要再配置一份SSH remote hosts和它配套使用\n\n## 全局工具配置\n\n由于我们要实现的是SpringBoot项目的自动化部署操作，所以需要安装JDK、Git、Maven、Docker。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0dec279d6d44a83b2138cd7663e0995~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装JDK\n\n可以安装多个，根据项目JDK版本需求。\n\n输入自定义JDK名称 ——> 勾选自动安装 ——> 输入Oracle账户、密码 ——> 选择JDK版本 ——> 勾选同意协议\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72aa67fd5a494228840c5bef060e36b8~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Git\n\n输入自定义Git名称 ——> 勾选自动安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b49eb7bd11d48ab9ffce4f29431c216~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Maven\n\n输入自定义名称 ——> 勾选自动安装 ——> 选择版本\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5394195a98b647189dfaa5cd74b1a0b0~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Docker\n\n输入自定义名称 ——> 勾选自动安装\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/893704cbe8fe449fb615534bf9e82cea~tplv-k3u1fbpfcp-watermark.image?)\n\n最后，点击应用 ——> 点击保存即可。\n\n## 新建Jenkins任务\n\n### 点击新建任务，输入名称\n\n注意：本名称必须和项目名称一致，因为本名称会在jenkins工作空间下生成目录，类似于IDEA或Eclipse的工作空间的概念。所以，一般情况下，保证本名称=项目名称=docker镜像名称=docker容器名称 这样能尽可能的减轻jenkins配置的shell命令的复杂性！（空间命名要小写：因为镜像名不允许存在大写字母）\n\n选择构建一个Maven项目（因为是Spring Boot的服务）\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5a510bcf4ac49159f3f3b2960ae4fc5~tplv-k3u1fbpfcp-watermark.image?)\n\n### 源码管理\n\n输入描述信息，源码管理选择Git，从gitlab复制克隆地址（http协议的）粘贴到Repository URL中。未添加凭证会报授权失败的错误。错误如下：\n```\n![]()无法连接仓库：Command \"git ls-remote -h -- http://192.168.57.128:8880/root/video-book-backend.git HEAD\" returned status code 128:\\\nstdout:\\\nstderr: remote: HTTP Basic: Access denied\\\nfatal: Authentication failed for \'http://192.168.57.128:8880/root/video-book-backend.git/\'\n```\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94c2477c80724a959f8bb9f461814f41~tplv-k3u1fbpfcp-watermark.image?)\n\n添加gitlab凭证：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e08c1c343564fda9d5c599e985c38f5~tplv-k3u1fbpfcp-watermark.image?)\n\n### 构建触发器\n\n接下来将会生成供gitlab配置webhook使用的URL和Token，请记录下来，后面会使用。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1016fa1f35f24be7bf16ebe0a503bb8e~tplv-k3u1fbpfcp-watermark.image?)\n\n点击高级，拉下来找到Generate并点击，生成一串Secret Token。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13fb693d0ed14c63b8b613cccc7cd5b9~tplv-k3u1fbpfcp-watermark.image?)\n\n### 添加webhook\n\n前往gitlab，进入要构建的项目，在setting中选择Webhooks，输入URL和Secret Token 这两在上面图中已经给你标注了，去掉Enable SSL verification的勾选。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/904006704c604f6da4f2d1989200d462~tplv-k3u1fbpfcp-watermark.image?)\n\n点击Add webhook，如图表示成功添加了webhook：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6928c377f94748d0b70f57189e42e6cd~tplv-k3u1fbpfcp-watermark.image?)\n\n如果添加不成功解决方案请参考：[解决 Url is blocked: Requests to the local network are not allowed](https://www.cnblogs.com/zhongyuanzhao000/p/11379098.html)\n\n### 构建环境\n\n勾选Add timestamps to the Console Output，等下可以看到控制台打印的信息，这个根据自己的需求勾选。\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/badcdddabcc643b19f5a41fdc9f3416e~tplv-k3u1fbpfcp-watermark.image?)\n\n### Pre Steps(构建之前的步骤)\n\n配置前一步需要做的事情是：清理本项目在jenkins的workspace中的历史文件夹。\n\n你可以不用知道WORKSPACE具体的地址在哪里，因为下方有链接可以查看到当前jenkins中有哪些可用的变量供你使用。\n\n默认WORKSPACE地址：`/var/jenkins_home/workspace`（如果你jenkins是docker启动的，并且挂载了目录在宿主机，那你在宿主机也是可以看到的，即 `/usr/local/docker/workspace`）\n\n本处选择的是执行shell，则表示本处配置的shell命令，是默认在jenkins容器中执行的，而不是在宿主机上。\n\n下拉选择执行 shell：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c2e1bd362944ff2aab0a62646bae53d~tplv-k3u1fbpfcp-watermark.image?)\n\n在执行shell的命令中输入以下命令，设置全局变量：\n```\nSERVER_NAME_1=video-book-backend\necho \"=========================>>>>>>>工作空间WORKSPACE的地址：$WORKSPACE \"\ncd $WORKSPACE\necho \"=========================>>>>>>>进入工作空间WORKSPACE，清除工作空间中原项目的工作空间$SERVER_NAME_1 \"\nrm -rf $SERVER_NAME_1\necho \"=========================>>>>>>>清除工作空间中原项目的工作空间$SERVER_NAME_1 ......成功success\"\n```\n注意：本处的SERVER_NAME_1=jenkins-docker-gitlab-springboot是配置项目的名称(和gitlab中的项目名保持一致)\n\n### Build(构建)\n\n我们是SpringBoot项目，所以用到maven，这里设置一下全局操作，clean项目，并打成jar包，所以这里输入：`clean package`\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a41ff4b5061f48f39de4738c6282ec78~tplv-k3u1fbpfcp-watermark.image?)\n\n### Post Steps(执行任务)\n\n只在jenkins构建成功后，才执行这一步。\n\n因为最后的构建成功的maven项目的jar包是以docker启动服务为目的，所以最后的docker操作，一定是在jenkins容器以外的服务器上运行的，可能是本机宿主机，也可能是远程的服务器，这个根据自己的情况去配置。\n\n本处选择，在远程的SSH执行shell脚本。\n\n选中只有构建成功才执行这些命令，然后选择Execute shell script on remote host using ssh。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c25a57ddb8f4b10b31e4832503d4af2~tplv-k3u1fbpfcp-watermark.image?)\n\nshell命令:\n```\n# =====================================================================================\n# =================================定义初始化变量======================================\n# =====================================================================================\n\n# 操作/项目路径(Dockerfile存放的路径，Dockerfile一般都放在项目的根目录下)\n# 如果Dockerfile放在项目根目录的子目录下，则子目录不能与项目同名\n# 会导致在复制jar包的时候，覆盖子目录为jar包,同时没有扩展名jar,原因我暂时不知道\n# 目前我的做法是将Dockerfile放在项目根目录下\nBASE_PATH=/usr/local/docker/jenkins/workspace/video-book-backend\n\n# jenkins构建好的源jar路径\n# 这个路径是jenkins容器挂载在宿主机上的路径\n# 我的jenkins的目录被我挂载在了/usr/local/docker/jenkins上\nSOURCE_PATH=/usr/local/docker/jenkins/workspace\n\n# docker镜像、docker容器、Dockerfile同目录下的jar名字[用它build生成image的jar]、jenkins的workspace下的项目名称\n# 注意统一名称！！！！！\nSERVER_NAME=video-book-backend\n\n# 容器id  [grep -w 全量匹配容器名] [awk 获取信息行的第一列，即容器ID]  [无论容器启动与否，都获取到]\nCID=$(docker ps -a | grep -w \"$SERVER_NAME\" | awk \'{print $1}\')\n\n# 镜像id  [grep -w 全量匹配镜像名] [awk 获取信息行的第三列，即镜像ID]\nIID=$(docker images | grep -w \"$SERVER_NAME\" | awk \'{print $3}\')\n\n# 源jar完整地址[jenkins构建成功后，会在自己的workspace/项目/target下生成maven构建成功的jar包，获取jar包名的完整路径]\n# 例如：/usr/local/docker/jenkins/workspace/video-book-backend/target/video-book-backend-0.0.1-SNAPSHOT.jar\nSOURCE_JAR_PATH=$(find \"$SOURCE_PATH/$SERVER_NAME/target/\"  -name \"*$SERVER_NAME*.jar\" )\n\nDATE=`date +%Y%m%d%H%M%S`\n\n# =====================================================================================\n# ============================对原本已存在的jar进行备份================================\n# =====================================================================================\n\n# 备份\nfunction backup(){\n    if [ -f \"$BASE_PATH/$SERVER_NAME.jar\" ]; then\n        echo \"=========================>>>>>>>$SERVER_NAME.jar 备份...\"\n            mv $BASE_PATH/$SERVER_NAME.jar $BASE_PATH/backup/$SERVER_NAME-$DATE.jar\n        echo \"=========================>>>>>>>备份老的 $SERVER_NAME.jar 完成\"\n\n    else\n        echo \"=========================>>>>>>>老的$BASE_PATH/$SERVER_NAME.jar不存在，跳过备份\"\n    fi\n}\n\n# =====================================================================================\n# =========================移动最新源jar包到Dockerfile所在目录=========================\n# =====================================================================================\n\n\n \n# 查找源jar文件名，进行重命名，最后将源文件移动到Dockerfile文件所在目录\nfunction transfer(){\n      \n    echo \"=========================>>>>>>>源文件完整地址为 $SOURCE_JAR_PATH\"\n\n    echo \"=========================>>>>>>>重命名源文件\"\n        mv $SOURCE_JAR_PATH  $SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar\n\n    echo \"=========================>>>>>>>最新构建代码 将$SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar 迁移至 $BASE_PATH\"\n        cp $SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar $BASE_PATH\n        \n    echo \"=========================>>>>>>>迁移完成Success\"\n\n}\n \n# =====================================================================================\n# ==================================构建最新镜像=======================================\n# =====================================================================================\n\n# 构建docker镜像\nfunction build(){\n    \n    # 无论镜像存在与否，都停止原容器服务，并移除原容器服务\n    echo \"=========================>>>>>>>停止$SERVER_NAME容器，CID=$CID\"\n    docker stop $CID\n\n    echo \"=========================>>>>>>>移除$SERVER_NAME容器，CID=$CID\"\n    docker rm $CID\n\n    # 无论如何，都去构建新的镜像\n    if [ -n \"$IID\" ]; then\n        echo \"=========================>>>>>>>存在$SERVER_NAME镜像，IID=$IID\"\n\n        echo \"=========================>>>>>>>移除老的$SERVER_NAME镜像，IID=$IID\"\n        \n        docker rmi $IID\n\n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，开始---->\"\n        \n        cd $BASE_PATH\n        docker build -t $SERVER_NAME .\n        \n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，完成---->\"\n\n    else\n        echo \"=========================>>>>>>>不存在$SERVER_NAME镜像，构建新的镜像，开始--->\"\n        \n        cd $BASE_PATH\n        docker build -t $SERVER_NAME .\n        \n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，结束--->\"\n    fi\n}\n \n\n# =====================================================================================\n# ==============================运行docker容器，启动服务===============================\n# =====================================================================================\n\n# 运行docker容器\nfunction run(){\n    backup\n    transfer\n    build\n\n    # 创建容器\n    docker run --name $SERVER_NAME -itd --net=host -v /etc/localtime:/etc/localtime:ro  -v /etc/timezone:/etc/timezone:ro  $SERVER_NAME \n\n}\n \n# 入口\nrun\n```\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e67ba6d7cf14d52b00009c09afc9349~tplv-k3u1fbpfcp-watermark.image?)\n\nOK，到这里基本的任务已经新建成功，至于后续的两个步骤，根据自己的需求自行配置，没有难度的。\n\n点击应用，保存。\n\n### 测试\n\n测试push事件触发自动化构建和部署，点击test下拉选择push events，出现HTTP 200表示OK了。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e85f532d1c2b4643996604347b945f51~tplv-k3u1fbpfcp-watermark.image?)\n\n回到Jenkins可以看到任务列表，查看构建信息等。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f954757d41324660ae01ff5de6afe17e~tplv-k3u1fbpfcp-watermark.image?)\n\n待Jenkins构建成功之后，在服务器上执行命令：`docker ps`，可以看到我们启动起来的 SpringBoot 容器：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8556de2ce136416ea36e817b661c2f80~tplv-k3u1fbpfcp-watermark.image?)\n\n## 邮件通知\n\n有时候团队合作，我们希望能通过邮件通知每一个开发者，项目是否构建成功。jenkins/jenkins:2.332.1默认安装了`# Email Extension Template`这个插件，还需要安装`Email Extension Template`这个插件\n\n系统管理->插件管理->可选插件->搜索`Email Extension Template`\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51c60941d3d3422e88db89b5188a3168~tplv-k3u1fbpfcp-watermark.image?)\n\n直接安装\n\n### 配置Email(Jenkins自带)\n\n#### 2.1 基础信息查询\n\n>找到所要配置邮箱的基础信息，这里以QQ邮箱为例\n\n1. 通过网页端QQ邮箱的设置进入到邮箱客户端设置页面\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f31038ef147f4c728540bc581f64d522~tplv-k3u1fbpfcp-watermark.image?)\n\n2. 找到邮箱的基础信息\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5694801b0ed74685a76cade6b358c5fc~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 2.2 Jenkins邮件通知配置\n\n在Jenkins：`系统管理->系统配置`中，最底部找到`邮件通知`，打开`高级`,注意到在配置的下方有个\"通过发送测试邮件测试配置\"，我们可以讲其勾选，填入邮箱地址，点击`Test configuration`来先测试一下邮件的发送。\n\n> 这边最好先保存一下再测试，否则出错，又得重配。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6420215d674647fb824854fd68a3efd6~tplv-k3u1fbpfcp-watermark.image?)\n\n如果报错如下：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8481f74294404047a2671bc8e2a3297e~tplv-k3u1fbpfcp-watermark.image?)\n\n这是因为我们还需要在设置`Jenkins Location`中配置`系统管理员邮件地址`，此地址要和`邮件通知`中的`用户名`一致\n\n### 配置Email(Extended E-mail Notification)\n\n>记得文章一开头提到的下载Extended插件，没错，Jenkins系统设置里还可以通过`Extended E-mail Notification`对邮件发送进行模板格式的自定义\n\n#### 3.1 基础信息配置\n\n基础信息配置与上述一致,唯一要注意的是这里需要重新生成一个授权码\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cb0934380904b098a035e54297946d4~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 3.2 模板格式配置\n\n接3.1配置继续。这里主要就是配置展示的模板格式，常用的格式化的参数有：\n```\n- $BUILD_STATUS – 构建结果\n- $PROJECT_NAME – 构建脚本名称\n- $BUILD_NUMBER – 构建脚本编号\n- $JOB_DESCRIPTION – 构建项目描述 \n- $CAUSE – 脚本启动原因\n- $BUILD_URL – 脚本构建详情URL地址\n```\n\n这里选择以HTML的格式展示，填入模板：\n```\n<!DOCTYPE html>    \n<html>    \n<head>    \n<meta charset=\"UTF-8\">    \n<title>${ENV, var=\"JOB_NAME\"}-第${BUILD_NUMBER}次构建日志</title>    \n</head>    \n    \n<body leftmargin=\"8\" marginwidth=\"0\" topmargin=\"8\" marginheight=\"4\"    \n    offset=\"0\">    \n    <table width=\"95%\" cellpadding=\"0\" cellspacing=\"0\"  style=\"font-size: 11pt; font-family: Tahoma, Arial, Helvetica, sans-serif\">    \n        <tr>    \n            本邮件由系统自动发出，无需回复！<br/>            \n            各位同事，大家好，以下为${PROJECT_NAME}项目构建信息</br> \n            <td><font color=\"#CC0000\">构建结果 - ${BUILD_STATUS}</font></td>   \n        </tr>    \n        <tr>    \n            <td><br />    \n            <b><font color=\"#0B610B\">构建信息</font></b>    \n            <hr size=\"2\" width=\"100%\" align=\"center\" /></td>    \n        </tr>    \n        <tr>    \n            <td>    \n                <ul>    \n                    <li>项目名称 ： ${PROJECT_NAME}</li>    \n                    <li>构建编号 ： 第${BUILD_NUMBER}次构建</li>    \n                    <li>触发原因： ${CAUSE}</li>    \n                    <li>构建状态： ${BUILD_STATUS}</li>    \n                    <li>构建日志： <a href=\"${BUILD_URL}console\">${BUILD_URL}console</a></li>    \n                    <li>构建  Url ： <a href=\"${BUILD_URL}\">${BUILD_URL}</a></li>    \n                    <li>工作目录 ： <a href=\"${PROJECT_URL}ws\">${PROJECT_URL}ws</a></li>    \n                    <li>项目  Url ： <a href=\"${PROJECT_URL}\">${PROJECT_URL}</a></li>    \n                </ul>    \n\n<h4><font color=\"#0B610B\">失败用例</font></h4>\n<hr size=\"2\" width=\"100%\" />\n$FAILED_TESTS<br/>\n\n<h4><font color=\"#0B610B\">最近提交(#$SVN_REVISION)</font></h4>\n<hr size=\"2\" width=\"100%\" />\n<ul>\n${CHANGES_SINCE_LAST_SUCCESS, reverse=true, format=\"%c\", changesFormat=\"<li>%d [%a] %m</li>\"}\n</ul>\n详细提交: <a href=\"${PROJECT_URL}changes\">${PROJECT_URL}changes</a><br/>\n\n            </td>    \n        </tr>    \n    </table>    \n</body>    \n</html>\n```\n\n如下图：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8b10b649f4943e1944fc094c72a3d2e~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 3.3 触发条件配置\n\n我们还可以在`Default Triggers`中根据自己的需要配置邮件的触发条件\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4328af1e2934c81b61f8c0429b6313b~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16835dfc64334f0e93a6cb7fd262922a~tplv-k3u1fbpfcp-watermark.image?)\n\n>这里为了防止因为构建一直尝试结果均为失败而造成的邮件轰炸，可以设置邮件仅第一次或第二次构建结果为失败时才发送邮件，后续失败的邮件将不再发送。我选择的是每一次失败和构建成功都会发邮件通知\n\n#### 3.4 jenkins的任务中配置邮件通知\n\n1. 在对应的任务中的构建设置中，勾选`E-mail Notification Recipients`\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/224fb406029d46d489cb6192848fdb6e~tplv-k3u1fbpfcp-watermark.image?)\n\n2. 在对应的任务中的构建后操作中，下拉选择`Editable Email Notification`\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1abc14189c874a818e5fe42a90371e43~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/594c71d3301544e48f6cc7468724b964~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b633844afb7a43e488cd3ab81d7c08a9~tplv-k3u1fbpfcp-watermark.image?)\n\n至此，jnekins的自动化构建的邮件通知已配置完成，在gitlab点击push event发起构建进行测试。\n\n发送成功的话，可看到如下图的提示：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a26d60de670c48ca991975dc2d20fa20~tplv-k3u1fbpfcp-watermark.image?)\n\n## 总结\n\n经过多款插件的安装配置，逐步掌握了如何上床Spring Boot项目到Gitlab中，并使用Jenkins自动构建任务，另外依托于Docker，让这一切变得更加方便，希望大家都多多思考，让机器自动干活，减少我们IT从业人员的重复、繁琐的工作量。\n\n\n', '小白学习gitlab+jenkins进行自动化构建(docker)之springboot项目', 0, 7, 2, 9, 0, '2023-06-09 16:56:30', '2023-06-09 16:56:30', 0);
INSERT INTO `tb_article` VALUES (6, '小白学习gitlab+jenkins进行自动化构建(docker)之springboot项目', '## 前言\ngitlab和jenkins的安装参考我的另外两篇博客：\n* gitlab安装：[小白搭建gitlab(docker)](https://juejin.cn/post/7032898607686778910)\n* jenkins安装：[小白学习搭建jenkins(docker)](https://juejin.cn/post/7032891246490157093/)\n\n## 在Jenkins上安装必要的插件\n所需插件：`Maven Integration`、`Pipeline Maven Integration`、`Gitlab`、`GitLab Authentication`、`SSH`、`Publish Over SSH`、`Docker`\n\n点击 Manage Jenkins（系统管理） ——> Manage Plugins（插件管理）\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5d15509337b44198064ba2bd41f221e~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Maven插件\n\n点击可选插件 ——> 过滤Maven Integration插件 ——> 勾选Maven Integration和Pipeline Maven Integration ——> 点击直接安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e496dbb12972454789d19546d660c88d~tplv-k3u1fbpfcp-watermark.image?)\n\n如图开始安装插件：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/134fef5f496c468b8dad342454c83b45~tplv-k3u1fbpfcp-watermark.image?)\n\n安装完成后，即可在插件管理下的已安装选项卡下看到刚刚已经安装的插件。\n\n#### 安装Gitlab插件\n\n点击可选插件 ——> 过滤Gitlab插件 ——> 勾选Gitlab和Gitlab Authentication ——> 点击直接安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6171674e55b428c9eba7be7cc2f516c~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装SSH插件和Publish Over SSH插件\n安装Publish Over SSH插件的原因：因为本方式是使用docker启动jenkins服务，所以在jenkins后续执行构建任务时候，需要在build成功后，将服务的jar包（以spring boot服务为例）拷贝到Dockerfile所在服务器的指定目录，进行微服务的启动；所以，此处需要配置SSH服务器的连接，意思就是在jenkins的任务结束后，去执行指定的服务器上的shell命令，做spring boot或cloud服务的镜像的构建，容器的运行，等一系列的事情。\n\n点击可选插件 ——> 过滤SSH插件 ——> 勾选SSH和Publish Over SSH ——> 点击直接安装\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d21ba2054860482b8b07684f48468538~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Docker插件\n\n点击可选插件 ——> 过滤Docker插件 ——> 勾选Docker ——> 点击直接安装\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1501abfe94b431a91e5692c41d12f72~tplv-k3u1fbpfcp-watermark.image?)\n\n插件全部安装完成后，可以重启一下Jenkins。\n\n## 相关配置\n\n#### 添加凭据\n\n点击 Manage Jenkins（系统管理） ——> Manage Credentials（凭据管理）\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0d3890020d34004adb05cab48310dd1~tplv-k3u1fbpfcp-watermark.image?)\n\n点击添加凭据 ——> 输入宿主机服务器的用户名和密码等信息并保存\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8eb6e5330d2140cb9705256fc722dc9d~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 配置SSH remote hosts\n\n这个配置是干什么的呢？配置SSH连接Dockerfile所在服务器的相关信息，并添加凭证，最后测试连接并保存，以备后面使用！！！\n\n点击 Manage Jenkins（系统管理） ——> 系统配置\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3813b66e9134305a1acb1d7515110bd~tplv-k3u1fbpfcp-watermark.image?)\n\n找到配置 ——> 下拉选择SSH remote hosts\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7436757a876049db93e6b255662001f2~tplv-k3u1fbpfcp-watermark.image?)\n\n如下图，输入对应的信息，并校验是否连接成功！成功后，点击应用 ——> 点击保存\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3559c64c918c4355aaff8d136e689da9~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 配置Publish over SSH\n\n找到配置 ——> 下拉选择Publish over SSH，进行相关配置即可。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0bb12f108302405ba90bb33e80fd0d5e~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78ad24f26a2a46b68ea44ea1c6ceb537~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de7ba1ca4a074ad1bb6f6a4b8fe71ee3~tplv-k3u1fbpfcp-watermark.image?)\n\n这里配置的数据，目前只能在Post Steps中选中send files or execute commands over ssh使用，要想能够在execute shell script on remote host using ssh方式中使用，需要再配置一份SSH remote hosts和它配套使用\n\n## 全局工具配置\n\n由于我们要实现的是SpringBoot项目的自动化部署操作，所以需要安装JDK、Git、Maven、Docker。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0dec279d6d44a83b2138cd7663e0995~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装JDK\n\n可以安装多个，根据项目JDK版本需求。\n\n输入自定义JDK名称 ——> 勾选自动安装 ——> 输入Oracle账户、密码 ——> 选择JDK版本 ——> 勾选同意协议\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72aa67fd5a494228840c5bef060e36b8~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Git\n\n输入自定义Git名称 ——> 勾选自动安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b49eb7bd11d48ab9ffce4f29431c216~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Maven\n\n输入自定义名称 ——> 勾选自动安装 ——> 选择版本\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5394195a98b647189dfaa5cd74b1a0b0~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Docker\n\n输入自定义名称 ——> 勾选自动安装\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/893704cbe8fe449fb615534bf9e82cea~tplv-k3u1fbpfcp-watermark.image?)\n\n最后，点击应用 ——> 点击保存即可。\n\n## 新建Jenkins任务\n\n### 点击新建任务，输入名称\n\n注意：本名称必须和项目名称一致，因为本名称会在jenkins工作空间下生成目录，类似于IDEA或Eclipse的工作空间的概念。所以，一般情况下，保证本名称=项目名称=docker镜像名称=docker容器名称 这样能尽可能的减轻jenkins配置的shell命令的复杂性！（空间命名要小写：因为镜像名不允许存在大写字母）\n\n选择构建一个Maven项目（因为是Spring Boot的服务）\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5a510bcf4ac49159f3f3b2960ae4fc5~tplv-k3u1fbpfcp-watermark.image?)\n\n### 源码管理\n\n输入描述信息，源码管理选择Git，从gitlab复制克隆地址（http协议的）粘贴到Repository URL中。未添加凭证会报授权失败的错误。错误如下：\n```\n![]()无法连接仓库：Command \"git ls-remote -h -- http://192.168.57.128:8880/root/video-book-backend.git HEAD\" returned status code 128:\\\nstdout:\\\nstderr: remote: HTTP Basic: Access denied\\\nfatal: Authentication failed for \'http://192.168.57.128:8880/root/video-book-backend.git/\'\n```\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94c2477c80724a959f8bb9f461814f41~tplv-k3u1fbpfcp-watermark.image?)\n\n添加gitlab凭证：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e08c1c343564fda9d5c599e985c38f5~tplv-k3u1fbpfcp-watermark.image?)\n\n### 构建触发器\n\n接下来将会生成供gitlab配置webhook使用的URL和Token，请记录下来，后面会使用。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1016fa1f35f24be7bf16ebe0a503bb8e~tplv-k3u1fbpfcp-watermark.image?)\n\n点击高级，拉下来找到Generate并点击，生成一串Secret Token。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13fb693d0ed14c63b8b613cccc7cd5b9~tplv-k3u1fbpfcp-watermark.image?)\n\n### 添加webhook\n\n前往gitlab，进入要构建的项目，在setting中选择Webhooks，输入URL和Secret Token 这两在上面图中已经给你标注了，去掉Enable SSL verification的勾选。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/904006704c604f6da4f2d1989200d462~tplv-k3u1fbpfcp-watermark.image?)\n\n点击Add webhook，如图表示成功添加了webhook：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6928c377f94748d0b70f57189e42e6cd~tplv-k3u1fbpfcp-watermark.image?)\n\n如果添加不成功解决方案请参考：[解决 Url is blocked: Requests to the local network are not allowed](https://www.cnblogs.com/zhongyuanzhao000/p/11379098.html)\n\n### 构建环境\n\n勾选Add timestamps to the Console Output，等下可以看到控制台打印的信息，这个根据自己的需求勾选。\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/badcdddabcc643b19f5a41fdc9f3416e~tplv-k3u1fbpfcp-watermark.image?)\n\n### Pre Steps(构建之前的步骤)\n\n配置前一步需要做的事情是：清理本项目在jenkins的workspace中的历史文件夹。\n\n你可以不用知道WORKSPACE具体的地址在哪里，因为下方有链接可以查看到当前jenkins中有哪些可用的变量供你使用。\n\n默认WORKSPACE地址：`/var/jenkins_home/workspace`（如果你jenkins是docker启动的，并且挂载了目录在宿主机，那你在宿主机也是可以看到的，即 `/usr/local/docker/workspace`）\n\n本处选择的是执行shell，则表示本处配置的shell命令，是默认在jenkins容器中执行的，而不是在宿主机上。\n\n下拉选择执行 shell：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c2e1bd362944ff2aab0a62646bae53d~tplv-k3u1fbpfcp-watermark.image?)\n\n在执行shell的命令中输入以下命令，设置全局变量：\n```\nSERVER_NAME_1=video-book-backend\necho \"=========================>>>>>>>工作空间WORKSPACE的地址：$WORKSPACE \"\ncd $WORKSPACE\necho \"=========================>>>>>>>进入工作空间WORKSPACE，清除工作空间中原项目的工作空间$SERVER_NAME_1 \"\nrm -rf $SERVER_NAME_1\necho \"=========================>>>>>>>清除工作空间中原项目的工作空间$SERVER_NAME_1 ......成功success\"\n```\n注意：本处的SERVER_NAME_1=jenkins-docker-gitlab-springboot是配置项目的名称(和gitlab中的项目名保持一致)\n\n### Build(构建)\n\n我们是SpringBoot项目，所以用到maven，这里设置一下全局操作，clean项目，并打成jar包，所以这里输入：`clean package`\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a41ff4b5061f48f39de4738c6282ec78~tplv-k3u1fbpfcp-watermark.image?)\n\n### Post Steps(执行任务)\n\n只在jenkins构建成功后，才执行这一步。\n\n因为最后的构建成功的maven项目的jar包是以docker启动服务为目的，所以最后的docker操作，一定是在jenkins容器以外的服务器上运行的，可能是本机宿主机，也可能是远程的服务器，这个根据自己的情况去配置。\n\n本处选择，在远程的SSH执行shell脚本。\n\n选中只有构建成功才执行这些命令，然后选择Execute shell script on remote host using ssh。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c25a57ddb8f4b10b31e4832503d4af2~tplv-k3u1fbpfcp-watermark.image?)\n\nshell命令:\n```\n# =====================================================================================\n# =================================定义初始化变量======================================\n# =====================================================================================\n\n# 操作/项目路径(Dockerfile存放的路径，Dockerfile一般都放在项目的根目录下)\n# 如果Dockerfile放在项目根目录的子目录下，则子目录不能与项目同名\n# 会导致在复制jar包的时候，覆盖子目录为jar包,同时没有扩展名jar,原因我暂时不知道\n# 目前我的做法是将Dockerfile放在项目根目录下\nBASE_PATH=/usr/local/docker/jenkins/workspace/video-book-backend\n\n# jenkins构建好的源jar路径\n# 这个路径是jenkins容器挂载在宿主机上的路径\n# 我的jenkins的目录被我挂载在了/usr/local/docker/jenkins上\nSOURCE_PATH=/usr/local/docker/jenkins/workspace\n\n# docker镜像、docker容器、Dockerfile同目录下的jar名字[用它build生成image的jar]、jenkins的workspace下的项目名称\n# 注意统一名称！！！！！\nSERVER_NAME=video-book-backend\n\n# 容器id  [grep -w 全量匹配容器名] [awk 获取信息行的第一列，即容器ID]  [无论容器启动与否，都获取到]\nCID=$(docker ps -a | grep -w \"$SERVER_NAME\" | awk \'{print $1}\')\n\n# 镜像id  [grep -w 全量匹配镜像名] [awk 获取信息行的第三列，即镜像ID]\nIID=$(docker images | grep -w \"$SERVER_NAME\" | awk \'{print $3}\')\n\n# 源jar完整地址[jenkins构建成功后，会在自己的workspace/项目/target下生成maven构建成功的jar包，获取jar包名的完整路径]\n# 例如：/usr/local/docker/jenkins/workspace/video-book-backend/target/video-book-backend-0.0.1-SNAPSHOT.jar\nSOURCE_JAR_PATH=$(find \"$SOURCE_PATH/$SERVER_NAME/target/\"  -name \"*$SERVER_NAME*.jar\" )\n\nDATE=`date +%Y%m%d%H%M%S`\n\n# =====================================================================================\n# ============================对原本已存在的jar进行备份================================\n# =====================================================================================\n\n# 备份\nfunction backup(){\n    if [ -f \"$BASE_PATH/$SERVER_NAME.jar\" ]; then\n        echo \"=========================>>>>>>>$SERVER_NAME.jar 备份...\"\n            mv $BASE_PATH/$SERVER_NAME.jar $BASE_PATH/backup/$SERVER_NAME-$DATE.jar\n        echo \"=========================>>>>>>>备份老的 $SERVER_NAME.jar 完成\"\n\n    else\n        echo \"=========================>>>>>>>老的$BASE_PATH/$SERVER_NAME.jar不存在，跳过备份\"\n    fi\n}\n\n# =====================================================================================\n# =========================移动最新源jar包到Dockerfile所在目录=========================\n# =====================================================================================\n\n\n \n# 查找源jar文件名，进行重命名，最后将源文件移动到Dockerfile文件所在目录\nfunction transfer(){\n      \n    echo \"=========================>>>>>>>源文件完整地址为 $SOURCE_JAR_PATH\"\n\n    echo \"=========================>>>>>>>重命名源文件\"\n        mv $SOURCE_JAR_PATH  $SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar\n\n    echo \"=========================>>>>>>>最新构建代码 将$SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar 迁移至 $BASE_PATH\"\n        cp $SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar $BASE_PATH\n        \n    echo \"=========================>>>>>>>迁移完成Success\"\n\n}\n \n# =====================================================================================\n# ==================================构建最新镜像=======================================\n# =====================================================================================\n\n# 构建docker镜像\nfunction build(){\n    \n    # 无论镜像存在与否，都停止原容器服务，并移除原容器服务\n    echo \"=========================>>>>>>>停止$SERVER_NAME容器，CID=$CID\"\n    docker stop $CID\n\n    echo \"=========================>>>>>>>移除$SERVER_NAME容器，CID=$CID\"\n    docker rm $CID\n\n    # 无论如何，都去构建新的镜像\n    if [ -n \"$IID\" ]; then\n        echo \"=========================>>>>>>>存在$SERVER_NAME镜像，IID=$IID\"\n\n        echo \"=========================>>>>>>>移除老的$SERVER_NAME镜像，IID=$IID\"\n        \n        docker rmi $IID\n\n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，开始---->\"\n        \n        cd $BASE_PATH\n        docker build -t $SERVER_NAME .\n        \n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，完成---->\"\n\n    else\n        echo \"=========================>>>>>>>不存在$SERVER_NAME镜像，构建新的镜像，开始--->\"\n        \n        cd $BASE_PATH\n        docker build -t $SERVER_NAME .\n        \n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，结束--->\"\n    fi\n}\n \n\n# =====================================================================================\n# ==============================运行docker容器，启动服务===============================\n# =====================================================================================\n\n# 运行docker容器\nfunction run(){\n    backup\n    transfer\n    build\n\n    # 创建容器\n    docker run --name $SERVER_NAME -itd --net=host -v /etc/localtime:/etc/localtime:ro  -v /etc/timezone:/etc/timezone:ro  $SERVER_NAME \n\n}\n \n# 入口\nrun\n```\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e67ba6d7cf14d52b00009c09afc9349~tplv-k3u1fbpfcp-watermark.image?)\n\nOK，到这里基本的任务已经新建成功，至于后续的两个步骤，根据自己的需求自行配置，没有难度的。\n\n点击应用，保存。\n\n### 测试\n\n测试push事件触发自动化构建和部署，点击test下拉选择push events，出现HTTP 200表示OK了。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e85f532d1c2b4643996604347b945f51~tplv-k3u1fbpfcp-watermark.image?)\n\n回到Jenkins可以看到任务列表，查看构建信息等。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f954757d41324660ae01ff5de6afe17e~tplv-k3u1fbpfcp-watermark.image?)\n\n待Jenkins构建成功之后，在服务器上执行命令：`docker ps`，可以看到我们启动起来的 SpringBoot 容器：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8556de2ce136416ea36e817b661c2f80~tplv-k3u1fbpfcp-watermark.image?)\n\n## 邮件通知\n\n有时候团队合作，我们希望能通过邮件通知每一个开发者，项目是否构建成功。jenkins/jenkins:2.332.1默认安装了`# Email Extension Template`这个插件，还需要安装`Email Extension Template`这个插件\n\n系统管理->插件管理->可选插件->搜索`Email Extension Template`\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51c60941d3d3422e88db89b5188a3168~tplv-k3u1fbpfcp-watermark.image?)\n\n直接安装\n\n### 配置Email(Jenkins自带)\n\n#### 2.1 基础信息查询\n\n>找到所要配置邮箱的基础信息，这里以QQ邮箱为例\n\n1. 通过网页端QQ邮箱的设置进入到邮箱客户端设置页面\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f31038ef147f4c728540bc581f64d522~tplv-k3u1fbpfcp-watermark.image?)\n\n2. 找到邮箱的基础信息\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5694801b0ed74685a76cade6b358c5fc~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 2.2 Jenkins邮件通知配置\n\n在Jenkins：`系统管理->系统配置`中，最底部找到`邮件通知`，打开`高级`,注意到在配置的下方有个\"通过发送测试邮件测试配置\"，我们可以讲其勾选，填入邮箱地址，点击`Test configuration`来先测试一下邮件的发送。\n\n> 这边最好先保存一下再测试，否则出错，又得重配。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6420215d674647fb824854fd68a3efd6~tplv-k3u1fbpfcp-watermark.image?)\n\n如果报错如下：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8481f74294404047a2671bc8e2a3297e~tplv-k3u1fbpfcp-watermark.image?)\n\n这是因为我们还需要在设置`Jenkins Location`中配置`系统管理员邮件地址`，此地址要和`邮件通知`中的`用户名`一致\n\n### 配置Email(Extended E-mail Notification)\n\n>记得文章一开头提到的下载Extended插件，没错，Jenkins系统设置里还可以通过`Extended E-mail Notification`对邮件发送进行模板格式的自定义\n\n#### 3.1 基础信息配置\n\n基础信息配置与上述一致,唯一要注意的是这里需要重新生成一个授权码\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cb0934380904b098a035e54297946d4~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 3.2 模板格式配置\n\n接3.1配置继续。这里主要就是配置展示的模板格式，常用的格式化的参数有：\n```\n- $BUILD_STATUS – 构建结果\n- $PROJECT_NAME – 构建脚本名称\n- $BUILD_NUMBER – 构建脚本编号\n- $JOB_DESCRIPTION – 构建项目描述 \n- $CAUSE – 脚本启动原因\n- $BUILD_URL – 脚本构建详情URL地址\n```\n\n这里选择以HTML的格式展示，填入模板：\n```\n<!DOCTYPE html>    \n<html>    \n<head>    \n<meta charset=\"UTF-8\">    \n<title>${ENV, var=\"JOB_NAME\"}-第${BUILD_NUMBER}次构建日志</title>    \n</head>    \n    \n<body leftmargin=\"8\" marginwidth=\"0\" topmargin=\"8\" marginheight=\"4\"    \n    offset=\"0\">    \n    <table width=\"95%\" cellpadding=\"0\" cellspacing=\"0\"  style=\"font-size: 11pt; font-family: Tahoma, Arial, Helvetica, sans-serif\">    \n        <tr>    \n            本邮件由系统自动发出，无需回复！<br/>            \n            各位同事，大家好，以下为${PROJECT_NAME}项目构建信息</br> \n            <td><font color=\"#CC0000\">构建结果 - ${BUILD_STATUS}</font></td>   \n        </tr>    \n        <tr>    \n            <td><br />    \n            <b><font color=\"#0B610B\">构建信息</font></b>    \n            <hr size=\"2\" width=\"100%\" align=\"center\" /></td>    \n        </tr>    \n        <tr>    \n            <td>    \n                <ul>    \n                    <li>项目名称 ： ${PROJECT_NAME}</li>    \n                    <li>构建编号 ： 第${BUILD_NUMBER}次构建</li>    \n                    <li>触发原因： ${CAUSE}</li>    \n                    <li>构建状态： ${BUILD_STATUS}</li>    \n                    <li>构建日志： <a href=\"${BUILD_URL}console\">${BUILD_URL}console</a></li>    \n                    <li>构建  Url ： <a href=\"${BUILD_URL}\">${BUILD_URL}</a></li>    \n                    <li>工作目录 ： <a href=\"${PROJECT_URL}ws\">${PROJECT_URL}ws</a></li>    \n                    <li>项目  Url ： <a href=\"${PROJECT_URL}\">${PROJECT_URL}</a></li>    \n                </ul>    \n\n<h4><font color=\"#0B610B\">失败用例</font></h4>\n<hr size=\"2\" width=\"100%\" />\n$FAILED_TESTS<br/>\n\n<h4><font color=\"#0B610B\">最近提交(#$SVN_REVISION)</font></h4>\n<hr size=\"2\" width=\"100%\" />\n<ul>\n${CHANGES_SINCE_LAST_SUCCESS, reverse=true, format=\"%c\", changesFormat=\"<li>%d [%a] %m</li>\"}\n</ul>\n详细提交: <a href=\"${PROJECT_URL}changes\">${PROJECT_URL}changes</a><br/>\n\n            </td>    \n        </tr>    \n    </table>    \n</body>    \n</html>\n```\n\n如下图：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8b10b649f4943e1944fc094c72a3d2e~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 3.3 触发条件配置\n\n我们还可以在`Default Triggers`中根据自己的需要配置邮件的触发条件\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4328af1e2934c81b61f8c0429b6313b~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16835dfc64334f0e93a6cb7fd262922a~tplv-k3u1fbpfcp-watermark.image?)\n\n>这里为了防止因为构建一直尝试结果均为失败而造成的邮件轰炸，可以设置邮件仅第一次或第二次构建结果为失败时才发送邮件，后续失败的邮件将不再发送。我选择的是每一次失败和构建成功都会发邮件通知\n\n#### 3.4 jenkins的任务中配置邮件通知\n\n1. 在对应的任务中的构建设置中，勾选`E-mail Notification Recipients`\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/224fb406029d46d489cb6192848fdb6e~tplv-k3u1fbpfcp-watermark.image?)\n\n2. 在对应的任务中的构建后操作中，下拉选择`Editable Email Notification`\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1abc14189c874a818e5fe42a90371e43~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/594c71d3301544e48f6cc7468724b964~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b633844afb7a43e488cd3ab81d7c08a9~tplv-k3u1fbpfcp-watermark.image?)\n\n至此，jnekins的自动化构建的邮件通知已配置完成，在gitlab点击push event发起构建进行测试。\n\n发送成功的话，可看到如下图的提示：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a26d60de670c48ca991975dc2d20fa20~tplv-k3u1fbpfcp-watermark.image?)\n\n## 总结\n\n经过多款插件的安装配置，逐步掌握了如何上床Spring Boot项目到Gitlab中，并使用Jenkins自动构建任务，另外依托于Docker，让这一切变得更加方便，希望大家都多多思考，让机器自动干活，减少我们IT从业人员的重复、繁琐的工作量。\n\n\n', '小白学习gitlab+jenkins进行自动化构建(docker)之springboot项目', 0, 7, 2, 9, 0, '2023-06-09 16:56:30', '2023-06-09 16:56:30', 0);
INSERT INTO `tb_article` VALUES (7, '小白学习gitlab+jenkins进行自动化构建(docker)之springboot项目', '## 前言\ngitlab和jenkins的安装参考我的另外两篇博客：\n* gitlab安装：[小白搭建gitlab(docker)](https://juejin.cn/post/7032898607686778910)\n* jenkins安装：[小白学习搭建jenkins(docker)](https://juejin.cn/post/7032891246490157093/)\n\n## 在Jenkins上安装必要的插件\n所需插件：`Maven Integration`、`Pipeline Maven Integration`、`Gitlab`、`GitLab Authentication`、`SSH`、`Publish Over SSH`、`Docker`\n\n点击 Manage Jenkins（系统管理） ——> Manage Plugins（插件管理）\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5d15509337b44198064ba2bd41f221e~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Maven插件\n\n点击可选插件 ——> 过滤Maven Integration插件 ——> 勾选Maven Integration和Pipeline Maven Integration ——> 点击直接安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e496dbb12972454789d19546d660c88d~tplv-k3u1fbpfcp-watermark.image?)\n\n如图开始安装插件：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/134fef5f496c468b8dad342454c83b45~tplv-k3u1fbpfcp-watermark.image?)\n\n安装完成后，即可在插件管理下的已安装选项卡下看到刚刚已经安装的插件。\n\n#### 安装Gitlab插件\n\n点击可选插件 ——> 过滤Gitlab插件 ——> 勾选Gitlab和Gitlab Authentication ——> 点击直接安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6171674e55b428c9eba7be7cc2f516c~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装SSH插件和Publish Over SSH插件\n安装Publish Over SSH插件的原因：因为本方式是使用docker启动jenkins服务，所以在jenkins后续执行构建任务时候，需要在build成功后，将服务的jar包（以spring boot服务为例）拷贝到Dockerfile所在服务器的指定目录，进行微服务的启动；所以，此处需要配置SSH服务器的连接，意思就是在jenkins的任务结束后，去执行指定的服务器上的shell命令，做spring boot或cloud服务的镜像的构建，容器的运行，等一系列的事情。\n\n点击可选插件 ——> 过滤SSH插件 ——> 勾选SSH和Publish Over SSH ——> 点击直接安装\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d21ba2054860482b8b07684f48468538~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Docker插件\n\n点击可选插件 ——> 过滤Docker插件 ——> 勾选Docker ——> 点击直接安装\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1501abfe94b431a91e5692c41d12f72~tplv-k3u1fbpfcp-watermark.image?)\n\n插件全部安装完成后，可以重启一下Jenkins。\n\n## 相关配置\n\n#### 添加凭据\n\n点击 Manage Jenkins（系统管理） ——> Manage Credentials（凭据管理）\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0d3890020d34004adb05cab48310dd1~tplv-k3u1fbpfcp-watermark.image?)\n\n点击添加凭据 ——> 输入宿主机服务器的用户名和密码等信息并保存\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8eb6e5330d2140cb9705256fc722dc9d~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 配置SSH remote hosts\n\n这个配置是干什么的呢？配置SSH连接Dockerfile所在服务器的相关信息，并添加凭证，最后测试连接并保存，以备后面使用！！！\n\n点击 Manage Jenkins（系统管理） ——> 系统配置\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3813b66e9134305a1acb1d7515110bd~tplv-k3u1fbpfcp-watermark.image?)\n\n找到配置 ——> 下拉选择SSH remote hosts\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7436757a876049db93e6b255662001f2~tplv-k3u1fbpfcp-watermark.image?)\n\n如下图，输入对应的信息，并校验是否连接成功！成功后，点击应用 ——> 点击保存\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3559c64c918c4355aaff8d136e689da9~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 配置Publish over SSH\n\n找到配置 ——> 下拉选择Publish over SSH，进行相关配置即可。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0bb12f108302405ba90bb33e80fd0d5e~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78ad24f26a2a46b68ea44ea1c6ceb537~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de7ba1ca4a074ad1bb6f6a4b8fe71ee3~tplv-k3u1fbpfcp-watermark.image?)\n\n这里配置的数据，目前只能在Post Steps中选中send files or execute commands over ssh使用，要想能够在execute shell script on remote host using ssh方式中使用，需要再配置一份SSH remote hosts和它配套使用\n\n## 全局工具配置\n\n由于我们要实现的是SpringBoot项目的自动化部署操作，所以需要安装JDK、Git、Maven、Docker。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0dec279d6d44a83b2138cd7663e0995~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装JDK\n\n可以安装多个，根据项目JDK版本需求。\n\n输入自定义JDK名称 ——> 勾选自动安装 ——> 输入Oracle账户、密码 ——> 选择JDK版本 ——> 勾选同意协议\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72aa67fd5a494228840c5bef060e36b8~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Git\n\n输入自定义Git名称 ——> 勾选自动安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b49eb7bd11d48ab9ffce4f29431c216~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Maven\n\n输入自定义名称 ——> 勾选自动安装 ——> 选择版本\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5394195a98b647189dfaa5cd74b1a0b0~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Docker\n\n输入自定义名称 ——> 勾选自动安装\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/893704cbe8fe449fb615534bf9e82cea~tplv-k3u1fbpfcp-watermark.image?)\n\n最后，点击应用 ——> 点击保存即可。\n\n## 新建Jenkins任务\n\n### 点击新建任务，输入名称\n\n注意：本名称必须和项目名称一致，因为本名称会在jenkins工作空间下生成目录，类似于IDEA或Eclipse的工作空间的概念。所以，一般情况下，保证本名称=项目名称=docker镜像名称=docker容器名称 这样能尽可能的减轻jenkins配置的shell命令的复杂性！（空间命名要小写：因为镜像名不允许存在大写字母）\n\n选择构建一个Maven项目（因为是Spring Boot的服务）\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5a510bcf4ac49159f3f3b2960ae4fc5~tplv-k3u1fbpfcp-watermark.image?)\n\n### 源码管理\n\n输入描述信息，源码管理选择Git，从gitlab复制克隆地址（http协议的）粘贴到Repository URL中。未添加凭证会报授权失败的错误。错误如下：\n```\n![]()无法连接仓库：Command \"git ls-remote -h -- http://192.168.57.128:8880/root/video-book-backend.git HEAD\" returned status code 128:\\\nstdout:\\\nstderr: remote: HTTP Basic: Access denied\\\nfatal: Authentication failed for \'http://192.168.57.128:8880/root/video-book-backend.git/\'\n```\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94c2477c80724a959f8bb9f461814f41~tplv-k3u1fbpfcp-watermark.image?)\n\n添加gitlab凭证：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e08c1c343564fda9d5c599e985c38f5~tplv-k3u1fbpfcp-watermark.image?)\n\n### 构建触发器\n\n接下来将会生成供gitlab配置webhook使用的URL和Token，请记录下来，后面会使用。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1016fa1f35f24be7bf16ebe0a503bb8e~tplv-k3u1fbpfcp-watermark.image?)\n\n点击高级，拉下来找到Generate并点击，生成一串Secret Token。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13fb693d0ed14c63b8b613cccc7cd5b9~tplv-k3u1fbpfcp-watermark.image?)\n\n### 添加webhook\n\n前往gitlab，进入要构建的项目，在setting中选择Webhooks，输入URL和Secret Token 这两在上面图中已经给你标注了，去掉Enable SSL verification的勾选。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/904006704c604f6da4f2d1989200d462~tplv-k3u1fbpfcp-watermark.image?)\n\n点击Add webhook，如图表示成功添加了webhook：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6928c377f94748d0b70f57189e42e6cd~tplv-k3u1fbpfcp-watermark.image?)\n\n如果添加不成功解决方案请参考：[解决 Url is blocked: Requests to the local network are not allowed](https://www.cnblogs.com/zhongyuanzhao000/p/11379098.html)\n\n### 构建环境\n\n勾选Add timestamps to the Console Output，等下可以看到控制台打印的信息，这个根据自己的需求勾选。\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/badcdddabcc643b19f5a41fdc9f3416e~tplv-k3u1fbpfcp-watermark.image?)\n\n### Pre Steps(构建之前的步骤)\n\n配置前一步需要做的事情是：清理本项目在jenkins的workspace中的历史文件夹。\n\n你可以不用知道WORKSPACE具体的地址在哪里，因为下方有链接可以查看到当前jenkins中有哪些可用的变量供你使用。\n\n默认WORKSPACE地址：`/var/jenkins_home/workspace`（如果你jenkins是docker启动的，并且挂载了目录在宿主机，那你在宿主机也是可以看到的，即 `/usr/local/docker/workspace`）\n\n本处选择的是执行shell，则表示本处配置的shell命令，是默认在jenkins容器中执行的，而不是在宿主机上。\n\n下拉选择执行 shell：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c2e1bd362944ff2aab0a62646bae53d~tplv-k3u1fbpfcp-watermark.image?)\n\n在执行shell的命令中输入以下命令，设置全局变量：\n```\nSERVER_NAME_1=video-book-backend\necho \"=========================>>>>>>>工作空间WORKSPACE的地址：$WORKSPACE \"\ncd $WORKSPACE\necho \"=========================>>>>>>>进入工作空间WORKSPACE，清除工作空间中原项目的工作空间$SERVER_NAME_1 \"\nrm -rf $SERVER_NAME_1\necho \"=========================>>>>>>>清除工作空间中原项目的工作空间$SERVER_NAME_1 ......成功success\"\n```\n注意：本处的SERVER_NAME_1=jenkins-docker-gitlab-springboot是配置项目的名称(和gitlab中的项目名保持一致)\n\n### Build(构建)\n\n我们是SpringBoot项目，所以用到maven，这里设置一下全局操作，clean项目，并打成jar包，所以这里输入：`clean package`\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a41ff4b5061f48f39de4738c6282ec78~tplv-k3u1fbpfcp-watermark.image?)\n\n### Post Steps(执行任务)\n\n只在jenkins构建成功后，才执行这一步。\n\n因为最后的构建成功的maven项目的jar包是以docker启动服务为目的，所以最后的docker操作，一定是在jenkins容器以外的服务器上运行的，可能是本机宿主机，也可能是远程的服务器，这个根据自己的情况去配置。\n\n本处选择，在远程的SSH执行shell脚本。\n\n选中只有构建成功才执行这些命令，然后选择Execute shell script on remote host using ssh。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c25a57ddb8f4b10b31e4832503d4af2~tplv-k3u1fbpfcp-watermark.image?)\n\nshell命令:\n```\n# =====================================================================================\n# =================================定义初始化变量======================================\n# =====================================================================================\n\n# 操作/项目路径(Dockerfile存放的路径，Dockerfile一般都放在项目的根目录下)\n# 如果Dockerfile放在项目根目录的子目录下，则子目录不能与项目同名\n# 会导致在复制jar包的时候，覆盖子目录为jar包,同时没有扩展名jar,原因我暂时不知道\n# 目前我的做法是将Dockerfile放在项目根目录下\nBASE_PATH=/usr/local/docker/jenkins/workspace/video-book-backend\n\n# jenkins构建好的源jar路径\n# 这个路径是jenkins容器挂载在宿主机上的路径\n# 我的jenkins的目录被我挂载在了/usr/local/docker/jenkins上\nSOURCE_PATH=/usr/local/docker/jenkins/workspace\n\n# docker镜像、docker容器、Dockerfile同目录下的jar名字[用它build生成image的jar]、jenkins的workspace下的项目名称\n# 注意统一名称！！！！！\nSERVER_NAME=video-book-backend\n\n# 容器id  [grep -w 全量匹配容器名] [awk 获取信息行的第一列，即容器ID]  [无论容器启动与否，都获取到]\nCID=$(docker ps -a | grep -w \"$SERVER_NAME\" | awk \'{print $1}\')\n\n# 镜像id  [grep -w 全量匹配镜像名] [awk 获取信息行的第三列，即镜像ID]\nIID=$(docker images | grep -w \"$SERVER_NAME\" | awk \'{print $3}\')\n\n# 源jar完整地址[jenkins构建成功后，会在自己的workspace/项目/target下生成maven构建成功的jar包，获取jar包名的完整路径]\n# 例如：/usr/local/docker/jenkins/workspace/video-book-backend/target/video-book-backend-0.0.1-SNAPSHOT.jar\nSOURCE_JAR_PATH=$(find \"$SOURCE_PATH/$SERVER_NAME/target/\"  -name \"*$SERVER_NAME*.jar\" )\n\nDATE=`date +%Y%m%d%H%M%S`\n\n# =====================================================================================\n# ============================对原本已存在的jar进行备份================================\n# =====================================================================================\n\n# 备份\nfunction backup(){\n    if [ -f \"$BASE_PATH/$SERVER_NAME.jar\" ]; then\n        echo \"=========================>>>>>>>$SERVER_NAME.jar 备份...\"\n            mv $BASE_PATH/$SERVER_NAME.jar $BASE_PATH/backup/$SERVER_NAME-$DATE.jar\n        echo \"=========================>>>>>>>备份老的 $SERVER_NAME.jar 完成\"\n\n    else\n        echo \"=========================>>>>>>>老的$BASE_PATH/$SERVER_NAME.jar不存在，跳过备份\"\n    fi\n}\n\n# =====================================================================================\n# =========================移动最新源jar包到Dockerfile所在目录=========================\n# =====================================================================================\n\n\n \n# 查找源jar文件名，进行重命名，最后将源文件移动到Dockerfile文件所在目录\nfunction transfer(){\n      \n    echo \"=========================>>>>>>>源文件完整地址为 $SOURCE_JAR_PATH\"\n\n    echo \"=========================>>>>>>>重命名源文件\"\n        mv $SOURCE_JAR_PATH  $SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar\n\n    echo \"=========================>>>>>>>最新构建代码 将$SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar 迁移至 $BASE_PATH\"\n        cp $SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar $BASE_PATH\n        \n    echo \"=========================>>>>>>>迁移完成Success\"\n\n}\n \n# =====================================================================================\n# ==================================构建最新镜像=======================================\n# =====================================================================================\n\n# 构建docker镜像\nfunction build(){\n    \n    # 无论镜像存在与否，都停止原容器服务，并移除原容器服务\n    echo \"=========================>>>>>>>停止$SERVER_NAME容器，CID=$CID\"\n    docker stop $CID\n\n    echo \"=========================>>>>>>>移除$SERVER_NAME容器，CID=$CID\"\n    docker rm $CID\n\n    # 无论如何，都去构建新的镜像\n    if [ -n \"$IID\" ]; then\n        echo \"=========================>>>>>>>存在$SERVER_NAME镜像，IID=$IID\"\n\n        echo \"=========================>>>>>>>移除老的$SERVER_NAME镜像，IID=$IID\"\n        \n        docker rmi $IID\n\n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，开始---->\"\n        \n        cd $BASE_PATH\n        docker build -t $SERVER_NAME .\n        \n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，完成---->\"\n\n    else\n        echo \"=========================>>>>>>>不存在$SERVER_NAME镜像，构建新的镜像，开始--->\"\n        \n        cd $BASE_PATH\n        docker build -t $SERVER_NAME .\n        \n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，结束--->\"\n    fi\n}\n \n\n# =====================================================================================\n# ==============================运行docker容器，启动服务===============================\n# =====================================================================================\n\n# 运行docker容器\nfunction run(){\n    backup\n    transfer\n    build\n\n    # 创建容器\n    docker run --name $SERVER_NAME -itd --net=host -v /etc/localtime:/etc/localtime:ro  -v /etc/timezone:/etc/timezone:ro  $SERVER_NAME \n\n}\n \n# 入口\nrun\n```\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e67ba6d7cf14d52b00009c09afc9349~tplv-k3u1fbpfcp-watermark.image?)\n\nOK，到这里基本的任务已经新建成功，至于后续的两个步骤，根据自己的需求自行配置，没有难度的。\n\n点击应用，保存。\n\n### 测试\n\n测试push事件触发自动化构建和部署，点击test下拉选择push events，出现HTTP 200表示OK了。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e85f532d1c2b4643996604347b945f51~tplv-k3u1fbpfcp-watermark.image?)\n\n回到Jenkins可以看到任务列表，查看构建信息等。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f954757d41324660ae01ff5de6afe17e~tplv-k3u1fbpfcp-watermark.image?)\n\n待Jenkins构建成功之后，在服务器上执行命令：`docker ps`，可以看到我们启动起来的 SpringBoot 容器：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8556de2ce136416ea36e817b661c2f80~tplv-k3u1fbpfcp-watermark.image?)\n\n## 邮件通知\n\n有时候团队合作，我们希望能通过邮件通知每一个开发者，项目是否构建成功。jenkins/jenkins:2.332.1默认安装了`# Email Extension Template`这个插件，还需要安装`Email Extension Template`这个插件\n\n系统管理->插件管理->可选插件->搜索`Email Extension Template`\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51c60941d3d3422e88db89b5188a3168~tplv-k3u1fbpfcp-watermark.image?)\n\n直接安装\n\n### 配置Email(Jenkins自带)\n\n#### 2.1 基础信息查询\n\n>找到所要配置邮箱的基础信息，这里以QQ邮箱为例\n\n1. 通过网页端QQ邮箱的设置进入到邮箱客户端设置页面\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f31038ef147f4c728540bc581f64d522~tplv-k3u1fbpfcp-watermark.image?)\n\n2. 找到邮箱的基础信息\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5694801b0ed74685a76cade6b358c5fc~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 2.2 Jenkins邮件通知配置\n\n在Jenkins：`系统管理->系统配置`中，最底部找到`邮件通知`，打开`高级`,注意到在配置的下方有个\"通过发送测试邮件测试配置\"，我们可以讲其勾选，填入邮箱地址，点击`Test configuration`来先测试一下邮件的发送。\n\n> 这边最好先保存一下再测试，否则出错，又得重配。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6420215d674647fb824854fd68a3efd6~tplv-k3u1fbpfcp-watermark.image?)\n\n如果报错如下：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8481f74294404047a2671bc8e2a3297e~tplv-k3u1fbpfcp-watermark.image?)\n\n这是因为我们还需要在设置`Jenkins Location`中配置`系统管理员邮件地址`，此地址要和`邮件通知`中的`用户名`一致\n\n### 配置Email(Extended E-mail Notification)\n\n>记得文章一开头提到的下载Extended插件，没错，Jenkins系统设置里还可以通过`Extended E-mail Notification`对邮件发送进行模板格式的自定义\n\n#### 3.1 基础信息配置\n\n基础信息配置与上述一致,唯一要注意的是这里需要重新生成一个授权码\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cb0934380904b098a035e54297946d4~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 3.2 模板格式配置\n\n接3.1配置继续。这里主要就是配置展示的模板格式，常用的格式化的参数有：\n```\n- $BUILD_STATUS – 构建结果\n- $PROJECT_NAME – 构建脚本名称\n- $BUILD_NUMBER – 构建脚本编号\n- $JOB_DESCRIPTION – 构建项目描述 \n- $CAUSE – 脚本启动原因\n- $BUILD_URL – 脚本构建详情URL地址\n```\n\n这里选择以HTML的格式展示，填入模板：\n```\n<!DOCTYPE html>    \n<html>    \n<head>    \n<meta charset=\"UTF-8\">    \n<title>${ENV, var=\"JOB_NAME\"}-第${BUILD_NUMBER}次构建日志</title>    \n</head>    \n    \n<body leftmargin=\"8\" marginwidth=\"0\" topmargin=\"8\" marginheight=\"4\"    \n    offset=\"0\">    \n    <table width=\"95%\" cellpadding=\"0\" cellspacing=\"0\"  style=\"font-size: 11pt; font-family: Tahoma, Arial, Helvetica, sans-serif\">    \n        <tr>    \n            本邮件由系统自动发出，无需回复！<br/>            \n            各位同事，大家好，以下为${PROJECT_NAME}项目构建信息</br> \n            <td><font color=\"#CC0000\">构建结果 - ${BUILD_STATUS}</font></td>   \n        </tr>    \n        <tr>    \n            <td><br />    \n            <b><font color=\"#0B610B\">构建信息</font></b>    \n            <hr size=\"2\" width=\"100%\" align=\"center\" /></td>    \n        </tr>    \n        <tr>    \n            <td>    \n                <ul>    \n                    <li>项目名称 ： ${PROJECT_NAME}</li>    \n                    <li>构建编号 ： 第${BUILD_NUMBER}次构建</li>    \n                    <li>触发原因： ${CAUSE}</li>    \n                    <li>构建状态： ${BUILD_STATUS}</li>    \n                    <li>构建日志： <a href=\"${BUILD_URL}console\">${BUILD_URL}console</a></li>    \n                    <li>构建  Url ： <a href=\"${BUILD_URL}\">${BUILD_URL}</a></li>    \n                    <li>工作目录 ： <a href=\"${PROJECT_URL}ws\">${PROJECT_URL}ws</a></li>    \n                    <li>项目  Url ： <a href=\"${PROJECT_URL}\">${PROJECT_URL}</a></li>    \n                </ul>    \n\n<h4><font color=\"#0B610B\">失败用例</font></h4>\n<hr size=\"2\" width=\"100%\" />\n$FAILED_TESTS<br/>\n\n<h4><font color=\"#0B610B\">最近提交(#$SVN_REVISION)</font></h4>\n<hr size=\"2\" width=\"100%\" />\n<ul>\n${CHANGES_SINCE_LAST_SUCCESS, reverse=true, format=\"%c\", changesFormat=\"<li>%d [%a] %m</li>\"}\n</ul>\n详细提交: <a href=\"${PROJECT_URL}changes\">${PROJECT_URL}changes</a><br/>\n\n            </td>    \n        </tr>    \n    </table>    \n</body>    \n</html>\n```\n\n如下图：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8b10b649f4943e1944fc094c72a3d2e~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 3.3 触发条件配置\n\n我们还可以在`Default Triggers`中根据自己的需要配置邮件的触发条件\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4328af1e2934c81b61f8c0429b6313b~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16835dfc64334f0e93a6cb7fd262922a~tplv-k3u1fbpfcp-watermark.image?)\n\n>这里为了防止因为构建一直尝试结果均为失败而造成的邮件轰炸，可以设置邮件仅第一次或第二次构建结果为失败时才发送邮件，后续失败的邮件将不再发送。我选择的是每一次失败和构建成功都会发邮件通知\n\n#### 3.4 jenkins的任务中配置邮件通知\n\n1. 在对应的任务中的构建设置中，勾选`E-mail Notification Recipients`\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/224fb406029d46d489cb6192848fdb6e~tplv-k3u1fbpfcp-watermark.image?)\n\n2. 在对应的任务中的构建后操作中，下拉选择`Editable Email Notification`\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1abc14189c874a818e5fe42a90371e43~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/594c71d3301544e48f6cc7468724b964~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b633844afb7a43e488cd3ab81d7c08a9~tplv-k3u1fbpfcp-watermark.image?)\n\n至此，jnekins的自动化构建的邮件通知已配置完成，在gitlab点击push event发起构建进行测试。\n\n发送成功的话，可看到如下图的提示：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a26d60de670c48ca991975dc2d20fa20~tplv-k3u1fbpfcp-watermark.image?)\n\n## 总结\n\n经过多款插件的安装配置，逐步掌握了如何上床Spring Boot项目到Gitlab中，并使用Jenkins自动构建任务，另外依托于Docker，让这一切变得更加方便，希望大家都多多思考，让机器自动干活，减少我们IT从业人员的重复、繁琐的工作量。\n\n\n', '小白学习gitlab+jenkins进行自动化构建(docker)之springboot项目', 0, 7, 2, 9, 0, '2023-06-09 16:56:30', '2023-06-09 16:56:30', 0);
INSERT INTO `tb_article` VALUES (8, '小白学习gitlab+jenkins进行自动化构建(docker)之springboot项目', '## 前言\ngitlab和jenkins的安装参考我的另外两篇博客：\n* gitlab安装：[小白搭建gitlab(docker)](https://juejin.cn/post/7032898607686778910)\n* jenkins安装：[小白学习搭建jenkins(docker)](https://juejin.cn/post/7032891246490157093/)\n\n## 在Jenkins上安装必要的插件\n所需插件：`Maven Integration`、`Pipeline Maven Integration`、`Gitlab`、`GitLab Authentication`、`SSH`、`Publish Over SSH`、`Docker`\n\n点击 Manage Jenkins（系统管理） ——> Manage Plugins（插件管理）\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5d15509337b44198064ba2bd41f221e~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Maven插件\n\n点击可选插件 ——> 过滤Maven Integration插件 ——> 勾选Maven Integration和Pipeline Maven Integration ——> 点击直接安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e496dbb12972454789d19546d660c88d~tplv-k3u1fbpfcp-watermark.image?)\n\n如图开始安装插件：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/134fef5f496c468b8dad342454c83b45~tplv-k3u1fbpfcp-watermark.image?)\n\n安装完成后，即可在插件管理下的已安装选项卡下看到刚刚已经安装的插件。\n\n#### 安装Gitlab插件\n\n点击可选插件 ——> 过滤Gitlab插件 ——> 勾选Gitlab和Gitlab Authentication ——> 点击直接安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6171674e55b428c9eba7be7cc2f516c~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装SSH插件和Publish Over SSH插件\n安装Publish Over SSH插件的原因：因为本方式是使用docker启动jenkins服务，所以在jenkins后续执行构建任务时候，需要在build成功后，将服务的jar包（以spring boot服务为例）拷贝到Dockerfile所在服务器的指定目录，进行微服务的启动；所以，此处需要配置SSH服务器的连接，意思就是在jenkins的任务结束后，去执行指定的服务器上的shell命令，做spring boot或cloud服务的镜像的构建，容器的运行，等一系列的事情。\n\n点击可选插件 ——> 过滤SSH插件 ——> 勾选SSH和Publish Over SSH ——> 点击直接安装\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d21ba2054860482b8b07684f48468538~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Docker插件\n\n点击可选插件 ——> 过滤Docker插件 ——> 勾选Docker ——> 点击直接安装\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1501abfe94b431a91e5692c41d12f72~tplv-k3u1fbpfcp-watermark.image?)\n\n插件全部安装完成后，可以重启一下Jenkins。\n\n## 相关配置\n\n#### 添加凭据\n\n点击 Manage Jenkins（系统管理） ——> Manage Credentials（凭据管理）\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0d3890020d34004adb05cab48310dd1~tplv-k3u1fbpfcp-watermark.image?)\n\n点击添加凭据 ——> 输入宿主机服务器的用户名和密码等信息并保存\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8eb6e5330d2140cb9705256fc722dc9d~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 配置SSH remote hosts\n\n这个配置是干什么的呢？配置SSH连接Dockerfile所在服务器的相关信息，并添加凭证，最后测试连接并保存，以备后面使用！！！\n\n点击 Manage Jenkins（系统管理） ——> 系统配置\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3813b66e9134305a1acb1d7515110bd~tplv-k3u1fbpfcp-watermark.image?)\n\n找到配置 ——> 下拉选择SSH remote hosts\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7436757a876049db93e6b255662001f2~tplv-k3u1fbpfcp-watermark.image?)\n\n如下图，输入对应的信息，并校验是否连接成功！成功后，点击应用 ——> 点击保存\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3559c64c918c4355aaff8d136e689da9~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 配置Publish over SSH\n\n找到配置 ——> 下拉选择Publish over SSH，进行相关配置即可。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0bb12f108302405ba90bb33e80fd0d5e~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78ad24f26a2a46b68ea44ea1c6ceb537~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de7ba1ca4a074ad1bb6f6a4b8fe71ee3~tplv-k3u1fbpfcp-watermark.image?)\n\n这里配置的数据，目前只能在Post Steps中选中send files or execute commands over ssh使用，要想能够在execute shell script on remote host using ssh方式中使用，需要再配置一份SSH remote hosts和它配套使用\n\n## 全局工具配置\n\n由于我们要实现的是SpringBoot项目的自动化部署操作，所以需要安装JDK、Git、Maven、Docker。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0dec279d6d44a83b2138cd7663e0995~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装JDK\n\n可以安装多个，根据项目JDK版本需求。\n\n输入自定义JDK名称 ——> 勾选自动安装 ——> 输入Oracle账户、密码 ——> 选择JDK版本 ——> 勾选同意协议\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72aa67fd5a494228840c5bef060e36b8~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Git\n\n输入自定义Git名称 ——> 勾选自动安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b49eb7bd11d48ab9ffce4f29431c216~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Maven\n\n输入自定义名称 ——> 勾选自动安装 ——> 选择版本\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5394195a98b647189dfaa5cd74b1a0b0~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Docker\n\n输入自定义名称 ——> 勾选自动安装\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/893704cbe8fe449fb615534bf9e82cea~tplv-k3u1fbpfcp-watermark.image?)\n\n最后，点击应用 ——> 点击保存即可。\n\n## 新建Jenkins任务\n\n### 点击新建任务，输入名称\n\n注意：本名称必须和项目名称一致，因为本名称会在jenkins工作空间下生成目录，类似于IDEA或Eclipse的工作空间的概念。所以，一般情况下，保证本名称=项目名称=docker镜像名称=docker容器名称 这样能尽可能的减轻jenkins配置的shell命令的复杂性！（空间命名要小写：因为镜像名不允许存在大写字母）\n\n选择构建一个Maven项目（因为是Spring Boot的服务）\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5a510bcf4ac49159f3f3b2960ae4fc5~tplv-k3u1fbpfcp-watermark.image?)\n\n### 源码管理\n\n输入描述信息，源码管理选择Git，从gitlab复制克隆地址（http协议的）粘贴到Repository URL中。未添加凭证会报授权失败的错误。错误如下：\n```\n![]()无法连接仓库：Command \"git ls-remote -h -- http://192.168.57.128:8880/root/video-book-backend.git HEAD\" returned status code 128:\\\nstdout:\\\nstderr: remote: HTTP Basic: Access denied\\\nfatal: Authentication failed for \'http://192.168.57.128:8880/root/video-book-backend.git/\'\n```\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94c2477c80724a959f8bb9f461814f41~tplv-k3u1fbpfcp-watermark.image?)\n\n添加gitlab凭证：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e08c1c343564fda9d5c599e985c38f5~tplv-k3u1fbpfcp-watermark.image?)\n\n### 构建触发器\n\n接下来将会生成供gitlab配置webhook使用的URL和Token，请记录下来，后面会使用。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1016fa1f35f24be7bf16ebe0a503bb8e~tplv-k3u1fbpfcp-watermark.image?)\n\n点击高级，拉下来找到Generate并点击，生成一串Secret Token。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13fb693d0ed14c63b8b613cccc7cd5b9~tplv-k3u1fbpfcp-watermark.image?)\n\n### 添加webhook\n\n前往gitlab，进入要构建的项目，在setting中选择Webhooks，输入URL和Secret Token 这两在上面图中已经给你标注了，去掉Enable SSL verification的勾选。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/904006704c604f6da4f2d1989200d462~tplv-k3u1fbpfcp-watermark.image?)\n\n点击Add webhook，如图表示成功添加了webhook：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6928c377f94748d0b70f57189e42e6cd~tplv-k3u1fbpfcp-watermark.image?)\n\n如果添加不成功解决方案请参考：[解决 Url is blocked: Requests to the local network are not allowed](https://www.cnblogs.com/zhongyuanzhao000/p/11379098.html)\n\n### 构建环境\n\n勾选Add timestamps to the Console Output，等下可以看到控制台打印的信息，这个根据自己的需求勾选。\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/badcdddabcc643b19f5a41fdc9f3416e~tplv-k3u1fbpfcp-watermark.image?)\n\n### Pre Steps(构建之前的步骤)\n\n配置前一步需要做的事情是：清理本项目在jenkins的workspace中的历史文件夹。\n\n你可以不用知道WORKSPACE具体的地址在哪里，因为下方有链接可以查看到当前jenkins中有哪些可用的变量供你使用。\n\n默认WORKSPACE地址：`/var/jenkins_home/workspace`（如果你jenkins是docker启动的，并且挂载了目录在宿主机，那你在宿主机也是可以看到的，即 `/usr/local/docker/workspace`）\n\n本处选择的是执行shell，则表示本处配置的shell命令，是默认在jenkins容器中执行的，而不是在宿主机上。\n\n下拉选择执行 shell：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c2e1bd362944ff2aab0a62646bae53d~tplv-k3u1fbpfcp-watermark.image?)\n\n在执行shell的命令中输入以下命令，设置全局变量：\n```\nSERVER_NAME_1=video-book-backend\necho \"=========================>>>>>>>工作空间WORKSPACE的地址：$WORKSPACE \"\ncd $WORKSPACE\necho \"=========================>>>>>>>进入工作空间WORKSPACE，清除工作空间中原项目的工作空间$SERVER_NAME_1 \"\nrm -rf $SERVER_NAME_1\necho \"=========================>>>>>>>清除工作空间中原项目的工作空间$SERVER_NAME_1 ......成功success\"\n```\n注意：本处的SERVER_NAME_1=jenkins-docker-gitlab-springboot是配置项目的名称(和gitlab中的项目名保持一致)\n\n### Build(构建)\n\n我们是SpringBoot项目，所以用到maven，这里设置一下全局操作，clean项目，并打成jar包，所以这里输入：`clean package`\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a41ff4b5061f48f39de4738c6282ec78~tplv-k3u1fbpfcp-watermark.image?)\n\n### Post Steps(执行任务)\n\n只在jenkins构建成功后，才执行这一步。\n\n因为最后的构建成功的maven项目的jar包是以docker启动服务为目的，所以最后的docker操作，一定是在jenkins容器以外的服务器上运行的，可能是本机宿主机，也可能是远程的服务器，这个根据自己的情况去配置。\n\n本处选择，在远程的SSH执行shell脚本。\n\n选中只有构建成功才执行这些命令，然后选择Execute shell script on remote host using ssh。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c25a57ddb8f4b10b31e4832503d4af2~tplv-k3u1fbpfcp-watermark.image?)\n\nshell命令:\n```\n# =====================================================================================\n# =================================定义初始化变量======================================\n# =====================================================================================\n\n# 操作/项目路径(Dockerfile存放的路径，Dockerfile一般都放在项目的根目录下)\n# 如果Dockerfile放在项目根目录的子目录下，则子目录不能与项目同名\n# 会导致在复制jar包的时候，覆盖子目录为jar包,同时没有扩展名jar,原因我暂时不知道\n# 目前我的做法是将Dockerfile放在项目根目录下\nBASE_PATH=/usr/local/docker/jenkins/workspace/video-book-backend\n\n# jenkins构建好的源jar路径\n# 这个路径是jenkins容器挂载在宿主机上的路径\n# 我的jenkins的目录被我挂载在了/usr/local/docker/jenkins上\nSOURCE_PATH=/usr/local/docker/jenkins/workspace\n\n# docker镜像、docker容器、Dockerfile同目录下的jar名字[用它build生成image的jar]、jenkins的workspace下的项目名称\n# 注意统一名称！！！！！\nSERVER_NAME=video-book-backend\n\n# 容器id  [grep -w 全量匹配容器名] [awk 获取信息行的第一列，即容器ID]  [无论容器启动与否，都获取到]\nCID=$(docker ps -a | grep -w \"$SERVER_NAME\" | awk \'{print $1}\')\n\n# 镜像id  [grep -w 全量匹配镜像名] [awk 获取信息行的第三列，即镜像ID]\nIID=$(docker images | grep -w \"$SERVER_NAME\" | awk \'{print $3}\')\n\n# 源jar完整地址[jenkins构建成功后，会在自己的workspace/项目/target下生成maven构建成功的jar包，获取jar包名的完整路径]\n# 例如：/usr/local/docker/jenkins/workspace/video-book-backend/target/video-book-backend-0.0.1-SNAPSHOT.jar\nSOURCE_JAR_PATH=$(find \"$SOURCE_PATH/$SERVER_NAME/target/\"  -name \"*$SERVER_NAME*.jar\" )\n\nDATE=`date +%Y%m%d%H%M%S`\n\n# =====================================================================================\n# ============================对原本已存在的jar进行备份================================\n# =====================================================================================\n\n# 备份\nfunction backup(){\n    if [ -f \"$BASE_PATH/$SERVER_NAME.jar\" ]; then\n        echo \"=========================>>>>>>>$SERVER_NAME.jar 备份...\"\n            mv $BASE_PATH/$SERVER_NAME.jar $BASE_PATH/backup/$SERVER_NAME-$DATE.jar\n        echo \"=========================>>>>>>>备份老的 $SERVER_NAME.jar 完成\"\n\n    else\n        echo \"=========================>>>>>>>老的$BASE_PATH/$SERVER_NAME.jar不存在，跳过备份\"\n    fi\n}\n\n# =====================================================================================\n# =========================移动最新源jar包到Dockerfile所在目录=========================\n# =====================================================================================\n\n\n \n# 查找源jar文件名，进行重命名，最后将源文件移动到Dockerfile文件所在目录\nfunction transfer(){\n      \n    echo \"=========================>>>>>>>源文件完整地址为 $SOURCE_JAR_PATH\"\n\n    echo \"=========================>>>>>>>重命名源文件\"\n        mv $SOURCE_JAR_PATH  $SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar\n\n    echo \"=========================>>>>>>>最新构建代码 将$SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar 迁移至 $BASE_PATH\"\n        cp $SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar $BASE_PATH\n        \n    echo \"=========================>>>>>>>迁移完成Success\"\n\n}\n \n# =====================================================================================\n# ==================================构建最新镜像=======================================\n# =====================================================================================\n\n# 构建docker镜像\nfunction build(){\n    \n    # 无论镜像存在与否，都停止原容器服务，并移除原容器服务\n    echo \"=========================>>>>>>>停止$SERVER_NAME容器，CID=$CID\"\n    docker stop $CID\n\n    echo \"=========================>>>>>>>移除$SERVER_NAME容器，CID=$CID\"\n    docker rm $CID\n\n    # 无论如何，都去构建新的镜像\n    if [ -n \"$IID\" ]; then\n        echo \"=========================>>>>>>>存在$SERVER_NAME镜像，IID=$IID\"\n\n        echo \"=========================>>>>>>>移除老的$SERVER_NAME镜像，IID=$IID\"\n        \n        docker rmi $IID\n\n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，开始---->\"\n        \n        cd $BASE_PATH\n        docker build -t $SERVER_NAME .\n        \n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，完成---->\"\n\n    else\n        echo \"=========================>>>>>>>不存在$SERVER_NAME镜像，构建新的镜像，开始--->\"\n        \n        cd $BASE_PATH\n        docker build -t $SERVER_NAME .\n        \n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，结束--->\"\n    fi\n}\n \n\n# =====================================================================================\n# ==============================运行docker容器，启动服务===============================\n# =====================================================================================\n\n# 运行docker容器\nfunction run(){\n    backup\n    transfer\n    build\n\n    # 创建容器\n    docker run --name $SERVER_NAME -itd --net=host -v /etc/localtime:/etc/localtime:ro  -v /etc/timezone:/etc/timezone:ro  $SERVER_NAME \n\n}\n \n# 入口\nrun\n```\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e67ba6d7cf14d52b00009c09afc9349~tplv-k3u1fbpfcp-watermark.image?)\n\nOK，到这里基本的任务已经新建成功，至于后续的两个步骤，根据自己的需求自行配置，没有难度的。\n\n点击应用，保存。\n\n### 测试\n\n测试push事件触发自动化构建和部署，点击test下拉选择push events，出现HTTP 200表示OK了。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e85f532d1c2b4643996604347b945f51~tplv-k3u1fbpfcp-watermark.image?)\n\n回到Jenkins可以看到任务列表，查看构建信息等。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f954757d41324660ae01ff5de6afe17e~tplv-k3u1fbpfcp-watermark.image?)\n\n待Jenkins构建成功之后，在服务器上执行命令：`docker ps`，可以看到我们启动起来的 SpringBoot 容器：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8556de2ce136416ea36e817b661c2f80~tplv-k3u1fbpfcp-watermark.image?)\n\n## 邮件通知\n\n有时候团队合作，我们希望能通过邮件通知每一个开发者，项目是否构建成功。jenkins/jenkins:2.332.1默认安装了`# Email Extension Template`这个插件，还需要安装`Email Extension Template`这个插件\n\n系统管理->插件管理->可选插件->搜索`Email Extension Template`\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51c60941d3d3422e88db89b5188a3168~tplv-k3u1fbpfcp-watermark.image?)\n\n直接安装\n\n### 配置Email(Jenkins自带)\n\n#### 2.1 基础信息查询\n\n>找到所要配置邮箱的基础信息，这里以QQ邮箱为例\n\n1. 通过网页端QQ邮箱的设置进入到邮箱客户端设置页面\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f31038ef147f4c728540bc581f64d522~tplv-k3u1fbpfcp-watermark.image?)\n\n2. 找到邮箱的基础信息\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5694801b0ed74685a76cade6b358c5fc~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 2.2 Jenkins邮件通知配置\n\n在Jenkins：`系统管理->系统配置`中，最底部找到`邮件通知`，打开`高级`,注意到在配置的下方有个\"通过发送测试邮件测试配置\"，我们可以讲其勾选，填入邮箱地址，点击`Test configuration`来先测试一下邮件的发送。\n\n> 这边最好先保存一下再测试，否则出错，又得重配。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6420215d674647fb824854fd68a3efd6~tplv-k3u1fbpfcp-watermark.image?)\n\n如果报错如下：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8481f74294404047a2671bc8e2a3297e~tplv-k3u1fbpfcp-watermark.image?)\n\n这是因为我们还需要在设置`Jenkins Location`中配置`系统管理员邮件地址`，此地址要和`邮件通知`中的`用户名`一致\n\n### 配置Email(Extended E-mail Notification)\n\n>记得文章一开头提到的下载Extended插件，没错，Jenkins系统设置里还可以通过`Extended E-mail Notification`对邮件发送进行模板格式的自定义\n\n#### 3.1 基础信息配置\n\n基础信息配置与上述一致,唯一要注意的是这里需要重新生成一个授权码\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cb0934380904b098a035e54297946d4~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 3.2 模板格式配置\n\n接3.1配置继续。这里主要就是配置展示的模板格式，常用的格式化的参数有：\n```\n- $BUILD_STATUS – 构建结果\n- $PROJECT_NAME – 构建脚本名称\n- $BUILD_NUMBER – 构建脚本编号\n- $JOB_DESCRIPTION – 构建项目描述 \n- $CAUSE – 脚本启动原因\n- $BUILD_URL – 脚本构建详情URL地址\n```\n\n这里选择以HTML的格式展示，填入模板：\n```\n<!DOCTYPE html>    \n<html>    \n<head>    \n<meta charset=\"UTF-8\">    \n<title>${ENV, var=\"JOB_NAME\"}-第${BUILD_NUMBER}次构建日志</title>    \n</head>    \n    \n<body leftmargin=\"8\" marginwidth=\"0\" topmargin=\"8\" marginheight=\"4\"    \n    offset=\"0\">    \n    <table width=\"95%\" cellpadding=\"0\" cellspacing=\"0\"  style=\"font-size: 11pt; font-family: Tahoma, Arial, Helvetica, sans-serif\">    \n        <tr>    \n            本邮件由系统自动发出，无需回复！<br/>            \n            各位同事，大家好，以下为${PROJECT_NAME}项目构建信息</br> \n            <td><font color=\"#CC0000\">构建结果 - ${BUILD_STATUS}</font></td>   \n        </tr>    \n        <tr>    \n            <td><br />    \n            <b><font color=\"#0B610B\">构建信息</font></b>    \n            <hr size=\"2\" width=\"100%\" align=\"center\" /></td>    \n        </tr>    \n        <tr>    \n            <td>    \n                <ul>    \n                    <li>项目名称 ： ${PROJECT_NAME}</li>    \n                    <li>构建编号 ： 第${BUILD_NUMBER}次构建</li>    \n                    <li>触发原因： ${CAUSE}</li>    \n                    <li>构建状态： ${BUILD_STATUS}</li>    \n                    <li>构建日志： <a href=\"${BUILD_URL}console\">${BUILD_URL}console</a></li>    \n                    <li>构建  Url ： <a href=\"${BUILD_URL}\">${BUILD_URL}</a></li>    \n                    <li>工作目录 ： <a href=\"${PROJECT_URL}ws\">${PROJECT_URL}ws</a></li>    \n                    <li>项目  Url ： <a href=\"${PROJECT_URL}\">${PROJECT_URL}</a></li>    \n                </ul>    \n\n<h4><font color=\"#0B610B\">失败用例</font></h4>\n<hr size=\"2\" width=\"100%\" />\n$FAILED_TESTS<br/>\n\n<h4><font color=\"#0B610B\">最近提交(#$SVN_REVISION)</font></h4>\n<hr size=\"2\" width=\"100%\" />\n<ul>\n${CHANGES_SINCE_LAST_SUCCESS, reverse=true, format=\"%c\", changesFormat=\"<li>%d [%a] %m</li>\"}\n</ul>\n详细提交: <a href=\"${PROJECT_URL}changes\">${PROJECT_URL}changes</a><br/>\n\n            </td>    \n        </tr>    \n    </table>    \n</body>    \n</html>\n```\n\n如下图：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8b10b649f4943e1944fc094c72a3d2e~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 3.3 触发条件配置\n\n我们还可以在`Default Triggers`中根据自己的需要配置邮件的触发条件\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4328af1e2934c81b61f8c0429b6313b~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16835dfc64334f0e93a6cb7fd262922a~tplv-k3u1fbpfcp-watermark.image?)\n\n>这里为了防止因为构建一直尝试结果均为失败而造成的邮件轰炸，可以设置邮件仅第一次或第二次构建结果为失败时才发送邮件，后续失败的邮件将不再发送。我选择的是每一次失败和构建成功都会发邮件通知\n\n#### 3.4 jenkins的任务中配置邮件通知\n\n1. 在对应的任务中的构建设置中，勾选`E-mail Notification Recipients`\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/224fb406029d46d489cb6192848fdb6e~tplv-k3u1fbpfcp-watermark.image?)\n\n2. 在对应的任务中的构建后操作中，下拉选择`Editable Email Notification`\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1abc14189c874a818e5fe42a90371e43~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/594c71d3301544e48f6cc7468724b964~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b633844afb7a43e488cd3ab81d7c08a9~tplv-k3u1fbpfcp-watermark.image?)\n\n至此，jnekins的自动化构建的邮件通知已配置完成，在gitlab点击push event发起构建进行测试。\n\n发送成功的话，可看到如下图的提示：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a26d60de670c48ca991975dc2d20fa20~tplv-k3u1fbpfcp-watermark.image?)\n\n## 总结\n\n经过多款插件的安装配置，逐步掌握了如何上床Spring Boot项目到Gitlab中，并使用Jenkins自动构建任务，另外依托于Docker，让这一切变得更加方便，希望大家都多多思考，让机器自动干活，减少我们IT从业人员的重复、繁琐的工作量。\n\n\n', '小白学习gitlab+jenkins进行自动化构建(docker)之springboot项目', 0, 7, 2, 9, 0, '2023-06-09 16:56:30', '2023-06-09 16:56:30', 0);
INSERT INTO `tb_article` VALUES (9, '小白学习gitlab+jenkins进行自动化构建(docker)之springboot项目', '## 前言\ngitlab和jenkins的安装参考我的另外两篇博客：\n* gitlab安装：[小白搭建gitlab(docker)](https://juejin.cn/post/7032898607686778910)\n* jenkins安装：[小白学习搭建jenkins(docker)](https://juejin.cn/post/7032891246490157093/)\n\n## 在Jenkins上安装必要的插件\n所需插件：`Maven Integration`、`Pipeline Maven Integration`、`Gitlab`、`GitLab Authentication`、`SSH`、`Publish Over SSH`、`Docker`\n\n点击 Manage Jenkins（系统管理） ——> Manage Plugins（插件管理）\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5d15509337b44198064ba2bd41f221e~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Maven插件\n\n点击可选插件 ——> 过滤Maven Integration插件 ——> 勾选Maven Integration和Pipeline Maven Integration ——> 点击直接安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e496dbb12972454789d19546d660c88d~tplv-k3u1fbpfcp-watermark.image?)\n\n如图开始安装插件：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/134fef5f496c468b8dad342454c83b45~tplv-k3u1fbpfcp-watermark.image?)\n\n安装完成后，即可在插件管理下的已安装选项卡下看到刚刚已经安装的插件。\n\n#### 安装Gitlab插件\n\n点击可选插件 ——> 过滤Gitlab插件 ——> 勾选Gitlab和Gitlab Authentication ——> 点击直接安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6171674e55b428c9eba7be7cc2f516c~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装SSH插件和Publish Over SSH插件\n安装Publish Over SSH插件的原因：因为本方式是使用docker启动jenkins服务，所以在jenkins后续执行构建任务时候，需要在build成功后，将服务的jar包（以spring boot服务为例）拷贝到Dockerfile所在服务器的指定目录，进行微服务的启动；所以，此处需要配置SSH服务器的连接，意思就是在jenkins的任务结束后，去执行指定的服务器上的shell命令，做spring boot或cloud服务的镜像的构建，容器的运行，等一系列的事情。\n\n点击可选插件 ——> 过滤SSH插件 ——> 勾选SSH和Publish Over SSH ——> 点击直接安装\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d21ba2054860482b8b07684f48468538~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Docker插件\n\n点击可选插件 ——> 过滤Docker插件 ——> 勾选Docker ——> 点击直接安装\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1501abfe94b431a91e5692c41d12f72~tplv-k3u1fbpfcp-watermark.image?)\n\n插件全部安装完成后，可以重启一下Jenkins。\n\n## 相关配置\n\n#### 添加凭据\n\n点击 Manage Jenkins（系统管理） ——> Manage Credentials（凭据管理）\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0d3890020d34004adb05cab48310dd1~tplv-k3u1fbpfcp-watermark.image?)\n\n点击添加凭据 ——> 输入宿主机服务器的用户名和密码等信息并保存\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8eb6e5330d2140cb9705256fc722dc9d~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 配置SSH remote hosts\n\n这个配置是干什么的呢？配置SSH连接Dockerfile所在服务器的相关信息，并添加凭证，最后测试连接并保存，以备后面使用！！！\n\n点击 Manage Jenkins（系统管理） ——> 系统配置\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3813b66e9134305a1acb1d7515110bd~tplv-k3u1fbpfcp-watermark.image?)\n\n找到配置 ——> 下拉选择SSH remote hosts\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7436757a876049db93e6b255662001f2~tplv-k3u1fbpfcp-watermark.image?)\n\n如下图，输入对应的信息，并校验是否连接成功！成功后，点击应用 ——> 点击保存\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3559c64c918c4355aaff8d136e689da9~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 配置Publish over SSH\n\n找到配置 ——> 下拉选择Publish over SSH，进行相关配置即可。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0bb12f108302405ba90bb33e80fd0d5e~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78ad24f26a2a46b68ea44ea1c6ceb537~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de7ba1ca4a074ad1bb6f6a4b8fe71ee3~tplv-k3u1fbpfcp-watermark.image?)\n\n这里配置的数据，目前只能在Post Steps中选中send files or execute commands over ssh使用，要想能够在execute shell script on remote host using ssh方式中使用，需要再配置一份SSH remote hosts和它配套使用\n\n## 全局工具配置\n\n由于我们要实现的是SpringBoot项目的自动化部署操作，所以需要安装JDK、Git、Maven、Docker。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0dec279d6d44a83b2138cd7663e0995~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装JDK\n\n可以安装多个，根据项目JDK版本需求。\n\n输入自定义JDK名称 ——> 勾选自动安装 ——> 输入Oracle账户、密码 ——> 选择JDK版本 ——> 勾选同意协议\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72aa67fd5a494228840c5bef060e36b8~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Git\n\n输入自定义Git名称 ——> 勾选自动安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b49eb7bd11d48ab9ffce4f29431c216~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Maven\n\n输入自定义名称 ——> 勾选自动安装 ——> 选择版本\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5394195a98b647189dfaa5cd74b1a0b0~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Docker\n\n输入自定义名称 ——> 勾选自动安装\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/893704cbe8fe449fb615534bf9e82cea~tplv-k3u1fbpfcp-watermark.image?)\n\n最后，点击应用 ——> 点击保存即可。\n\n## 新建Jenkins任务\n\n### 点击新建任务，输入名称\n\n注意：本名称必须和项目名称一致，因为本名称会在jenkins工作空间下生成目录，类似于IDEA或Eclipse的工作空间的概念。所以，一般情况下，保证本名称=项目名称=docker镜像名称=docker容器名称 这样能尽可能的减轻jenkins配置的shell命令的复杂性！（空间命名要小写：因为镜像名不允许存在大写字母）\n\n选择构建一个Maven项目（因为是Spring Boot的服务）\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5a510bcf4ac49159f3f3b2960ae4fc5~tplv-k3u1fbpfcp-watermark.image?)\n\n### 源码管理\n\n输入描述信息，源码管理选择Git，从gitlab复制克隆地址（http协议的）粘贴到Repository URL中。未添加凭证会报授权失败的错误。错误如下：\n```\n![]()无法连接仓库：Command \"git ls-remote -h -- http://192.168.57.128:8880/root/video-book-backend.git HEAD\" returned status code 128:\\\nstdout:\\\nstderr: remote: HTTP Basic: Access denied\\\nfatal: Authentication failed for \'http://192.168.57.128:8880/root/video-book-backend.git/\'\n```\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94c2477c80724a959f8bb9f461814f41~tplv-k3u1fbpfcp-watermark.image?)\n\n添加gitlab凭证：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e08c1c343564fda9d5c599e985c38f5~tplv-k3u1fbpfcp-watermark.image?)\n\n### 构建触发器\n\n接下来将会生成供gitlab配置webhook使用的URL和Token，请记录下来，后面会使用。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1016fa1f35f24be7bf16ebe0a503bb8e~tplv-k3u1fbpfcp-watermark.image?)\n\n点击高级，拉下来找到Generate并点击，生成一串Secret Token。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13fb693d0ed14c63b8b613cccc7cd5b9~tplv-k3u1fbpfcp-watermark.image?)\n\n### 添加webhook\n\n前往gitlab，进入要构建的项目，在setting中选择Webhooks，输入URL和Secret Token 这两在上面图中已经给你标注了，去掉Enable SSL verification的勾选。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/904006704c604f6da4f2d1989200d462~tplv-k3u1fbpfcp-watermark.image?)\n\n点击Add webhook，如图表示成功添加了webhook：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6928c377f94748d0b70f57189e42e6cd~tplv-k3u1fbpfcp-watermark.image?)\n\n如果添加不成功解决方案请参考：[解决 Url is blocked: Requests to the local network are not allowed](https://www.cnblogs.com/zhongyuanzhao000/p/11379098.html)\n\n### 构建环境\n\n勾选Add timestamps to the Console Output，等下可以看到控制台打印的信息，这个根据自己的需求勾选。\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/badcdddabcc643b19f5a41fdc9f3416e~tplv-k3u1fbpfcp-watermark.image?)\n\n### Pre Steps(构建之前的步骤)\n\n配置前一步需要做的事情是：清理本项目在jenkins的workspace中的历史文件夹。\n\n你可以不用知道WORKSPACE具体的地址在哪里，因为下方有链接可以查看到当前jenkins中有哪些可用的变量供你使用。\n\n默认WORKSPACE地址：`/var/jenkins_home/workspace`（如果你jenkins是docker启动的，并且挂载了目录在宿主机，那你在宿主机也是可以看到的，即 `/usr/local/docker/workspace`）\n\n本处选择的是执行shell，则表示本处配置的shell命令，是默认在jenkins容器中执行的，而不是在宿主机上。\n\n下拉选择执行 shell：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c2e1bd362944ff2aab0a62646bae53d~tplv-k3u1fbpfcp-watermark.image?)\n\n在执行shell的命令中输入以下命令，设置全局变量：\n```\nSERVER_NAME_1=video-book-backend\necho \"=========================>>>>>>>工作空间WORKSPACE的地址：$WORKSPACE \"\ncd $WORKSPACE\necho \"=========================>>>>>>>进入工作空间WORKSPACE，清除工作空间中原项目的工作空间$SERVER_NAME_1 \"\nrm -rf $SERVER_NAME_1\necho \"=========================>>>>>>>清除工作空间中原项目的工作空间$SERVER_NAME_1 ......成功success\"\n```\n注意：本处的SERVER_NAME_1=jenkins-docker-gitlab-springboot是配置项目的名称(和gitlab中的项目名保持一致)\n\n### Build(构建)\n\n我们是SpringBoot项目，所以用到maven，这里设置一下全局操作，clean项目，并打成jar包，所以这里输入：`clean package`\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a41ff4b5061f48f39de4738c6282ec78~tplv-k3u1fbpfcp-watermark.image?)\n\n### Post Steps(执行任务)\n\n只在jenkins构建成功后，才执行这一步。\n\n因为最后的构建成功的maven项目的jar包是以docker启动服务为目的，所以最后的docker操作，一定是在jenkins容器以外的服务器上运行的，可能是本机宿主机，也可能是远程的服务器，这个根据自己的情况去配置。\n\n本处选择，在远程的SSH执行shell脚本。\n\n选中只有构建成功才执行这些命令，然后选择Execute shell script on remote host using ssh。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c25a57ddb8f4b10b31e4832503d4af2~tplv-k3u1fbpfcp-watermark.image?)\n\nshell命令:\n```\n# =====================================================================================\n# =================================定义初始化变量======================================\n# =====================================================================================\n\n# 操作/项目路径(Dockerfile存放的路径，Dockerfile一般都放在项目的根目录下)\n# 如果Dockerfile放在项目根目录的子目录下，则子目录不能与项目同名\n# 会导致在复制jar包的时候，覆盖子目录为jar包,同时没有扩展名jar,原因我暂时不知道\n# 目前我的做法是将Dockerfile放在项目根目录下\nBASE_PATH=/usr/local/docker/jenkins/workspace/video-book-backend\n\n# jenkins构建好的源jar路径\n# 这个路径是jenkins容器挂载在宿主机上的路径\n# 我的jenkins的目录被我挂载在了/usr/local/docker/jenkins上\nSOURCE_PATH=/usr/local/docker/jenkins/workspace\n\n# docker镜像、docker容器、Dockerfile同目录下的jar名字[用它build生成image的jar]、jenkins的workspace下的项目名称\n# 注意统一名称！！！！！\nSERVER_NAME=video-book-backend\n\n# 容器id  [grep -w 全量匹配容器名] [awk 获取信息行的第一列，即容器ID]  [无论容器启动与否，都获取到]\nCID=$(docker ps -a | grep -w \"$SERVER_NAME\" | awk \'{print $1}\')\n\n# 镜像id  [grep -w 全量匹配镜像名] [awk 获取信息行的第三列，即镜像ID]\nIID=$(docker images | grep -w \"$SERVER_NAME\" | awk \'{print $3}\')\n\n# 源jar完整地址[jenkins构建成功后，会在自己的workspace/项目/target下生成maven构建成功的jar包，获取jar包名的完整路径]\n# 例如：/usr/local/docker/jenkins/workspace/video-book-backend/target/video-book-backend-0.0.1-SNAPSHOT.jar\nSOURCE_JAR_PATH=$(find \"$SOURCE_PATH/$SERVER_NAME/target/\"  -name \"*$SERVER_NAME*.jar\" )\n\nDATE=`date +%Y%m%d%H%M%S`\n\n# =====================================================================================\n# ============================对原本已存在的jar进行备份================================\n# =====================================================================================\n\n# 备份\nfunction backup(){\n    if [ -f \"$BASE_PATH/$SERVER_NAME.jar\" ]; then\n        echo \"=========================>>>>>>>$SERVER_NAME.jar 备份...\"\n            mv $BASE_PATH/$SERVER_NAME.jar $BASE_PATH/backup/$SERVER_NAME-$DATE.jar\n        echo \"=========================>>>>>>>备份老的 $SERVER_NAME.jar 完成\"\n\n    else\n        echo \"=========================>>>>>>>老的$BASE_PATH/$SERVER_NAME.jar不存在，跳过备份\"\n    fi\n}\n\n# =====================================================================================\n# =========================移动最新源jar包到Dockerfile所在目录=========================\n# =====================================================================================\n\n\n \n# 查找源jar文件名，进行重命名，最后将源文件移动到Dockerfile文件所在目录\nfunction transfer(){\n      \n    echo \"=========================>>>>>>>源文件完整地址为 $SOURCE_JAR_PATH\"\n\n    echo \"=========================>>>>>>>重命名源文件\"\n        mv $SOURCE_JAR_PATH  $SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar\n\n    echo \"=========================>>>>>>>最新构建代码 将$SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar 迁移至 $BASE_PATH\"\n        cp $SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar $BASE_PATH\n        \n    echo \"=========================>>>>>>>迁移完成Success\"\n\n}\n \n# =====================================================================================\n# ==================================构建最新镜像=======================================\n# =====================================================================================\n\n# 构建docker镜像\nfunction build(){\n    \n    # 无论镜像存在与否，都停止原容器服务，并移除原容器服务\n    echo \"=========================>>>>>>>停止$SERVER_NAME容器，CID=$CID\"\n    docker stop $CID\n\n    echo \"=========================>>>>>>>移除$SERVER_NAME容器，CID=$CID\"\n    docker rm $CID\n\n    # 无论如何，都去构建新的镜像\n    if [ -n \"$IID\" ]; then\n        echo \"=========================>>>>>>>存在$SERVER_NAME镜像，IID=$IID\"\n\n        echo \"=========================>>>>>>>移除老的$SERVER_NAME镜像，IID=$IID\"\n        \n        docker rmi $IID\n\n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，开始---->\"\n        \n        cd $BASE_PATH\n        docker build -t $SERVER_NAME .\n        \n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，完成---->\"\n\n    else\n        echo \"=========================>>>>>>>不存在$SERVER_NAME镜像，构建新的镜像，开始--->\"\n        \n        cd $BASE_PATH\n        docker build -t $SERVER_NAME .\n        \n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，结束--->\"\n    fi\n}\n \n\n# =====================================================================================\n# ==============================运行docker容器，启动服务===============================\n# =====================================================================================\n\n# 运行docker容器\nfunction run(){\n    backup\n    transfer\n    build\n\n    # 创建容器\n    docker run --name $SERVER_NAME -itd --net=host -v /etc/localtime:/etc/localtime:ro  -v /etc/timezone:/etc/timezone:ro  $SERVER_NAME \n\n}\n \n# 入口\nrun\n```\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e67ba6d7cf14d52b00009c09afc9349~tplv-k3u1fbpfcp-watermark.image?)\n\nOK，到这里基本的任务已经新建成功，至于后续的两个步骤，根据自己的需求自行配置，没有难度的。\n\n点击应用，保存。\n\n### 测试\n\n测试push事件触发自动化构建和部署，点击test下拉选择push events，出现HTTP 200表示OK了。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e85f532d1c2b4643996604347b945f51~tplv-k3u1fbpfcp-watermark.image?)\n\n回到Jenkins可以看到任务列表，查看构建信息等。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f954757d41324660ae01ff5de6afe17e~tplv-k3u1fbpfcp-watermark.image?)\n\n待Jenkins构建成功之后，在服务器上执行命令：`docker ps`，可以看到我们启动起来的 SpringBoot 容器：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8556de2ce136416ea36e817b661c2f80~tplv-k3u1fbpfcp-watermark.image?)\n\n## 邮件通知\n\n有时候团队合作，我们希望能通过邮件通知每一个开发者，项目是否构建成功。jenkins/jenkins:2.332.1默认安装了`# Email Extension Template`这个插件，还需要安装`Email Extension Template`这个插件\n\n系统管理->插件管理->可选插件->搜索`Email Extension Template`\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51c60941d3d3422e88db89b5188a3168~tplv-k3u1fbpfcp-watermark.image?)\n\n直接安装\n\n### 配置Email(Jenkins自带)\n\n#### 2.1 基础信息查询\n\n>找到所要配置邮箱的基础信息，这里以QQ邮箱为例\n\n1. 通过网页端QQ邮箱的设置进入到邮箱客户端设置页面\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f31038ef147f4c728540bc581f64d522~tplv-k3u1fbpfcp-watermark.image?)\n\n2. 找到邮箱的基础信息\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5694801b0ed74685a76cade6b358c5fc~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 2.2 Jenkins邮件通知配置\n\n在Jenkins：`系统管理->系统配置`中，最底部找到`邮件通知`，打开`高级`,注意到在配置的下方有个\"通过发送测试邮件测试配置\"，我们可以讲其勾选，填入邮箱地址，点击`Test configuration`来先测试一下邮件的发送。\n\n> 这边最好先保存一下再测试，否则出错，又得重配。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6420215d674647fb824854fd68a3efd6~tplv-k3u1fbpfcp-watermark.image?)\n\n如果报错如下：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8481f74294404047a2671bc8e2a3297e~tplv-k3u1fbpfcp-watermark.image?)\n\n这是因为我们还需要在设置`Jenkins Location`中配置`系统管理员邮件地址`，此地址要和`邮件通知`中的`用户名`一致\n\n### 配置Email(Extended E-mail Notification)\n\n>记得文章一开头提到的下载Extended插件，没错，Jenkins系统设置里还可以通过`Extended E-mail Notification`对邮件发送进行模板格式的自定义\n\n#### 3.1 基础信息配置\n\n基础信息配置与上述一致,唯一要注意的是这里需要重新生成一个授权码\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cb0934380904b098a035e54297946d4~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 3.2 模板格式配置\n\n接3.1配置继续。这里主要就是配置展示的模板格式，常用的格式化的参数有：\n```\n- $BUILD_STATUS – 构建结果\n- $PROJECT_NAME – 构建脚本名称\n- $BUILD_NUMBER – 构建脚本编号\n- $JOB_DESCRIPTION – 构建项目描述 \n- $CAUSE – 脚本启动原因\n- $BUILD_URL – 脚本构建详情URL地址\n```\n\n这里选择以HTML的格式展示，填入模板：\n```\n<!DOCTYPE html>    \n<html>    \n<head>    \n<meta charset=\"UTF-8\">    \n<title>${ENV, var=\"JOB_NAME\"}-第${BUILD_NUMBER}次构建日志</title>    \n</head>    \n    \n<body leftmargin=\"8\" marginwidth=\"0\" topmargin=\"8\" marginheight=\"4\"    \n    offset=\"0\">    \n    <table width=\"95%\" cellpadding=\"0\" cellspacing=\"0\"  style=\"font-size: 11pt; font-family: Tahoma, Arial, Helvetica, sans-serif\">    \n        <tr>    \n            本邮件由系统自动发出，无需回复！<br/>            \n            各位同事，大家好，以下为${PROJECT_NAME}项目构建信息</br> \n            <td><font color=\"#CC0000\">构建结果 - ${BUILD_STATUS}</font></td>   \n        </tr>    \n        <tr>    \n            <td><br />    \n            <b><font color=\"#0B610B\">构建信息</font></b>    \n            <hr size=\"2\" width=\"100%\" align=\"center\" /></td>    \n        </tr>    \n        <tr>    \n            <td>    \n                <ul>    \n                    <li>项目名称 ： ${PROJECT_NAME}</li>    \n                    <li>构建编号 ： 第${BUILD_NUMBER}次构建</li>    \n                    <li>触发原因： ${CAUSE}</li>    \n                    <li>构建状态： ${BUILD_STATUS}</li>    \n                    <li>构建日志： <a href=\"${BUILD_URL}console\">${BUILD_URL}console</a></li>    \n                    <li>构建  Url ： <a href=\"${BUILD_URL}\">${BUILD_URL}</a></li>    \n                    <li>工作目录 ： <a href=\"${PROJECT_URL}ws\">${PROJECT_URL}ws</a></li>    \n                    <li>项目  Url ： <a href=\"${PROJECT_URL}\">${PROJECT_URL}</a></li>    \n                </ul>    \n\n<h4><font color=\"#0B610B\">失败用例</font></h4>\n<hr size=\"2\" width=\"100%\" />\n$FAILED_TESTS<br/>\n\n<h4><font color=\"#0B610B\">最近提交(#$SVN_REVISION)</font></h4>\n<hr size=\"2\" width=\"100%\" />\n<ul>\n${CHANGES_SINCE_LAST_SUCCESS, reverse=true, format=\"%c\", changesFormat=\"<li>%d [%a] %m</li>\"}\n</ul>\n详细提交: <a href=\"${PROJECT_URL}changes\">${PROJECT_URL}changes</a><br/>\n\n            </td>    \n        </tr>    \n    </table>    \n</body>    \n</html>\n```\n\n如下图：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8b10b649f4943e1944fc094c72a3d2e~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 3.3 触发条件配置\n\n我们还可以在`Default Triggers`中根据自己的需要配置邮件的触发条件\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4328af1e2934c81b61f8c0429b6313b~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16835dfc64334f0e93a6cb7fd262922a~tplv-k3u1fbpfcp-watermark.image?)\n\n>这里为了防止因为构建一直尝试结果均为失败而造成的邮件轰炸，可以设置邮件仅第一次或第二次构建结果为失败时才发送邮件，后续失败的邮件将不再发送。我选择的是每一次失败和构建成功都会发邮件通知\n\n#### 3.4 jenkins的任务中配置邮件通知\n\n1. 在对应的任务中的构建设置中，勾选`E-mail Notification Recipients`\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/224fb406029d46d489cb6192848fdb6e~tplv-k3u1fbpfcp-watermark.image?)\n\n2. 在对应的任务中的构建后操作中，下拉选择`Editable Email Notification`\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1abc14189c874a818e5fe42a90371e43~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/594c71d3301544e48f6cc7468724b964~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b633844afb7a43e488cd3ab81d7c08a9~tplv-k3u1fbpfcp-watermark.image?)\n\n至此，jnekins的自动化构建的邮件通知已配置完成，在gitlab点击push event发起构建进行测试。\n\n发送成功的话，可看到如下图的提示：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a26d60de670c48ca991975dc2d20fa20~tplv-k3u1fbpfcp-watermark.image?)\n\n## 总结\n\n经过多款插件的安装配置，逐步掌握了如何上床Spring Boot项目到Gitlab中，并使用Jenkins自动构建任务，另外依托于Docker，让这一切变得更加方便，希望大家都多多思考，让机器自动干活，减少我们IT从业人员的重复、繁琐的工作量。\n\n\n', '小白学习gitlab+jenkins进行自动化构建(docker)之springboot项目', 0, 7, 2, 9, 0, '2023-06-09 16:56:30', '2023-06-09 16:56:30', 0);
INSERT INTO `tb_article` VALUES (10, '小白学习gitlab+jenkins进行自动化构建(docker)之springboot项目', '## 前言\ngitlab和jenkins的安装参考我的另外两篇博客：\n* gitlab安装：[小白搭建gitlab(docker)](https://juejin.cn/post/7032898607686778910)\n* jenkins安装：[小白学习搭建jenkins(docker)](https://juejin.cn/post/7032891246490157093/)\n\n## 在Jenkins上安装必要的插件\n所需插件：`Maven Integration`、`Pipeline Maven Integration`、`Gitlab`、`GitLab Authentication`、`SSH`、`Publish Over SSH`、`Docker`\n\n点击 Manage Jenkins（系统管理） ——> Manage Plugins（插件管理）\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5d15509337b44198064ba2bd41f221e~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Maven插件\n\n点击可选插件 ——> 过滤Maven Integration插件 ——> 勾选Maven Integration和Pipeline Maven Integration ——> 点击直接安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e496dbb12972454789d19546d660c88d~tplv-k3u1fbpfcp-watermark.image?)\n\n如图开始安装插件：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/134fef5f496c468b8dad342454c83b45~tplv-k3u1fbpfcp-watermark.image?)\n\n安装完成后，即可在插件管理下的已安装选项卡下看到刚刚已经安装的插件。\n\n#### 安装Gitlab插件\n\n点击可选插件 ——> 过滤Gitlab插件 ——> 勾选Gitlab和Gitlab Authentication ——> 点击直接安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6171674e55b428c9eba7be7cc2f516c~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装SSH插件和Publish Over SSH插件\n安装Publish Over SSH插件的原因：因为本方式是使用docker启动jenkins服务，所以在jenkins后续执行构建任务时候，需要在build成功后，将服务的jar包（以spring boot服务为例）拷贝到Dockerfile所在服务器的指定目录，进行微服务的启动；所以，此处需要配置SSH服务器的连接，意思就是在jenkins的任务结束后，去执行指定的服务器上的shell命令，做spring boot或cloud服务的镜像的构建，容器的运行，等一系列的事情。\n\n点击可选插件 ——> 过滤SSH插件 ——> 勾选SSH和Publish Over SSH ——> 点击直接安装\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d21ba2054860482b8b07684f48468538~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Docker插件\n\n点击可选插件 ——> 过滤Docker插件 ——> 勾选Docker ——> 点击直接安装\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1501abfe94b431a91e5692c41d12f72~tplv-k3u1fbpfcp-watermark.image?)\n\n插件全部安装完成后，可以重启一下Jenkins。\n\n## 相关配置\n\n#### 添加凭据\n\n点击 Manage Jenkins（系统管理） ——> Manage Credentials（凭据管理）\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0d3890020d34004adb05cab48310dd1~tplv-k3u1fbpfcp-watermark.image?)\n\n点击添加凭据 ——> 输入宿主机服务器的用户名和密码等信息并保存\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8eb6e5330d2140cb9705256fc722dc9d~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 配置SSH remote hosts\n\n这个配置是干什么的呢？配置SSH连接Dockerfile所在服务器的相关信息，并添加凭证，最后测试连接并保存，以备后面使用！！！\n\n点击 Manage Jenkins（系统管理） ——> 系统配置\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3813b66e9134305a1acb1d7515110bd~tplv-k3u1fbpfcp-watermark.image?)\n\n找到配置 ——> 下拉选择SSH remote hosts\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7436757a876049db93e6b255662001f2~tplv-k3u1fbpfcp-watermark.image?)\n\n如下图，输入对应的信息，并校验是否连接成功！成功后，点击应用 ——> 点击保存\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3559c64c918c4355aaff8d136e689da9~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 配置Publish over SSH\n\n找到配置 ——> 下拉选择Publish over SSH，进行相关配置即可。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0bb12f108302405ba90bb33e80fd0d5e~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78ad24f26a2a46b68ea44ea1c6ceb537~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de7ba1ca4a074ad1bb6f6a4b8fe71ee3~tplv-k3u1fbpfcp-watermark.image?)\n\n这里配置的数据，目前只能在Post Steps中选中send files or execute commands over ssh使用，要想能够在execute shell script on remote host using ssh方式中使用，需要再配置一份SSH remote hosts和它配套使用\n\n## 全局工具配置\n\n由于我们要实现的是SpringBoot项目的自动化部署操作，所以需要安装JDK、Git、Maven、Docker。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0dec279d6d44a83b2138cd7663e0995~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装JDK\n\n可以安装多个，根据项目JDK版本需求。\n\n输入自定义JDK名称 ——> 勾选自动安装 ——> 输入Oracle账户、密码 ——> 选择JDK版本 ——> 勾选同意协议\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72aa67fd5a494228840c5bef060e36b8~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Git\n\n输入自定义Git名称 ——> 勾选自动安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b49eb7bd11d48ab9ffce4f29431c216~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Maven\n\n输入自定义名称 ——> 勾选自动安装 ——> 选择版本\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5394195a98b647189dfaa5cd74b1a0b0~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Docker\n\n输入自定义名称 ——> 勾选自动安装\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/893704cbe8fe449fb615534bf9e82cea~tplv-k3u1fbpfcp-watermark.image?)\n\n最后，点击应用 ——> 点击保存即可。\n\n## 新建Jenkins任务\n\n### 点击新建任务，输入名称\n\n注意：本名称必须和项目名称一致，因为本名称会在jenkins工作空间下生成目录，类似于IDEA或Eclipse的工作空间的概念。所以，一般情况下，保证本名称=项目名称=docker镜像名称=docker容器名称 这样能尽可能的减轻jenkins配置的shell命令的复杂性！（空间命名要小写：因为镜像名不允许存在大写字母）\n\n选择构建一个Maven项目（因为是Spring Boot的服务）\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5a510bcf4ac49159f3f3b2960ae4fc5~tplv-k3u1fbpfcp-watermark.image?)\n\n### 源码管理\n\n输入描述信息，源码管理选择Git，从gitlab复制克隆地址（http协议的）粘贴到Repository URL中。未添加凭证会报授权失败的错误。错误如下：\n```\n![]()无法连接仓库：Command \"git ls-remote -h -- http://192.168.57.128:8880/root/video-book-backend.git HEAD\" returned status code 128:\\\nstdout:\\\nstderr: remote: HTTP Basic: Access denied\\\nfatal: Authentication failed for \'http://192.168.57.128:8880/root/video-book-backend.git/\'\n```\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94c2477c80724a959f8bb9f461814f41~tplv-k3u1fbpfcp-watermark.image?)\n\n添加gitlab凭证：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e08c1c343564fda9d5c599e985c38f5~tplv-k3u1fbpfcp-watermark.image?)\n\n### 构建触发器\n\n接下来将会生成供gitlab配置webhook使用的URL和Token，请记录下来，后面会使用。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1016fa1f35f24be7bf16ebe0a503bb8e~tplv-k3u1fbpfcp-watermark.image?)\n\n点击高级，拉下来找到Generate并点击，生成一串Secret Token。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13fb693d0ed14c63b8b613cccc7cd5b9~tplv-k3u1fbpfcp-watermark.image?)\n\n### 添加webhook\n\n前往gitlab，进入要构建的项目，在setting中选择Webhooks，输入URL和Secret Token 这两在上面图中已经给你标注了，去掉Enable SSL verification的勾选。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/904006704c604f6da4f2d1989200d462~tplv-k3u1fbpfcp-watermark.image?)\n\n点击Add webhook，如图表示成功添加了webhook：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6928c377f94748d0b70f57189e42e6cd~tplv-k3u1fbpfcp-watermark.image?)\n\n如果添加不成功解决方案请参考：[解决 Url is blocked: Requests to the local network are not allowed](https://www.cnblogs.com/zhongyuanzhao000/p/11379098.html)\n\n### 构建环境\n\n勾选Add timestamps to the Console Output，等下可以看到控制台打印的信息，这个根据自己的需求勾选。\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/badcdddabcc643b19f5a41fdc9f3416e~tplv-k3u1fbpfcp-watermark.image?)\n\n### Pre Steps(构建之前的步骤)\n\n配置前一步需要做的事情是：清理本项目在jenkins的workspace中的历史文件夹。\n\n你可以不用知道WORKSPACE具体的地址在哪里，因为下方有链接可以查看到当前jenkins中有哪些可用的变量供你使用。\n\n默认WORKSPACE地址：`/var/jenkins_home/workspace`（如果你jenkins是docker启动的，并且挂载了目录在宿主机，那你在宿主机也是可以看到的，即 `/usr/local/docker/workspace`）\n\n本处选择的是执行shell，则表示本处配置的shell命令，是默认在jenkins容器中执行的，而不是在宿主机上。\n\n下拉选择执行 shell：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c2e1bd362944ff2aab0a62646bae53d~tplv-k3u1fbpfcp-watermark.image?)\n\n在执行shell的命令中输入以下命令，设置全局变量：\n```\nSERVER_NAME_1=video-book-backend\necho \"=========================>>>>>>>工作空间WORKSPACE的地址：$WORKSPACE \"\ncd $WORKSPACE\necho \"=========================>>>>>>>进入工作空间WORKSPACE，清除工作空间中原项目的工作空间$SERVER_NAME_1 \"\nrm -rf $SERVER_NAME_1\necho \"=========================>>>>>>>清除工作空间中原项目的工作空间$SERVER_NAME_1 ......成功success\"\n```\n注意：本处的SERVER_NAME_1=jenkins-docker-gitlab-springboot是配置项目的名称(和gitlab中的项目名保持一致)\n\n### Build(构建)\n\n我们是SpringBoot项目，所以用到maven，这里设置一下全局操作，clean项目，并打成jar包，所以这里输入：`clean package`\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a41ff4b5061f48f39de4738c6282ec78~tplv-k3u1fbpfcp-watermark.image?)\n\n### Post Steps(执行任务)\n\n只在jenkins构建成功后，才执行这一步。\n\n因为最后的构建成功的maven项目的jar包是以docker启动服务为目的，所以最后的docker操作，一定是在jenkins容器以外的服务器上运行的，可能是本机宿主机，也可能是远程的服务器，这个根据自己的情况去配置。\n\n本处选择，在远程的SSH执行shell脚本。\n\n选中只有构建成功才执行这些命令，然后选择Execute shell script on remote host using ssh。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c25a57ddb8f4b10b31e4832503d4af2~tplv-k3u1fbpfcp-watermark.image?)\n\nshell命令:\n```\n# =====================================================================================\n# =================================定义初始化变量======================================\n# =====================================================================================\n\n# 操作/项目路径(Dockerfile存放的路径，Dockerfile一般都放在项目的根目录下)\n# 如果Dockerfile放在项目根目录的子目录下，则子目录不能与项目同名\n# 会导致在复制jar包的时候，覆盖子目录为jar包,同时没有扩展名jar,原因我暂时不知道\n# 目前我的做法是将Dockerfile放在项目根目录下\nBASE_PATH=/usr/local/docker/jenkins/workspace/video-book-backend\n\n# jenkins构建好的源jar路径\n# 这个路径是jenkins容器挂载在宿主机上的路径\n# 我的jenkins的目录被我挂载在了/usr/local/docker/jenkins上\nSOURCE_PATH=/usr/local/docker/jenkins/workspace\n\n# docker镜像、docker容器、Dockerfile同目录下的jar名字[用它build生成image的jar]、jenkins的workspace下的项目名称\n# 注意统一名称！！！！！\nSERVER_NAME=video-book-backend\n\n# 容器id  [grep -w 全量匹配容器名] [awk 获取信息行的第一列，即容器ID]  [无论容器启动与否，都获取到]\nCID=$(docker ps -a | grep -w \"$SERVER_NAME\" | awk \'{print $1}\')\n\n# 镜像id  [grep -w 全量匹配镜像名] [awk 获取信息行的第三列，即镜像ID]\nIID=$(docker images | grep -w \"$SERVER_NAME\" | awk \'{print $3}\')\n\n# 源jar完整地址[jenkins构建成功后，会在自己的workspace/项目/target下生成maven构建成功的jar包，获取jar包名的完整路径]\n# 例如：/usr/local/docker/jenkins/workspace/video-book-backend/target/video-book-backend-0.0.1-SNAPSHOT.jar\nSOURCE_JAR_PATH=$(find \"$SOURCE_PATH/$SERVER_NAME/target/\"  -name \"*$SERVER_NAME*.jar\" )\n\nDATE=`date +%Y%m%d%H%M%S`\n\n# =====================================================================================\n# ============================对原本已存在的jar进行备份================================\n# =====================================================================================\n\n# 备份\nfunction backup(){\n    if [ -f \"$BASE_PATH/$SERVER_NAME.jar\" ]; then\n        echo \"=========================>>>>>>>$SERVER_NAME.jar 备份...\"\n            mv $BASE_PATH/$SERVER_NAME.jar $BASE_PATH/backup/$SERVER_NAME-$DATE.jar\n        echo \"=========================>>>>>>>备份老的 $SERVER_NAME.jar 完成\"\n\n    else\n        echo \"=========================>>>>>>>老的$BASE_PATH/$SERVER_NAME.jar不存在，跳过备份\"\n    fi\n}\n\n# =====================================================================================\n# =========================移动最新源jar包到Dockerfile所在目录=========================\n# =====================================================================================\n\n\n \n# 查找源jar文件名，进行重命名，最后将源文件移动到Dockerfile文件所在目录\nfunction transfer(){\n      \n    echo \"=========================>>>>>>>源文件完整地址为 $SOURCE_JAR_PATH\"\n\n    echo \"=========================>>>>>>>重命名源文件\"\n        mv $SOURCE_JAR_PATH  $SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar\n\n    echo \"=========================>>>>>>>最新构建代码 将$SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar 迁移至 $BASE_PATH\"\n        cp $SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar $BASE_PATH\n        \n    echo \"=========================>>>>>>>迁移完成Success\"\n\n}\n \n# =====================================================================================\n# ==================================构建最新镜像=======================================\n# =====================================================================================\n\n# 构建docker镜像\nfunction build(){\n    \n    # 无论镜像存在与否，都停止原容器服务，并移除原容器服务\n    echo \"=========================>>>>>>>停止$SERVER_NAME容器，CID=$CID\"\n    docker stop $CID\n\n    echo \"=========================>>>>>>>移除$SERVER_NAME容器，CID=$CID\"\n    docker rm $CID\n\n    # 无论如何，都去构建新的镜像\n    if [ -n \"$IID\" ]; then\n        echo \"=========================>>>>>>>存在$SERVER_NAME镜像，IID=$IID\"\n\n        echo \"=========================>>>>>>>移除老的$SERVER_NAME镜像，IID=$IID\"\n        \n        docker rmi $IID\n\n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，开始---->\"\n        \n        cd $BASE_PATH\n        docker build -t $SERVER_NAME .\n        \n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，完成---->\"\n\n    else\n        echo \"=========================>>>>>>>不存在$SERVER_NAME镜像，构建新的镜像，开始--->\"\n        \n        cd $BASE_PATH\n        docker build -t $SERVER_NAME .\n        \n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，结束--->\"\n    fi\n}\n \n\n# =====================================================================================\n# ==============================运行docker容器，启动服务===============================\n# =====================================================================================\n\n# 运行docker容器\nfunction run(){\n    backup\n    transfer\n    build\n\n    # 创建容器\n    docker run --name $SERVER_NAME -itd --net=host -v /etc/localtime:/etc/localtime:ro  -v /etc/timezone:/etc/timezone:ro  $SERVER_NAME \n\n}\n \n# 入口\nrun\n```\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e67ba6d7cf14d52b00009c09afc9349~tplv-k3u1fbpfcp-watermark.image?)\n\nOK，到这里基本的任务已经新建成功，至于后续的两个步骤，根据自己的需求自行配置，没有难度的。\n\n点击应用，保存。\n\n### 测试\n\n测试push事件触发自动化构建和部署，点击test下拉选择push events，出现HTTP 200表示OK了。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e85f532d1c2b4643996604347b945f51~tplv-k3u1fbpfcp-watermark.image?)\n\n回到Jenkins可以看到任务列表，查看构建信息等。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f954757d41324660ae01ff5de6afe17e~tplv-k3u1fbpfcp-watermark.image?)\n\n待Jenkins构建成功之后，在服务器上执行命令：`docker ps`，可以看到我们启动起来的 SpringBoot 容器：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8556de2ce136416ea36e817b661c2f80~tplv-k3u1fbpfcp-watermark.image?)\n\n## 邮件通知\n\n有时候团队合作，我们希望能通过邮件通知每一个开发者，项目是否构建成功。jenkins/jenkins:2.332.1默认安装了`# Email Extension Template`这个插件，还需要安装`Email Extension Template`这个插件\n\n系统管理->插件管理->可选插件->搜索`Email Extension Template`\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51c60941d3d3422e88db89b5188a3168~tplv-k3u1fbpfcp-watermark.image?)\n\n直接安装\n\n### 配置Email(Jenkins自带)\n\n#### 2.1 基础信息查询\n\n>找到所要配置邮箱的基础信息，这里以QQ邮箱为例\n\n1. 通过网页端QQ邮箱的设置进入到邮箱客户端设置页面\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f31038ef147f4c728540bc581f64d522~tplv-k3u1fbpfcp-watermark.image?)\n\n2. 找到邮箱的基础信息\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5694801b0ed74685a76cade6b358c5fc~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 2.2 Jenkins邮件通知配置\n\n在Jenkins：`系统管理->系统配置`中，最底部找到`邮件通知`，打开`高级`,注意到在配置的下方有个\"通过发送测试邮件测试配置\"，我们可以讲其勾选，填入邮箱地址，点击`Test configuration`来先测试一下邮件的发送。\n\n> 这边最好先保存一下再测试，否则出错，又得重配。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6420215d674647fb824854fd68a3efd6~tplv-k3u1fbpfcp-watermark.image?)\n\n如果报错如下：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8481f74294404047a2671bc8e2a3297e~tplv-k3u1fbpfcp-watermark.image?)\n\n这是因为我们还需要在设置`Jenkins Location`中配置`系统管理员邮件地址`，此地址要和`邮件通知`中的`用户名`一致\n\n### 配置Email(Extended E-mail Notification)\n\n>记得文章一开头提到的下载Extended插件，没错，Jenkins系统设置里还可以通过`Extended E-mail Notification`对邮件发送进行模板格式的自定义\n\n#### 3.1 基础信息配置\n\n基础信息配置与上述一致,唯一要注意的是这里需要重新生成一个授权码\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cb0934380904b098a035e54297946d4~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 3.2 模板格式配置\n\n接3.1配置继续。这里主要就是配置展示的模板格式，常用的格式化的参数有：\n```\n- $BUILD_STATUS – 构建结果\n- $PROJECT_NAME – 构建脚本名称\n- $BUILD_NUMBER – 构建脚本编号\n- $JOB_DESCRIPTION – 构建项目描述 \n- $CAUSE – 脚本启动原因\n- $BUILD_URL – 脚本构建详情URL地址\n```\n\n这里选择以HTML的格式展示，填入模板：\n```\n<!DOCTYPE html>    \n<html>    \n<head>    \n<meta charset=\"UTF-8\">    \n<title>${ENV, var=\"JOB_NAME\"}-第${BUILD_NUMBER}次构建日志</title>    \n</head>    \n    \n<body leftmargin=\"8\" marginwidth=\"0\" topmargin=\"8\" marginheight=\"4\"    \n    offset=\"0\">    \n    <table width=\"95%\" cellpadding=\"0\" cellspacing=\"0\"  style=\"font-size: 11pt; font-family: Tahoma, Arial, Helvetica, sans-serif\">    \n        <tr>    \n            本邮件由系统自动发出，无需回复！<br/>            \n            各位同事，大家好，以下为${PROJECT_NAME}项目构建信息</br> \n            <td><font color=\"#CC0000\">构建结果 - ${BUILD_STATUS}</font></td>   \n        </tr>    \n        <tr>    \n            <td><br />    \n            <b><font color=\"#0B610B\">构建信息</font></b>    \n            <hr size=\"2\" width=\"100%\" align=\"center\" /></td>    \n        </tr>    \n        <tr>    \n            <td>    \n                <ul>    \n                    <li>项目名称 ： ${PROJECT_NAME}</li>    \n                    <li>构建编号 ： 第${BUILD_NUMBER}次构建</li>    \n                    <li>触发原因： ${CAUSE}</li>    \n                    <li>构建状态： ${BUILD_STATUS}</li>    \n                    <li>构建日志： <a href=\"${BUILD_URL}console\">${BUILD_URL}console</a></li>    \n                    <li>构建  Url ： <a href=\"${BUILD_URL}\">${BUILD_URL}</a></li>    \n                    <li>工作目录 ： <a href=\"${PROJECT_URL}ws\">${PROJECT_URL}ws</a></li>    \n                    <li>项目  Url ： <a href=\"${PROJECT_URL}\">${PROJECT_URL}</a></li>    \n                </ul>    \n\n<h4><font color=\"#0B610B\">失败用例</font></h4>\n<hr size=\"2\" width=\"100%\" />\n$FAILED_TESTS<br/>\n\n<h4><font color=\"#0B610B\">最近提交(#$SVN_REVISION)</font></h4>\n<hr size=\"2\" width=\"100%\" />\n<ul>\n${CHANGES_SINCE_LAST_SUCCESS, reverse=true, format=\"%c\", changesFormat=\"<li>%d [%a] %m</li>\"}\n</ul>\n详细提交: <a href=\"${PROJECT_URL}changes\">${PROJECT_URL}changes</a><br/>\n\n            </td>    \n        </tr>    \n    </table>    \n</body>    \n</html>\n```\n\n如下图：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8b10b649f4943e1944fc094c72a3d2e~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 3.3 触发条件配置\n\n我们还可以在`Default Triggers`中根据自己的需要配置邮件的触发条件\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4328af1e2934c81b61f8c0429b6313b~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16835dfc64334f0e93a6cb7fd262922a~tplv-k3u1fbpfcp-watermark.image?)\n\n>这里为了防止因为构建一直尝试结果均为失败而造成的邮件轰炸，可以设置邮件仅第一次或第二次构建结果为失败时才发送邮件，后续失败的邮件将不再发送。我选择的是每一次失败和构建成功都会发邮件通知\n\n#### 3.4 jenkins的任务中配置邮件通知\n\n1. 在对应的任务中的构建设置中，勾选`E-mail Notification Recipients`\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/224fb406029d46d489cb6192848fdb6e~tplv-k3u1fbpfcp-watermark.image?)\n\n2. 在对应的任务中的构建后操作中，下拉选择`Editable Email Notification`\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1abc14189c874a818e5fe42a90371e43~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/594c71d3301544e48f6cc7468724b964~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b633844afb7a43e488cd3ab81d7c08a9~tplv-k3u1fbpfcp-watermark.image?)\n\n至此，jnekins的自动化构建的邮件通知已配置完成，在gitlab点击push event发起构建进行测试。\n\n发送成功的话，可看到如下图的提示：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a26d60de670c48ca991975dc2d20fa20~tplv-k3u1fbpfcp-watermark.image?)\n\n## 总结\n\n经过多款插件的安装配置，逐步掌握了如何上床Spring Boot项目到Gitlab中，并使用Jenkins自动构建任务，另外依托于Docker，让这一切变得更加方便，希望大家都多多思考，让机器自动干活，减少我们IT从业人员的重复、繁琐的工作量。\n\n\n', '小白学习gitlab+jenkins进行自动化构建(docker)之springboot项目', 0, 7, 2, 9, 0, '2023-06-09 16:56:30', '2023-06-09 16:56:30', 0);
INSERT INTO `tb_article` VALUES (11, '小白学习gitlab+jenkins进行自动化构建(docker)之springboot项目', '## 前言\ngitlab和jenkins的安装参考我的另外两篇博客：\n* gitlab安装：[小白搭建gitlab(docker)](https://juejin.cn/post/7032898607686778910)\n* jenkins安装：[小白学习搭建jenkins(docker)](https://juejin.cn/post/7032891246490157093/)\n\n## 在Jenkins上安装必要的插件\n所需插件：`Maven Integration`、`Pipeline Maven Integration`、`Gitlab`、`GitLab Authentication`、`SSH`、`Publish Over SSH`、`Docker`\n\n点击 Manage Jenkins（系统管理） ——> Manage Plugins（插件管理）\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5d15509337b44198064ba2bd41f221e~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Maven插件\n\n点击可选插件 ——> 过滤Maven Integration插件 ——> 勾选Maven Integration和Pipeline Maven Integration ——> 点击直接安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e496dbb12972454789d19546d660c88d~tplv-k3u1fbpfcp-watermark.image?)\n\n如图开始安装插件：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/134fef5f496c468b8dad342454c83b45~tplv-k3u1fbpfcp-watermark.image?)\n\n安装完成后，即可在插件管理下的已安装选项卡下看到刚刚已经安装的插件。\n\n#### 安装Gitlab插件\n\n点击可选插件 ——> 过滤Gitlab插件 ——> 勾选Gitlab和Gitlab Authentication ——> 点击直接安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6171674e55b428c9eba7be7cc2f516c~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装SSH插件和Publish Over SSH插件\n安装Publish Over SSH插件的原因：因为本方式是使用docker启动jenkins服务，所以在jenkins后续执行构建任务时候，需要在build成功后，将服务的jar包（以spring boot服务为例）拷贝到Dockerfile所在服务器的指定目录，进行微服务的启动；所以，此处需要配置SSH服务器的连接，意思就是在jenkins的任务结束后，去执行指定的服务器上的shell命令，做spring boot或cloud服务的镜像的构建，容器的运行，等一系列的事情。\n\n点击可选插件 ——> 过滤SSH插件 ——> 勾选SSH和Publish Over SSH ——> 点击直接安装\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d21ba2054860482b8b07684f48468538~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Docker插件\n\n点击可选插件 ——> 过滤Docker插件 ——> 勾选Docker ——> 点击直接安装\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1501abfe94b431a91e5692c41d12f72~tplv-k3u1fbpfcp-watermark.image?)\n\n插件全部安装完成后，可以重启一下Jenkins。\n\n## 相关配置\n\n#### 添加凭据\n\n点击 Manage Jenkins（系统管理） ——> Manage Credentials（凭据管理）\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0d3890020d34004adb05cab48310dd1~tplv-k3u1fbpfcp-watermark.image?)\n\n点击添加凭据 ——> 输入宿主机服务器的用户名和密码等信息并保存\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8eb6e5330d2140cb9705256fc722dc9d~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 配置SSH remote hosts\n\n这个配置是干什么的呢？配置SSH连接Dockerfile所在服务器的相关信息，并添加凭证，最后测试连接并保存，以备后面使用！！！\n\n点击 Manage Jenkins（系统管理） ——> 系统配置\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3813b66e9134305a1acb1d7515110bd~tplv-k3u1fbpfcp-watermark.image?)\n\n找到配置 ——> 下拉选择SSH remote hosts\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7436757a876049db93e6b255662001f2~tplv-k3u1fbpfcp-watermark.image?)\n\n如下图，输入对应的信息，并校验是否连接成功！成功后，点击应用 ——> 点击保存\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3559c64c918c4355aaff8d136e689da9~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 配置Publish over SSH\n\n找到配置 ——> 下拉选择Publish over SSH，进行相关配置即可。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0bb12f108302405ba90bb33e80fd0d5e~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78ad24f26a2a46b68ea44ea1c6ceb537~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de7ba1ca4a074ad1bb6f6a4b8fe71ee3~tplv-k3u1fbpfcp-watermark.image?)\n\n这里配置的数据，目前只能在Post Steps中选中send files or execute commands over ssh使用，要想能够在execute shell script on remote host using ssh方式中使用，需要再配置一份SSH remote hosts和它配套使用\n\n## 全局工具配置\n\n由于我们要实现的是SpringBoot项目的自动化部署操作，所以需要安装JDK、Git、Maven、Docker。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0dec279d6d44a83b2138cd7663e0995~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装JDK\n\n可以安装多个，根据项目JDK版本需求。\n\n输入自定义JDK名称 ——> 勾选自动安装 ——> 输入Oracle账户、密码 ——> 选择JDK版本 ——> 勾选同意协议\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72aa67fd5a494228840c5bef060e36b8~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Git\n\n输入自定义Git名称 ——> 勾选自动安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b49eb7bd11d48ab9ffce4f29431c216~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Maven\n\n输入自定义名称 ——> 勾选自动安装 ——> 选择版本\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5394195a98b647189dfaa5cd74b1a0b0~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Docker\n\n输入自定义名称 ——> 勾选自动安装\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/893704cbe8fe449fb615534bf9e82cea~tplv-k3u1fbpfcp-watermark.image?)\n\n最后，点击应用 ——> 点击保存即可。\n\n## 新建Jenkins任务\n\n### 点击新建任务，输入名称\n\n注意：本名称必须和项目名称一致，因为本名称会在jenkins工作空间下生成目录，类似于IDEA或Eclipse的工作空间的概念。所以，一般情况下，保证本名称=项目名称=docker镜像名称=docker容器名称 这样能尽可能的减轻jenkins配置的shell命令的复杂性！（空间命名要小写：因为镜像名不允许存在大写字母）\n\n选择构建一个Maven项目（因为是Spring Boot的服务）\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5a510bcf4ac49159f3f3b2960ae4fc5~tplv-k3u1fbpfcp-watermark.image?)\n\n### 源码管理\n\n输入描述信息，源码管理选择Git，从gitlab复制克隆地址（http协议的）粘贴到Repository URL中。未添加凭证会报授权失败的错误。错误如下：\n```\n![]()无法连接仓库：Command \"git ls-remote -h -- http://192.168.57.128:8880/root/video-book-backend.git HEAD\" returned status code 128:\\\nstdout:\\\nstderr: remote: HTTP Basic: Access denied\\\nfatal: Authentication failed for \'http://192.168.57.128:8880/root/video-book-backend.git/\'\n```\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94c2477c80724a959f8bb9f461814f41~tplv-k3u1fbpfcp-watermark.image?)\n\n添加gitlab凭证：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e08c1c343564fda9d5c599e985c38f5~tplv-k3u1fbpfcp-watermark.image?)\n\n### 构建触发器\n\n接下来将会生成供gitlab配置webhook使用的URL和Token，请记录下来，后面会使用。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1016fa1f35f24be7bf16ebe0a503bb8e~tplv-k3u1fbpfcp-watermark.image?)\n\n点击高级，拉下来找到Generate并点击，生成一串Secret Token。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13fb693d0ed14c63b8b613cccc7cd5b9~tplv-k3u1fbpfcp-watermark.image?)\n\n### 添加webhook\n\n前往gitlab，进入要构建的项目，在setting中选择Webhooks，输入URL和Secret Token 这两在上面图中已经给你标注了，去掉Enable SSL verification的勾选。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/904006704c604f6da4f2d1989200d462~tplv-k3u1fbpfcp-watermark.image?)\n\n点击Add webhook，如图表示成功添加了webhook：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6928c377f94748d0b70f57189e42e6cd~tplv-k3u1fbpfcp-watermark.image?)\n\n如果添加不成功解决方案请参考：[解决 Url is blocked: Requests to the local network are not allowed](https://www.cnblogs.com/zhongyuanzhao000/p/11379098.html)\n\n### 构建环境\n\n勾选Add timestamps to the Console Output，等下可以看到控制台打印的信息，这个根据自己的需求勾选。\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/badcdddabcc643b19f5a41fdc9f3416e~tplv-k3u1fbpfcp-watermark.image?)\n\n### Pre Steps(构建之前的步骤)\n\n配置前一步需要做的事情是：清理本项目在jenkins的workspace中的历史文件夹。\n\n你可以不用知道WORKSPACE具体的地址在哪里，因为下方有链接可以查看到当前jenkins中有哪些可用的变量供你使用。\n\n默认WORKSPACE地址：`/var/jenkins_home/workspace`（如果你jenkins是docker启动的，并且挂载了目录在宿主机，那你在宿主机也是可以看到的，即 `/usr/local/docker/workspace`）\n\n本处选择的是执行shell，则表示本处配置的shell命令，是默认在jenkins容器中执行的，而不是在宿主机上。\n\n下拉选择执行 shell：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c2e1bd362944ff2aab0a62646bae53d~tplv-k3u1fbpfcp-watermark.image?)\n\n在执行shell的命令中输入以下命令，设置全局变量：\n```\nSERVER_NAME_1=video-book-backend\necho \"=========================>>>>>>>工作空间WORKSPACE的地址：$WORKSPACE \"\ncd $WORKSPACE\necho \"=========================>>>>>>>进入工作空间WORKSPACE，清除工作空间中原项目的工作空间$SERVER_NAME_1 \"\nrm -rf $SERVER_NAME_1\necho \"=========================>>>>>>>清除工作空间中原项目的工作空间$SERVER_NAME_1 ......成功success\"\n```\n注意：本处的SERVER_NAME_1=jenkins-docker-gitlab-springboot是配置项目的名称(和gitlab中的项目名保持一致)\n\n### Build(构建)\n\n我们是SpringBoot项目，所以用到maven，这里设置一下全局操作，clean项目，并打成jar包，所以这里输入：`clean package`\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a41ff4b5061f48f39de4738c6282ec78~tplv-k3u1fbpfcp-watermark.image?)\n\n### Post Steps(执行任务)\n\n只在jenkins构建成功后，才执行这一步。\n\n因为最后的构建成功的maven项目的jar包是以docker启动服务为目的，所以最后的docker操作，一定是在jenkins容器以外的服务器上运行的，可能是本机宿主机，也可能是远程的服务器，这个根据自己的情况去配置。\n\n本处选择，在远程的SSH执行shell脚本。\n\n选中只有构建成功才执行这些命令，然后选择Execute shell script on remote host using ssh。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c25a57ddb8f4b10b31e4832503d4af2~tplv-k3u1fbpfcp-watermark.image?)\n\nshell命令:\n```\n# =====================================================================================\n# =================================定义初始化变量======================================\n# =====================================================================================\n\n# 操作/项目路径(Dockerfile存放的路径，Dockerfile一般都放在项目的根目录下)\n# 如果Dockerfile放在项目根目录的子目录下，则子目录不能与项目同名\n# 会导致在复制jar包的时候，覆盖子目录为jar包,同时没有扩展名jar,原因我暂时不知道\n# 目前我的做法是将Dockerfile放在项目根目录下\nBASE_PATH=/usr/local/docker/jenkins/workspace/video-book-backend\n\n# jenkins构建好的源jar路径\n# 这个路径是jenkins容器挂载在宿主机上的路径\n# 我的jenkins的目录被我挂载在了/usr/local/docker/jenkins上\nSOURCE_PATH=/usr/local/docker/jenkins/workspace\n\n# docker镜像、docker容器、Dockerfile同目录下的jar名字[用它build生成image的jar]、jenkins的workspace下的项目名称\n# 注意统一名称！！！！！\nSERVER_NAME=video-book-backend\n\n# 容器id  [grep -w 全量匹配容器名] [awk 获取信息行的第一列，即容器ID]  [无论容器启动与否，都获取到]\nCID=$(docker ps -a | grep -w \"$SERVER_NAME\" | awk \'{print $1}\')\n\n# 镜像id  [grep -w 全量匹配镜像名] [awk 获取信息行的第三列，即镜像ID]\nIID=$(docker images | grep -w \"$SERVER_NAME\" | awk \'{print $3}\')\n\n# 源jar完整地址[jenkins构建成功后，会在自己的workspace/项目/target下生成maven构建成功的jar包，获取jar包名的完整路径]\n# 例如：/usr/local/docker/jenkins/workspace/video-book-backend/target/video-book-backend-0.0.1-SNAPSHOT.jar\nSOURCE_JAR_PATH=$(find \"$SOURCE_PATH/$SERVER_NAME/target/\"  -name \"*$SERVER_NAME*.jar\" )\n\nDATE=`date +%Y%m%d%H%M%S`\n\n# =====================================================================================\n# ============================对原本已存在的jar进行备份================================\n# =====================================================================================\n\n# 备份\nfunction backup(){\n    if [ -f \"$BASE_PATH/$SERVER_NAME.jar\" ]; then\n        echo \"=========================>>>>>>>$SERVER_NAME.jar 备份...\"\n            mv $BASE_PATH/$SERVER_NAME.jar $BASE_PATH/backup/$SERVER_NAME-$DATE.jar\n        echo \"=========================>>>>>>>备份老的 $SERVER_NAME.jar 完成\"\n\n    else\n        echo \"=========================>>>>>>>老的$BASE_PATH/$SERVER_NAME.jar不存在，跳过备份\"\n    fi\n}\n\n# =====================================================================================\n# =========================移动最新源jar包到Dockerfile所在目录=========================\n# =====================================================================================\n\n\n \n# 查找源jar文件名，进行重命名，最后将源文件移动到Dockerfile文件所在目录\nfunction transfer(){\n      \n    echo \"=========================>>>>>>>源文件完整地址为 $SOURCE_JAR_PATH\"\n\n    echo \"=========================>>>>>>>重命名源文件\"\n        mv $SOURCE_JAR_PATH  $SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar\n\n    echo \"=========================>>>>>>>最新构建代码 将$SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar 迁移至 $BASE_PATH\"\n        cp $SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar $BASE_PATH\n        \n    echo \"=========================>>>>>>>迁移完成Success\"\n\n}\n \n# =====================================================================================\n# ==================================构建最新镜像=======================================\n# =====================================================================================\n\n# 构建docker镜像\nfunction build(){\n    \n    # 无论镜像存在与否，都停止原容器服务，并移除原容器服务\n    echo \"=========================>>>>>>>停止$SERVER_NAME容器，CID=$CID\"\n    docker stop $CID\n\n    echo \"=========================>>>>>>>移除$SERVER_NAME容器，CID=$CID\"\n    docker rm $CID\n\n    # 无论如何，都去构建新的镜像\n    if [ -n \"$IID\" ]; then\n        echo \"=========================>>>>>>>存在$SERVER_NAME镜像，IID=$IID\"\n\n        echo \"=========================>>>>>>>移除老的$SERVER_NAME镜像，IID=$IID\"\n        \n        docker rmi $IID\n\n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，开始---->\"\n        \n        cd $BASE_PATH\n        docker build -t $SERVER_NAME .\n        \n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，完成---->\"\n\n    else\n        echo \"=========================>>>>>>>不存在$SERVER_NAME镜像，构建新的镜像，开始--->\"\n        \n        cd $BASE_PATH\n        docker build -t $SERVER_NAME .\n        \n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，结束--->\"\n    fi\n}\n \n\n# =====================================================================================\n# ==============================运行docker容器，启动服务===============================\n# =====================================================================================\n\n# 运行docker容器\nfunction run(){\n    backup\n    transfer\n    build\n\n    # 创建容器\n    docker run --name $SERVER_NAME -itd --net=host -v /etc/localtime:/etc/localtime:ro  -v /etc/timezone:/etc/timezone:ro  $SERVER_NAME \n\n}\n \n# 入口\nrun\n```\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e67ba6d7cf14d52b00009c09afc9349~tplv-k3u1fbpfcp-watermark.image?)\n\nOK，到这里基本的任务已经新建成功，至于后续的两个步骤，根据自己的需求自行配置，没有难度的。\n\n点击应用，保存。\n\n### 测试\n\n测试push事件触发自动化构建和部署，点击test下拉选择push events，出现HTTP 200表示OK了。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e85f532d1c2b4643996604347b945f51~tplv-k3u1fbpfcp-watermark.image?)\n\n回到Jenkins可以看到任务列表，查看构建信息等。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f954757d41324660ae01ff5de6afe17e~tplv-k3u1fbpfcp-watermark.image?)\n\n待Jenkins构建成功之后，在服务器上执行命令：`docker ps`，可以看到我们启动起来的 SpringBoot 容器：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8556de2ce136416ea36e817b661c2f80~tplv-k3u1fbpfcp-watermark.image?)\n\n## 邮件通知\n\n有时候团队合作，我们希望能通过邮件通知每一个开发者，项目是否构建成功。jenkins/jenkins:2.332.1默认安装了`# Email Extension Template`这个插件，还需要安装`Email Extension Template`这个插件\n\n系统管理->插件管理->可选插件->搜索`Email Extension Template`\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51c60941d3d3422e88db89b5188a3168~tplv-k3u1fbpfcp-watermark.image?)\n\n直接安装\n\n### 配置Email(Jenkins自带)\n\n#### 2.1 基础信息查询\n\n>找到所要配置邮箱的基础信息，这里以QQ邮箱为例\n\n1. 通过网页端QQ邮箱的设置进入到邮箱客户端设置页面\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f31038ef147f4c728540bc581f64d522~tplv-k3u1fbpfcp-watermark.image?)\n\n2. 找到邮箱的基础信息\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5694801b0ed74685a76cade6b358c5fc~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 2.2 Jenkins邮件通知配置\n\n在Jenkins：`系统管理->系统配置`中，最底部找到`邮件通知`，打开`高级`,注意到在配置的下方有个\"通过发送测试邮件测试配置\"，我们可以讲其勾选，填入邮箱地址，点击`Test configuration`来先测试一下邮件的发送。\n\n> 这边最好先保存一下再测试，否则出错，又得重配。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6420215d674647fb824854fd68a3efd6~tplv-k3u1fbpfcp-watermark.image?)\n\n如果报错如下：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8481f74294404047a2671bc8e2a3297e~tplv-k3u1fbpfcp-watermark.image?)\n\n这是因为我们还需要在设置`Jenkins Location`中配置`系统管理员邮件地址`，此地址要和`邮件通知`中的`用户名`一致\n\n### 配置Email(Extended E-mail Notification)\n\n>记得文章一开头提到的下载Extended插件，没错，Jenkins系统设置里还可以通过`Extended E-mail Notification`对邮件发送进行模板格式的自定义\n\n#### 3.1 基础信息配置\n\n基础信息配置与上述一致,唯一要注意的是这里需要重新生成一个授权码\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cb0934380904b098a035e54297946d4~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 3.2 模板格式配置\n\n接3.1配置继续。这里主要就是配置展示的模板格式，常用的格式化的参数有：\n```\n- $BUILD_STATUS – 构建结果\n- $PROJECT_NAME – 构建脚本名称\n- $BUILD_NUMBER – 构建脚本编号\n- $JOB_DESCRIPTION – 构建项目描述 \n- $CAUSE – 脚本启动原因\n- $BUILD_URL – 脚本构建详情URL地址\n```\n\n这里选择以HTML的格式展示，填入模板：\n```\n<!DOCTYPE html>    \n<html>    \n<head>    \n<meta charset=\"UTF-8\">    \n<title>${ENV, var=\"JOB_NAME\"}-第${BUILD_NUMBER}次构建日志</title>    \n</head>    \n    \n<body leftmargin=\"8\" marginwidth=\"0\" topmargin=\"8\" marginheight=\"4\"    \n    offset=\"0\">    \n    <table width=\"95%\" cellpadding=\"0\" cellspacing=\"0\"  style=\"font-size: 11pt; font-family: Tahoma, Arial, Helvetica, sans-serif\">    \n        <tr>    \n            本邮件由系统自动发出，无需回复！<br/>            \n            各位同事，大家好，以下为${PROJECT_NAME}项目构建信息</br> \n            <td><font color=\"#CC0000\">构建结果 - ${BUILD_STATUS}</font></td>   \n        </tr>    \n        <tr>    \n            <td><br />    \n            <b><font color=\"#0B610B\">构建信息</font></b>    \n            <hr size=\"2\" width=\"100%\" align=\"center\" /></td>    \n        </tr>    \n        <tr>    \n            <td>    \n                <ul>    \n                    <li>项目名称 ： ${PROJECT_NAME}</li>    \n                    <li>构建编号 ： 第${BUILD_NUMBER}次构建</li>    \n                    <li>触发原因： ${CAUSE}</li>    \n                    <li>构建状态： ${BUILD_STATUS}</li>    \n                    <li>构建日志： <a href=\"${BUILD_URL}console\">${BUILD_URL}console</a></li>    \n                    <li>构建  Url ： <a href=\"${BUILD_URL}\">${BUILD_URL}</a></li>    \n                    <li>工作目录 ： <a href=\"${PROJECT_URL}ws\">${PROJECT_URL}ws</a></li>    \n                    <li>项目  Url ： <a href=\"${PROJECT_URL}\">${PROJECT_URL}</a></li>    \n                </ul>    \n\n<h4><font color=\"#0B610B\">失败用例</font></h4>\n<hr size=\"2\" width=\"100%\" />\n$FAILED_TESTS<br/>\n\n<h4><font color=\"#0B610B\">最近提交(#$SVN_REVISION)</font></h4>\n<hr size=\"2\" width=\"100%\" />\n<ul>\n${CHANGES_SINCE_LAST_SUCCESS, reverse=true, format=\"%c\", changesFormat=\"<li>%d [%a] %m</li>\"}\n</ul>\n详细提交: <a href=\"${PROJECT_URL}changes\">${PROJECT_URL}changes</a><br/>\n\n            </td>    \n        </tr>    \n    </table>    \n</body>    \n</html>\n```\n\n如下图：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8b10b649f4943e1944fc094c72a3d2e~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 3.3 触发条件配置\n\n我们还可以在`Default Triggers`中根据自己的需要配置邮件的触发条件\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4328af1e2934c81b61f8c0429b6313b~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16835dfc64334f0e93a6cb7fd262922a~tplv-k3u1fbpfcp-watermark.image?)\n\n>这里为了防止因为构建一直尝试结果均为失败而造成的邮件轰炸，可以设置邮件仅第一次或第二次构建结果为失败时才发送邮件，后续失败的邮件将不再发送。我选择的是每一次失败和构建成功都会发邮件通知\n\n#### 3.4 jenkins的任务中配置邮件通知\n\n1. 在对应的任务中的构建设置中，勾选`E-mail Notification Recipients`\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/224fb406029d46d489cb6192848fdb6e~tplv-k3u1fbpfcp-watermark.image?)\n\n2. 在对应的任务中的构建后操作中，下拉选择`Editable Email Notification`\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1abc14189c874a818e5fe42a90371e43~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/594c71d3301544e48f6cc7468724b964~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b633844afb7a43e488cd3ab81d7c08a9~tplv-k3u1fbpfcp-watermark.image?)\n\n至此，jnekins的自动化构建的邮件通知已配置完成，在gitlab点击push event发起构建进行测试。\n\n发送成功的话，可看到如下图的提示：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a26d60de670c48ca991975dc2d20fa20~tplv-k3u1fbpfcp-watermark.image?)\n\n## 总结\n\n经过多款插件的安装配置，逐步掌握了如何上床Spring Boot项目到Gitlab中，并使用Jenkins自动构建任务，另外依托于Docker，让这一切变得更加方便，希望大家都多多思考，让机器自动干活，减少我们IT从业人员的重复、繁琐的工作量。\n\n\n', '小白学习gitlab+jenkins进行自动化构建(docker)之springboot项目', 0, 7, 2, 9, 0, '2023-06-09 16:56:30', '2023-06-09 16:56:30', 0);
INSERT INTO `tb_article` VALUES (12, '小白学习gitlab+jenkins进行自动化构建(docker)之springboot项目', '## 前言\ngitlab和jenkins的安装参考我的另外两篇博客：\n* gitlab安装：[小白搭建gitlab(docker)](https://juejin.cn/post/7032898607686778910)\n* jenkins安装：[小白学习搭建jenkins(docker)](https://juejin.cn/post/7032891246490157093/)\n\n## 在Jenkins上安装必要的插件\n所需插件：`Maven Integration`、`Pipeline Maven Integration`、`Gitlab`、`GitLab Authentication`、`SSH`、`Publish Over SSH`、`Docker`\n\n点击 Manage Jenkins（系统管理） ——> Manage Plugins（插件管理）\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5d15509337b44198064ba2bd41f221e~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Maven插件\n\n点击可选插件 ——> 过滤Maven Integration插件 ——> 勾选Maven Integration和Pipeline Maven Integration ——> 点击直接安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e496dbb12972454789d19546d660c88d~tplv-k3u1fbpfcp-watermark.image?)\n\n如图开始安装插件：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/134fef5f496c468b8dad342454c83b45~tplv-k3u1fbpfcp-watermark.image?)\n\n安装完成后，即可在插件管理下的已安装选项卡下看到刚刚已经安装的插件。\n\n#### 安装Gitlab插件\n\n点击可选插件 ——> 过滤Gitlab插件 ——> 勾选Gitlab和Gitlab Authentication ——> 点击直接安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6171674e55b428c9eba7be7cc2f516c~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装SSH插件和Publish Over SSH插件\n安装Publish Over SSH插件的原因：因为本方式是使用docker启动jenkins服务，所以在jenkins后续执行构建任务时候，需要在build成功后，将服务的jar包（以spring boot服务为例）拷贝到Dockerfile所在服务器的指定目录，进行微服务的启动；所以，此处需要配置SSH服务器的连接，意思就是在jenkins的任务结束后，去执行指定的服务器上的shell命令，做spring boot或cloud服务的镜像的构建，容器的运行，等一系列的事情。\n\n点击可选插件 ——> 过滤SSH插件 ——> 勾选SSH和Publish Over SSH ——> 点击直接安装\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d21ba2054860482b8b07684f48468538~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Docker插件\n\n点击可选插件 ——> 过滤Docker插件 ——> 勾选Docker ——> 点击直接安装\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1501abfe94b431a91e5692c41d12f72~tplv-k3u1fbpfcp-watermark.image?)\n\n插件全部安装完成后，可以重启一下Jenkins。\n\n## 相关配置\n\n#### 添加凭据\n\n点击 Manage Jenkins（系统管理） ——> Manage Credentials（凭据管理）\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0d3890020d34004adb05cab48310dd1~tplv-k3u1fbpfcp-watermark.image?)\n\n点击添加凭据 ——> 输入宿主机服务器的用户名和密码等信息并保存\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8eb6e5330d2140cb9705256fc722dc9d~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 配置SSH remote hosts\n\n这个配置是干什么的呢？配置SSH连接Dockerfile所在服务器的相关信息，并添加凭证，最后测试连接并保存，以备后面使用！！！\n\n点击 Manage Jenkins（系统管理） ——> 系统配置\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3813b66e9134305a1acb1d7515110bd~tplv-k3u1fbpfcp-watermark.image?)\n\n找到配置 ——> 下拉选择SSH remote hosts\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7436757a876049db93e6b255662001f2~tplv-k3u1fbpfcp-watermark.image?)\n\n如下图，输入对应的信息，并校验是否连接成功！成功后，点击应用 ——> 点击保存\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3559c64c918c4355aaff8d136e689da9~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 配置Publish over SSH\n\n找到配置 ——> 下拉选择Publish over SSH，进行相关配置即可。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0bb12f108302405ba90bb33e80fd0d5e~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78ad24f26a2a46b68ea44ea1c6ceb537~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de7ba1ca4a074ad1bb6f6a4b8fe71ee3~tplv-k3u1fbpfcp-watermark.image?)\n\n这里配置的数据，目前只能在Post Steps中选中send files or execute commands over ssh使用，要想能够在execute shell script on remote host using ssh方式中使用，需要再配置一份SSH remote hosts和它配套使用\n\n## 全局工具配置\n\n由于我们要实现的是SpringBoot项目的自动化部署操作，所以需要安装JDK、Git、Maven、Docker。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0dec279d6d44a83b2138cd7663e0995~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装JDK\n\n可以安装多个，根据项目JDK版本需求。\n\n输入自定义JDK名称 ——> 勾选自动安装 ——> 输入Oracle账户、密码 ——> 选择JDK版本 ——> 勾选同意协议\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72aa67fd5a494228840c5bef060e36b8~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Git\n\n输入自定义Git名称 ——> 勾选自动安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b49eb7bd11d48ab9ffce4f29431c216~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Maven\n\n输入自定义名称 ——> 勾选自动安装 ——> 选择版本\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5394195a98b647189dfaa5cd74b1a0b0~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Docker\n\n输入自定义名称 ——> 勾选自动安装\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/893704cbe8fe449fb615534bf9e82cea~tplv-k3u1fbpfcp-watermark.image?)\n\n最后，点击应用 ——> 点击保存即可。\n\n## 新建Jenkins任务\n\n### 点击新建任务，输入名称\n\n注意：本名称必须和项目名称一致，因为本名称会在jenkins工作空间下生成目录，类似于IDEA或Eclipse的工作空间的概念。所以，一般情况下，保证本名称=项目名称=docker镜像名称=docker容器名称 这样能尽可能的减轻jenkins配置的shell命令的复杂性！（空间命名要小写：因为镜像名不允许存在大写字母）\n\n选择构建一个Maven项目（因为是Spring Boot的服务）\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5a510bcf4ac49159f3f3b2960ae4fc5~tplv-k3u1fbpfcp-watermark.image?)\n\n### 源码管理\n\n输入描述信息，源码管理选择Git，从gitlab复制克隆地址（http协议的）粘贴到Repository URL中。未添加凭证会报授权失败的错误。错误如下：\n```\n![]()无法连接仓库：Command \"git ls-remote -h -- http://192.168.57.128:8880/root/video-book-backend.git HEAD\" returned status code 128:\\\nstdout:\\\nstderr: remote: HTTP Basic: Access denied\\\nfatal: Authentication failed for \'http://192.168.57.128:8880/root/video-book-backend.git/\'\n```\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94c2477c80724a959f8bb9f461814f41~tplv-k3u1fbpfcp-watermark.image?)\n\n添加gitlab凭证：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e08c1c343564fda9d5c599e985c38f5~tplv-k3u1fbpfcp-watermark.image?)\n\n### 构建触发器\n\n接下来将会生成供gitlab配置webhook使用的URL和Token，请记录下来，后面会使用。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1016fa1f35f24be7bf16ebe0a503bb8e~tplv-k3u1fbpfcp-watermark.image?)\n\n点击高级，拉下来找到Generate并点击，生成一串Secret Token。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13fb693d0ed14c63b8b613cccc7cd5b9~tplv-k3u1fbpfcp-watermark.image?)\n\n### 添加webhook\n\n前往gitlab，进入要构建的项目，在setting中选择Webhooks，输入URL和Secret Token 这两在上面图中已经给你标注了，去掉Enable SSL verification的勾选。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/904006704c604f6da4f2d1989200d462~tplv-k3u1fbpfcp-watermark.image?)\n\n点击Add webhook，如图表示成功添加了webhook：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6928c377f94748d0b70f57189e42e6cd~tplv-k3u1fbpfcp-watermark.image?)\n\n如果添加不成功解决方案请参考：[解决 Url is blocked: Requests to the local network are not allowed](https://www.cnblogs.com/zhongyuanzhao000/p/11379098.html)\n\n### 构建环境\n\n勾选Add timestamps to the Console Output，等下可以看到控制台打印的信息，这个根据自己的需求勾选。\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/badcdddabcc643b19f5a41fdc9f3416e~tplv-k3u1fbpfcp-watermark.image?)\n\n### Pre Steps(构建之前的步骤)\n\n配置前一步需要做的事情是：清理本项目在jenkins的workspace中的历史文件夹。\n\n你可以不用知道WORKSPACE具体的地址在哪里，因为下方有链接可以查看到当前jenkins中有哪些可用的变量供你使用。\n\n默认WORKSPACE地址：`/var/jenkins_home/workspace`（如果你jenkins是docker启动的，并且挂载了目录在宿主机，那你在宿主机也是可以看到的，即 `/usr/local/docker/workspace`）\n\n本处选择的是执行shell，则表示本处配置的shell命令，是默认在jenkins容器中执行的，而不是在宿主机上。\n\n下拉选择执行 shell：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c2e1bd362944ff2aab0a62646bae53d~tplv-k3u1fbpfcp-watermark.image?)\n\n在执行shell的命令中输入以下命令，设置全局变量：\n```\nSERVER_NAME_1=video-book-backend\necho \"=========================>>>>>>>工作空间WORKSPACE的地址：$WORKSPACE \"\ncd $WORKSPACE\necho \"=========================>>>>>>>进入工作空间WORKSPACE，清除工作空间中原项目的工作空间$SERVER_NAME_1 \"\nrm -rf $SERVER_NAME_1\necho \"=========================>>>>>>>清除工作空间中原项目的工作空间$SERVER_NAME_1 ......成功success\"\n```\n注意：本处的SERVER_NAME_1=jenkins-docker-gitlab-springboot是配置项目的名称(和gitlab中的项目名保持一致)\n\n### Build(构建)\n\n我们是SpringBoot项目，所以用到maven，这里设置一下全局操作，clean项目，并打成jar包，所以这里输入：`clean package`\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a41ff4b5061f48f39de4738c6282ec78~tplv-k3u1fbpfcp-watermark.image?)\n\n### Post Steps(执行任务)\n\n只在jenkins构建成功后，才执行这一步。\n\n因为最后的构建成功的maven项目的jar包是以docker启动服务为目的，所以最后的docker操作，一定是在jenkins容器以外的服务器上运行的，可能是本机宿主机，也可能是远程的服务器，这个根据自己的情况去配置。\n\n本处选择，在远程的SSH执行shell脚本。\n\n选中只有构建成功才执行这些命令，然后选择Execute shell script on remote host using ssh。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c25a57ddb8f4b10b31e4832503d4af2~tplv-k3u1fbpfcp-watermark.image?)\n\nshell命令:\n```\n# =====================================================================================\n# =================================定义初始化变量======================================\n# =====================================================================================\n\n# 操作/项目路径(Dockerfile存放的路径，Dockerfile一般都放在项目的根目录下)\n# 如果Dockerfile放在项目根目录的子目录下，则子目录不能与项目同名\n# 会导致在复制jar包的时候，覆盖子目录为jar包,同时没有扩展名jar,原因我暂时不知道\n# 目前我的做法是将Dockerfile放在项目根目录下\nBASE_PATH=/usr/local/docker/jenkins/workspace/video-book-backend\n\n# jenkins构建好的源jar路径\n# 这个路径是jenkins容器挂载在宿主机上的路径\n# 我的jenkins的目录被我挂载在了/usr/local/docker/jenkins上\nSOURCE_PATH=/usr/local/docker/jenkins/workspace\n\n# docker镜像、docker容器、Dockerfile同目录下的jar名字[用它build生成image的jar]、jenkins的workspace下的项目名称\n# 注意统一名称！！！！！\nSERVER_NAME=video-book-backend\n\n# 容器id  [grep -w 全量匹配容器名] [awk 获取信息行的第一列，即容器ID]  [无论容器启动与否，都获取到]\nCID=$(docker ps -a | grep -w \"$SERVER_NAME\" | awk \'{print $1}\')\n\n# 镜像id  [grep -w 全量匹配镜像名] [awk 获取信息行的第三列，即镜像ID]\nIID=$(docker images | grep -w \"$SERVER_NAME\" | awk \'{print $3}\')\n\n# 源jar完整地址[jenkins构建成功后，会在自己的workspace/项目/target下生成maven构建成功的jar包，获取jar包名的完整路径]\n# 例如：/usr/local/docker/jenkins/workspace/video-book-backend/target/video-book-backend-0.0.1-SNAPSHOT.jar\nSOURCE_JAR_PATH=$(find \"$SOURCE_PATH/$SERVER_NAME/target/\"  -name \"*$SERVER_NAME*.jar\" )\n\nDATE=`date +%Y%m%d%H%M%S`\n\n# =====================================================================================\n# ============================对原本已存在的jar进行备份================================\n# =====================================================================================\n\n# 备份\nfunction backup(){\n    if [ -f \"$BASE_PATH/$SERVER_NAME.jar\" ]; then\n        echo \"=========================>>>>>>>$SERVER_NAME.jar 备份...\"\n            mv $BASE_PATH/$SERVER_NAME.jar $BASE_PATH/backup/$SERVER_NAME-$DATE.jar\n        echo \"=========================>>>>>>>备份老的 $SERVER_NAME.jar 完成\"\n\n    else\n        echo \"=========================>>>>>>>老的$BASE_PATH/$SERVER_NAME.jar不存在，跳过备份\"\n    fi\n}\n\n# =====================================================================================\n# =========================移动最新源jar包到Dockerfile所在目录=========================\n# =====================================================================================\n\n\n \n# 查找源jar文件名，进行重命名，最后将源文件移动到Dockerfile文件所在目录\nfunction transfer(){\n      \n    echo \"=========================>>>>>>>源文件完整地址为 $SOURCE_JAR_PATH\"\n\n    echo \"=========================>>>>>>>重命名源文件\"\n        mv $SOURCE_JAR_PATH  $SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar\n\n    echo \"=========================>>>>>>>最新构建代码 将$SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar 迁移至 $BASE_PATH\"\n        cp $SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar $BASE_PATH\n        \n    echo \"=========================>>>>>>>迁移完成Success\"\n\n}\n \n# =====================================================================================\n# ==================================构建最新镜像=======================================\n# =====================================================================================\n\n# 构建docker镜像\nfunction build(){\n    \n    # 无论镜像存在与否，都停止原容器服务，并移除原容器服务\n    echo \"=========================>>>>>>>停止$SERVER_NAME容器，CID=$CID\"\n    docker stop $CID\n\n    echo \"=========================>>>>>>>移除$SERVER_NAME容器，CID=$CID\"\n    docker rm $CID\n\n    # 无论如何，都去构建新的镜像\n    if [ -n \"$IID\" ]; then\n        echo \"=========================>>>>>>>存在$SERVER_NAME镜像，IID=$IID\"\n\n        echo \"=========================>>>>>>>移除老的$SERVER_NAME镜像，IID=$IID\"\n        \n        docker rmi $IID\n\n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，开始---->\"\n        \n        cd $BASE_PATH\n        docker build -t $SERVER_NAME .\n        \n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，完成---->\"\n\n    else\n        echo \"=========================>>>>>>>不存在$SERVER_NAME镜像，构建新的镜像，开始--->\"\n        \n        cd $BASE_PATH\n        docker build -t $SERVER_NAME .\n        \n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，结束--->\"\n    fi\n}\n \n\n# =====================================================================================\n# ==============================运行docker容器，启动服务===============================\n# =====================================================================================\n\n# 运行docker容器\nfunction run(){\n    backup\n    transfer\n    build\n\n    # 创建容器\n    docker run --name $SERVER_NAME -itd --net=host -v /etc/localtime:/etc/localtime:ro  -v /etc/timezone:/etc/timezone:ro  $SERVER_NAME \n\n}\n \n# 入口\nrun\n```\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e67ba6d7cf14d52b00009c09afc9349~tplv-k3u1fbpfcp-watermark.image?)\n\nOK，到这里基本的任务已经新建成功，至于后续的两个步骤，根据自己的需求自行配置，没有难度的。\n\n点击应用，保存。\n\n### 测试\n\n测试push事件触发自动化构建和部署，点击test下拉选择push events，出现HTTP 200表示OK了。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e85f532d1c2b4643996604347b945f51~tplv-k3u1fbpfcp-watermark.image?)\n\n回到Jenkins可以看到任务列表，查看构建信息等。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f954757d41324660ae01ff5de6afe17e~tplv-k3u1fbpfcp-watermark.image?)\n\n待Jenkins构建成功之后，在服务器上执行命令：`docker ps`，可以看到我们启动起来的 SpringBoot 容器：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8556de2ce136416ea36e817b661c2f80~tplv-k3u1fbpfcp-watermark.image?)\n\n## 邮件通知\n\n有时候团队合作，我们希望能通过邮件通知每一个开发者，项目是否构建成功。jenkins/jenkins:2.332.1默认安装了`# Email Extension Template`这个插件，还需要安装`Email Extension Template`这个插件\n\n系统管理->插件管理->可选插件->搜索`Email Extension Template`\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51c60941d3d3422e88db89b5188a3168~tplv-k3u1fbpfcp-watermark.image?)\n\n直接安装\n\n### 配置Email(Jenkins自带)\n\n#### 2.1 基础信息查询\n\n>找到所要配置邮箱的基础信息，这里以QQ邮箱为例\n\n1. 通过网页端QQ邮箱的设置进入到邮箱客户端设置页面\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f31038ef147f4c728540bc581f64d522~tplv-k3u1fbpfcp-watermark.image?)\n\n2. 找到邮箱的基础信息\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5694801b0ed74685a76cade6b358c5fc~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 2.2 Jenkins邮件通知配置\n\n在Jenkins：`系统管理->系统配置`中，最底部找到`邮件通知`，打开`高级`,注意到在配置的下方有个\"通过发送测试邮件测试配置\"，我们可以讲其勾选，填入邮箱地址，点击`Test configuration`来先测试一下邮件的发送。\n\n> 这边最好先保存一下再测试，否则出错，又得重配。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6420215d674647fb824854fd68a3efd6~tplv-k3u1fbpfcp-watermark.image?)\n\n如果报错如下：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8481f74294404047a2671bc8e2a3297e~tplv-k3u1fbpfcp-watermark.image?)\n\n这是因为我们还需要在设置`Jenkins Location`中配置`系统管理员邮件地址`，此地址要和`邮件通知`中的`用户名`一致\n\n### 配置Email(Extended E-mail Notification)\n\n>记得文章一开头提到的下载Extended插件，没错，Jenkins系统设置里还可以通过`Extended E-mail Notification`对邮件发送进行模板格式的自定义\n\n#### 3.1 基础信息配置\n\n基础信息配置与上述一致,唯一要注意的是这里需要重新生成一个授权码\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cb0934380904b098a035e54297946d4~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 3.2 模板格式配置\n\n接3.1配置继续。这里主要就是配置展示的模板格式，常用的格式化的参数有：\n```\n- $BUILD_STATUS – 构建结果\n- $PROJECT_NAME – 构建脚本名称\n- $BUILD_NUMBER – 构建脚本编号\n- $JOB_DESCRIPTION – 构建项目描述 \n- $CAUSE – 脚本启动原因\n- $BUILD_URL – 脚本构建详情URL地址\n```\n\n这里选择以HTML的格式展示，填入模板：\n```\n<!DOCTYPE html>    \n<html>    \n<head>    \n<meta charset=\"UTF-8\">    \n<title>${ENV, var=\"JOB_NAME\"}-第${BUILD_NUMBER}次构建日志</title>    \n</head>    \n    \n<body leftmargin=\"8\" marginwidth=\"0\" topmargin=\"8\" marginheight=\"4\"    \n    offset=\"0\">    \n    <table width=\"95%\" cellpadding=\"0\" cellspacing=\"0\"  style=\"font-size: 11pt; font-family: Tahoma, Arial, Helvetica, sans-serif\">    \n        <tr>    \n            本邮件由系统自动发出，无需回复！<br/>            \n            各位同事，大家好，以下为${PROJECT_NAME}项目构建信息</br> \n            <td><font color=\"#CC0000\">构建结果 - ${BUILD_STATUS}</font></td>   \n        </tr>    \n        <tr>    \n            <td><br />    \n            <b><font color=\"#0B610B\">构建信息</font></b>    \n            <hr size=\"2\" width=\"100%\" align=\"center\" /></td>    \n        </tr>    \n        <tr>    \n            <td>    \n                <ul>    \n                    <li>项目名称 ： ${PROJECT_NAME}</li>    \n                    <li>构建编号 ： 第${BUILD_NUMBER}次构建</li>    \n                    <li>触发原因： ${CAUSE}</li>    \n                    <li>构建状态： ${BUILD_STATUS}</li>    \n                    <li>构建日志： <a href=\"${BUILD_URL}console\">${BUILD_URL}console</a></li>    \n                    <li>构建  Url ： <a href=\"${BUILD_URL}\">${BUILD_URL}</a></li>    \n                    <li>工作目录 ： <a href=\"${PROJECT_URL}ws\">${PROJECT_URL}ws</a></li>    \n                    <li>项目  Url ： <a href=\"${PROJECT_URL}\">${PROJECT_URL}</a></li>    \n                </ul>    \n\n<h4><font color=\"#0B610B\">失败用例</font></h4>\n<hr size=\"2\" width=\"100%\" />\n$FAILED_TESTS<br/>\n\n<h4><font color=\"#0B610B\">最近提交(#$SVN_REVISION)</font></h4>\n<hr size=\"2\" width=\"100%\" />\n<ul>\n${CHANGES_SINCE_LAST_SUCCESS, reverse=true, format=\"%c\", changesFormat=\"<li>%d [%a] %m</li>\"}\n</ul>\n详细提交: <a href=\"${PROJECT_URL}changes\">${PROJECT_URL}changes</a><br/>\n\n            </td>    \n        </tr>    \n    </table>    \n</body>    \n</html>\n```\n\n如下图：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8b10b649f4943e1944fc094c72a3d2e~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 3.3 触发条件配置\n\n我们还可以在`Default Triggers`中根据自己的需要配置邮件的触发条件\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4328af1e2934c81b61f8c0429b6313b~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16835dfc64334f0e93a6cb7fd262922a~tplv-k3u1fbpfcp-watermark.image?)\n\n>这里为了防止因为构建一直尝试结果均为失败而造成的邮件轰炸，可以设置邮件仅第一次或第二次构建结果为失败时才发送邮件，后续失败的邮件将不再发送。我选择的是每一次失败和构建成功都会发邮件通知\n\n#### 3.4 jenkins的任务中配置邮件通知\n\n1. 在对应的任务中的构建设置中，勾选`E-mail Notification Recipients`\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/224fb406029d46d489cb6192848fdb6e~tplv-k3u1fbpfcp-watermark.image?)\n\n2. 在对应的任务中的构建后操作中，下拉选择`Editable Email Notification`\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1abc14189c874a818e5fe42a90371e43~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/594c71d3301544e48f6cc7468724b964~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b633844afb7a43e488cd3ab81d7c08a9~tplv-k3u1fbpfcp-watermark.image?)\n\n至此，jnekins的自动化构建的邮件通知已配置完成，在gitlab点击push event发起构建进行测试。\n\n发送成功的话，可看到如下图的提示：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a26d60de670c48ca991975dc2d20fa20~tplv-k3u1fbpfcp-watermark.image?)\n\n## 总结\n\n经过多款插件的安装配置，逐步掌握了如何上床Spring Boot项目到Gitlab中，并使用Jenkins自动构建任务，另外依托于Docker，让这一切变得更加方便，希望大家都多多思考，让机器自动干活，减少我们IT从业人员的重复、繁琐的工作量。\n\n\n', '小白学习gitlab+jenkins进行自动化构建(docker)之springboot项目', 0, 7, 2, 9, 0, '2023-06-09 16:56:30', '2023-06-09 16:56:30', 0);
INSERT INTO `tb_article` VALUES (13, '小白学习gitlab+jenkins进行自动化构建(docker)之springboot项目', '## 前言\ngitlab和jenkins的安装参考我的另外两篇博客：\n* gitlab安装：[小白搭建gitlab(docker)](https://juejin.cn/post/7032898607686778910)\n* jenkins安装：[小白学习搭建jenkins(docker)](https://juejin.cn/post/7032891246490157093/)\n\n## 在Jenkins上安装必要的插件\n所需插件：`Maven Integration`、`Pipeline Maven Integration`、`Gitlab`、`GitLab Authentication`、`SSH`、`Publish Over SSH`、`Docker`\n\n点击 Manage Jenkins（系统管理） ——> Manage Plugins（插件管理）\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5d15509337b44198064ba2bd41f221e~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Maven插件\n\n点击可选插件 ——> 过滤Maven Integration插件 ——> 勾选Maven Integration和Pipeline Maven Integration ——> 点击直接安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e496dbb12972454789d19546d660c88d~tplv-k3u1fbpfcp-watermark.image?)\n\n如图开始安装插件：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/134fef5f496c468b8dad342454c83b45~tplv-k3u1fbpfcp-watermark.image?)\n\n安装完成后，即可在插件管理下的已安装选项卡下看到刚刚已经安装的插件。\n\n#### 安装Gitlab插件\n\n点击可选插件 ——> 过滤Gitlab插件 ——> 勾选Gitlab和Gitlab Authentication ——> 点击直接安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6171674e55b428c9eba7be7cc2f516c~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装SSH插件和Publish Over SSH插件\n安装Publish Over SSH插件的原因：因为本方式是使用docker启动jenkins服务，所以在jenkins后续执行构建任务时候，需要在build成功后，将服务的jar包（以spring boot服务为例）拷贝到Dockerfile所在服务器的指定目录，进行微服务的启动；所以，此处需要配置SSH服务器的连接，意思就是在jenkins的任务结束后，去执行指定的服务器上的shell命令，做spring boot或cloud服务的镜像的构建，容器的运行，等一系列的事情。\n\n点击可选插件 ——> 过滤SSH插件 ——> 勾选SSH和Publish Over SSH ——> 点击直接安装\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d21ba2054860482b8b07684f48468538~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Docker插件\n\n点击可选插件 ——> 过滤Docker插件 ——> 勾选Docker ——> 点击直接安装\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1501abfe94b431a91e5692c41d12f72~tplv-k3u1fbpfcp-watermark.image?)\n\n插件全部安装完成后，可以重启一下Jenkins。\n\n## 相关配置\n\n#### 添加凭据\n\n点击 Manage Jenkins（系统管理） ——> Manage Credentials（凭据管理）\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0d3890020d34004adb05cab48310dd1~tplv-k3u1fbpfcp-watermark.image?)\n\n点击添加凭据 ——> 输入宿主机服务器的用户名和密码等信息并保存\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8eb6e5330d2140cb9705256fc722dc9d~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 配置SSH remote hosts\n\n这个配置是干什么的呢？配置SSH连接Dockerfile所在服务器的相关信息，并添加凭证，最后测试连接并保存，以备后面使用！！！\n\n点击 Manage Jenkins（系统管理） ——> 系统配置\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3813b66e9134305a1acb1d7515110bd~tplv-k3u1fbpfcp-watermark.image?)\n\n找到配置 ——> 下拉选择SSH remote hosts\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7436757a876049db93e6b255662001f2~tplv-k3u1fbpfcp-watermark.image?)\n\n如下图，输入对应的信息，并校验是否连接成功！成功后，点击应用 ——> 点击保存\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3559c64c918c4355aaff8d136e689da9~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 配置Publish over SSH\n\n找到配置 ——> 下拉选择Publish over SSH，进行相关配置即可。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0bb12f108302405ba90bb33e80fd0d5e~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78ad24f26a2a46b68ea44ea1c6ceb537~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de7ba1ca4a074ad1bb6f6a4b8fe71ee3~tplv-k3u1fbpfcp-watermark.image?)\n\n这里配置的数据，目前只能在Post Steps中选中send files or execute commands over ssh使用，要想能够在execute shell script on remote host using ssh方式中使用，需要再配置一份SSH remote hosts和它配套使用\n\n## 全局工具配置\n\n由于我们要实现的是SpringBoot项目的自动化部署操作，所以需要安装JDK、Git、Maven、Docker。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0dec279d6d44a83b2138cd7663e0995~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装JDK\n\n可以安装多个，根据项目JDK版本需求。\n\n输入自定义JDK名称 ——> 勾选自动安装 ——> 输入Oracle账户、密码 ——> 选择JDK版本 ——> 勾选同意协议\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72aa67fd5a494228840c5bef060e36b8~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Git\n\n输入自定义Git名称 ——> 勾选自动安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b49eb7bd11d48ab9ffce4f29431c216~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Maven\n\n输入自定义名称 ——> 勾选自动安装 ——> 选择版本\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5394195a98b647189dfaa5cd74b1a0b0~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Docker\n\n输入自定义名称 ——> 勾选自动安装\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/893704cbe8fe449fb615534bf9e82cea~tplv-k3u1fbpfcp-watermark.image?)\n\n最后，点击应用 ——> 点击保存即可。\n\n## 新建Jenkins任务\n\n### 点击新建任务，输入名称\n\n注意：本名称必须和项目名称一致，因为本名称会在jenkins工作空间下生成目录，类似于IDEA或Eclipse的工作空间的概念。所以，一般情况下，保证本名称=项目名称=docker镜像名称=docker容器名称 这样能尽可能的减轻jenkins配置的shell命令的复杂性！（空间命名要小写：因为镜像名不允许存在大写字母）\n\n选择构建一个Maven项目（因为是Spring Boot的服务）\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5a510bcf4ac49159f3f3b2960ae4fc5~tplv-k3u1fbpfcp-watermark.image?)\n\n### 源码管理\n\n输入描述信息，源码管理选择Git，从gitlab复制克隆地址（http协议的）粘贴到Repository URL中。未添加凭证会报授权失败的错误。错误如下：\n```\n![]()无法连接仓库：Command \"git ls-remote -h -- http://192.168.57.128:8880/root/video-book-backend.git HEAD\" returned status code 128:\\\nstdout:\\\nstderr: remote: HTTP Basic: Access denied\\\nfatal: Authentication failed for \'http://192.168.57.128:8880/root/video-book-backend.git/\'\n```\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94c2477c80724a959f8bb9f461814f41~tplv-k3u1fbpfcp-watermark.image?)\n\n添加gitlab凭证：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e08c1c343564fda9d5c599e985c38f5~tplv-k3u1fbpfcp-watermark.image?)\n\n### 构建触发器\n\n接下来将会生成供gitlab配置webhook使用的URL和Token，请记录下来，后面会使用。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1016fa1f35f24be7bf16ebe0a503bb8e~tplv-k3u1fbpfcp-watermark.image?)\n\n点击高级，拉下来找到Generate并点击，生成一串Secret Token。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13fb693d0ed14c63b8b613cccc7cd5b9~tplv-k3u1fbpfcp-watermark.image?)\n\n### 添加webhook\n\n前往gitlab，进入要构建的项目，在setting中选择Webhooks，输入URL和Secret Token 这两在上面图中已经给你标注了，去掉Enable SSL verification的勾选。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/904006704c604f6da4f2d1989200d462~tplv-k3u1fbpfcp-watermark.image?)\n\n点击Add webhook，如图表示成功添加了webhook：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6928c377f94748d0b70f57189e42e6cd~tplv-k3u1fbpfcp-watermark.image?)\n\n如果添加不成功解决方案请参考：[解决 Url is blocked: Requests to the local network are not allowed](https://www.cnblogs.com/zhongyuanzhao000/p/11379098.html)\n\n### 构建环境\n\n勾选Add timestamps to the Console Output，等下可以看到控制台打印的信息，这个根据自己的需求勾选。\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/badcdddabcc643b19f5a41fdc9f3416e~tplv-k3u1fbpfcp-watermark.image?)\n\n### Pre Steps(构建之前的步骤)\n\n配置前一步需要做的事情是：清理本项目在jenkins的workspace中的历史文件夹。\n\n你可以不用知道WORKSPACE具体的地址在哪里，因为下方有链接可以查看到当前jenkins中有哪些可用的变量供你使用。\n\n默认WORKSPACE地址：`/var/jenkins_home/workspace`（如果你jenkins是docker启动的，并且挂载了目录在宿主机，那你在宿主机也是可以看到的，即 `/usr/local/docker/workspace`）\n\n本处选择的是执行shell，则表示本处配置的shell命令，是默认在jenkins容器中执行的，而不是在宿主机上。\n\n下拉选择执行 shell：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c2e1bd362944ff2aab0a62646bae53d~tplv-k3u1fbpfcp-watermark.image?)\n\n在执行shell的命令中输入以下命令，设置全局变量：\n```\nSERVER_NAME_1=video-book-backend\necho \"=========================>>>>>>>工作空间WORKSPACE的地址：$WORKSPACE \"\ncd $WORKSPACE\necho \"=========================>>>>>>>进入工作空间WORKSPACE，清除工作空间中原项目的工作空间$SERVER_NAME_1 \"\nrm -rf $SERVER_NAME_1\necho \"=========================>>>>>>>清除工作空间中原项目的工作空间$SERVER_NAME_1 ......成功success\"\n```\n注意：本处的SERVER_NAME_1=jenkins-docker-gitlab-springboot是配置项目的名称(和gitlab中的项目名保持一致)\n\n### Build(构建)\n\n我们是SpringBoot项目，所以用到maven，这里设置一下全局操作，clean项目，并打成jar包，所以这里输入：`clean package`\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a41ff4b5061f48f39de4738c6282ec78~tplv-k3u1fbpfcp-watermark.image?)\n\n### Post Steps(执行任务)\n\n只在jenkins构建成功后，才执行这一步。\n\n因为最后的构建成功的maven项目的jar包是以docker启动服务为目的，所以最后的docker操作，一定是在jenkins容器以外的服务器上运行的，可能是本机宿主机，也可能是远程的服务器，这个根据自己的情况去配置。\n\n本处选择，在远程的SSH执行shell脚本。\n\n选中只有构建成功才执行这些命令，然后选择Execute shell script on remote host using ssh。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c25a57ddb8f4b10b31e4832503d4af2~tplv-k3u1fbpfcp-watermark.image?)\n\nshell命令:\n```\n# =====================================================================================\n# =================================定义初始化变量======================================\n# =====================================================================================\n\n# 操作/项目路径(Dockerfile存放的路径，Dockerfile一般都放在项目的根目录下)\n# 如果Dockerfile放在项目根目录的子目录下，则子目录不能与项目同名\n# 会导致在复制jar包的时候，覆盖子目录为jar包,同时没有扩展名jar,原因我暂时不知道\n# 目前我的做法是将Dockerfile放在项目根目录下\nBASE_PATH=/usr/local/docker/jenkins/workspace/video-book-backend\n\n# jenkins构建好的源jar路径\n# 这个路径是jenkins容器挂载在宿主机上的路径\n# 我的jenkins的目录被我挂载在了/usr/local/docker/jenkins上\nSOURCE_PATH=/usr/local/docker/jenkins/workspace\n\n# docker镜像、docker容器、Dockerfile同目录下的jar名字[用它build生成image的jar]、jenkins的workspace下的项目名称\n# 注意统一名称！！！！！\nSERVER_NAME=video-book-backend\n\n# 容器id  [grep -w 全量匹配容器名] [awk 获取信息行的第一列，即容器ID]  [无论容器启动与否，都获取到]\nCID=$(docker ps -a | grep -w \"$SERVER_NAME\" | awk \'{print $1}\')\n\n# 镜像id  [grep -w 全量匹配镜像名] [awk 获取信息行的第三列，即镜像ID]\nIID=$(docker images | grep -w \"$SERVER_NAME\" | awk \'{print $3}\')\n\n# 源jar完整地址[jenkins构建成功后，会在自己的workspace/项目/target下生成maven构建成功的jar包，获取jar包名的完整路径]\n# 例如：/usr/local/docker/jenkins/workspace/video-book-backend/target/video-book-backend-0.0.1-SNAPSHOT.jar\nSOURCE_JAR_PATH=$(find \"$SOURCE_PATH/$SERVER_NAME/target/\"  -name \"*$SERVER_NAME*.jar\" )\n\nDATE=`date +%Y%m%d%H%M%S`\n\n# =====================================================================================\n# ============================对原本已存在的jar进行备份================================\n# =====================================================================================\n\n# 备份\nfunction backup(){\n    if [ -f \"$BASE_PATH/$SERVER_NAME.jar\" ]; then\n        echo \"=========================>>>>>>>$SERVER_NAME.jar 备份...\"\n            mv $BASE_PATH/$SERVER_NAME.jar $BASE_PATH/backup/$SERVER_NAME-$DATE.jar\n        echo \"=========================>>>>>>>备份老的 $SERVER_NAME.jar 完成\"\n\n    else\n        echo \"=========================>>>>>>>老的$BASE_PATH/$SERVER_NAME.jar不存在，跳过备份\"\n    fi\n}\n\n# =====================================================================================\n# =========================移动最新源jar包到Dockerfile所在目录=========================\n# =====================================================================================\n\n\n \n# 查找源jar文件名，进行重命名，最后将源文件移动到Dockerfile文件所在目录\nfunction transfer(){\n      \n    echo \"=========================>>>>>>>源文件完整地址为 $SOURCE_JAR_PATH\"\n\n    echo \"=========================>>>>>>>重命名源文件\"\n        mv $SOURCE_JAR_PATH  $SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar\n\n    echo \"=========================>>>>>>>最新构建代码 将$SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar 迁移至 $BASE_PATH\"\n        cp $SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar $BASE_PATH\n        \n    echo \"=========================>>>>>>>迁移完成Success\"\n\n}\n \n# =====================================================================================\n# ==================================构建最新镜像=======================================\n# =====================================================================================\n\n# 构建docker镜像\nfunction build(){\n    \n    # 无论镜像存在与否，都停止原容器服务，并移除原容器服务\n    echo \"=========================>>>>>>>停止$SERVER_NAME容器，CID=$CID\"\n    docker stop $CID\n\n    echo \"=========================>>>>>>>移除$SERVER_NAME容器，CID=$CID\"\n    docker rm $CID\n\n    # 无论如何，都去构建新的镜像\n    if [ -n \"$IID\" ]; then\n        echo \"=========================>>>>>>>存在$SERVER_NAME镜像，IID=$IID\"\n\n        echo \"=========================>>>>>>>移除老的$SERVER_NAME镜像，IID=$IID\"\n        \n        docker rmi $IID\n\n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，开始---->\"\n        \n        cd $BASE_PATH\n        docker build -t $SERVER_NAME .\n        \n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，完成---->\"\n\n    else\n        echo \"=========================>>>>>>>不存在$SERVER_NAME镜像，构建新的镜像，开始--->\"\n        \n        cd $BASE_PATH\n        docker build -t $SERVER_NAME .\n        \n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，结束--->\"\n    fi\n}\n \n\n# =====================================================================================\n# ==============================运行docker容器，启动服务===============================\n# =====================================================================================\n\n# 运行docker容器\nfunction run(){\n    backup\n    transfer\n    build\n\n    # 创建容器\n    docker run --name $SERVER_NAME -itd --net=host -v /etc/localtime:/etc/localtime:ro  -v /etc/timezone:/etc/timezone:ro  $SERVER_NAME \n\n}\n \n# 入口\nrun\n```\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e67ba6d7cf14d52b00009c09afc9349~tplv-k3u1fbpfcp-watermark.image?)\n\nOK，到这里基本的任务已经新建成功，至于后续的两个步骤，根据自己的需求自行配置，没有难度的。\n\n点击应用，保存。\n\n### 测试\n\n测试push事件触发自动化构建和部署，点击test下拉选择push events，出现HTTP 200表示OK了。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e85f532d1c2b4643996604347b945f51~tplv-k3u1fbpfcp-watermark.image?)\n\n回到Jenkins可以看到任务列表，查看构建信息等。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f954757d41324660ae01ff5de6afe17e~tplv-k3u1fbpfcp-watermark.image?)\n\n待Jenkins构建成功之后，在服务器上执行命令：`docker ps`，可以看到我们启动起来的 SpringBoot 容器：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8556de2ce136416ea36e817b661c2f80~tplv-k3u1fbpfcp-watermark.image?)\n\n## 邮件通知\n\n有时候团队合作，我们希望能通过邮件通知每一个开发者，项目是否构建成功。jenkins/jenkins:2.332.1默认安装了`# Email Extension Template`这个插件，还需要安装`Email Extension Template`这个插件\n\n系统管理->插件管理->可选插件->搜索`Email Extension Template`\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51c60941d3d3422e88db89b5188a3168~tplv-k3u1fbpfcp-watermark.image?)\n\n直接安装\n\n### 配置Email(Jenkins自带)\n\n#### 2.1 基础信息查询\n\n>找到所要配置邮箱的基础信息，这里以QQ邮箱为例\n\n1. 通过网页端QQ邮箱的设置进入到邮箱客户端设置页面\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f31038ef147f4c728540bc581f64d522~tplv-k3u1fbpfcp-watermark.image?)\n\n2. 找到邮箱的基础信息\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5694801b0ed74685a76cade6b358c5fc~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 2.2 Jenkins邮件通知配置\n\n在Jenkins：`系统管理->系统配置`中，最底部找到`邮件通知`，打开`高级`,注意到在配置的下方有个\"通过发送测试邮件测试配置\"，我们可以讲其勾选，填入邮箱地址，点击`Test configuration`来先测试一下邮件的发送。\n\n> 这边最好先保存一下再测试，否则出错，又得重配。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6420215d674647fb824854fd68a3efd6~tplv-k3u1fbpfcp-watermark.image?)\n\n如果报错如下：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8481f74294404047a2671bc8e2a3297e~tplv-k3u1fbpfcp-watermark.image?)\n\n这是因为我们还需要在设置`Jenkins Location`中配置`系统管理员邮件地址`，此地址要和`邮件通知`中的`用户名`一致\n\n### 配置Email(Extended E-mail Notification)\n\n>记得文章一开头提到的下载Extended插件，没错，Jenkins系统设置里还可以通过`Extended E-mail Notification`对邮件发送进行模板格式的自定义\n\n#### 3.1 基础信息配置\n\n基础信息配置与上述一致,唯一要注意的是这里需要重新生成一个授权码\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cb0934380904b098a035e54297946d4~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 3.2 模板格式配置\n\n接3.1配置继续。这里主要就是配置展示的模板格式，常用的格式化的参数有：\n```\n- $BUILD_STATUS – 构建结果\n- $PROJECT_NAME – 构建脚本名称\n- $BUILD_NUMBER – 构建脚本编号\n- $JOB_DESCRIPTION – 构建项目描述 \n- $CAUSE – 脚本启动原因\n- $BUILD_URL – 脚本构建详情URL地址\n```\n\n这里选择以HTML的格式展示，填入模板：\n```\n<!DOCTYPE html>    \n<html>    \n<head>    \n<meta charset=\"UTF-8\">    \n<title>${ENV, var=\"JOB_NAME\"}-第${BUILD_NUMBER}次构建日志</title>    \n</head>    \n    \n<body leftmargin=\"8\" marginwidth=\"0\" topmargin=\"8\" marginheight=\"4\"    \n    offset=\"0\">    \n    <table width=\"95%\" cellpadding=\"0\" cellspacing=\"0\"  style=\"font-size: 11pt; font-family: Tahoma, Arial, Helvetica, sans-serif\">    \n        <tr>    \n            本邮件由系统自动发出，无需回复！<br/>            \n            各位同事，大家好，以下为${PROJECT_NAME}项目构建信息</br> \n            <td><font color=\"#CC0000\">构建结果 - ${BUILD_STATUS}</font></td>   \n        </tr>    \n        <tr>    \n            <td><br />    \n            <b><font color=\"#0B610B\">构建信息</font></b>    \n            <hr size=\"2\" width=\"100%\" align=\"center\" /></td>    \n        </tr>    \n        <tr>    \n            <td>    \n                <ul>    \n                    <li>项目名称 ： ${PROJECT_NAME}</li>    \n                    <li>构建编号 ： 第${BUILD_NUMBER}次构建</li>    \n                    <li>触发原因： ${CAUSE}</li>    \n                    <li>构建状态： ${BUILD_STATUS}</li>    \n                    <li>构建日志： <a href=\"${BUILD_URL}console\">${BUILD_URL}console</a></li>    \n                    <li>构建  Url ： <a href=\"${BUILD_URL}\">${BUILD_URL}</a></li>    \n                    <li>工作目录 ： <a href=\"${PROJECT_URL}ws\">${PROJECT_URL}ws</a></li>    \n                    <li>项目  Url ： <a href=\"${PROJECT_URL}\">${PROJECT_URL}</a></li>    \n                </ul>    \n\n<h4><font color=\"#0B610B\">失败用例</font></h4>\n<hr size=\"2\" width=\"100%\" />\n$FAILED_TESTS<br/>\n\n<h4><font color=\"#0B610B\">最近提交(#$SVN_REVISION)</font></h4>\n<hr size=\"2\" width=\"100%\" />\n<ul>\n${CHANGES_SINCE_LAST_SUCCESS, reverse=true, format=\"%c\", changesFormat=\"<li>%d [%a] %m</li>\"}\n</ul>\n详细提交: <a href=\"${PROJECT_URL}changes\">${PROJECT_URL}changes</a><br/>\n\n            </td>    \n        </tr>    \n    </table>    \n</body>    \n</html>\n```\n\n如下图：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8b10b649f4943e1944fc094c72a3d2e~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 3.3 触发条件配置\n\n我们还可以在`Default Triggers`中根据自己的需要配置邮件的触发条件\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4328af1e2934c81b61f8c0429b6313b~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16835dfc64334f0e93a6cb7fd262922a~tplv-k3u1fbpfcp-watermark.image?)\n\n>这里为了防止因为构建一直尝试结果均为失败而造成的邮件轰炸，可以设置邮件仅第一次或第二次构建结果为失败时才发送邮件，后续失败的邮件将不再发送。我选择的是每一次失败和构建成功都会发邮件通知\n\n#### 3.4 jenkins的任务中配置邮件通知\n\n1. 在对应的任务中的构建设置中，勾选`E-mail Notification Recipients`\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/224fb406029d46d489cb6192848fdb6e~tplv-k3u1fbpfcp-watermark.image?)\n\n2. 在对应的任务中的构建后操作中，下拉选择`Editable Email Notification`\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1abc14189c874a818e5fe42a90371e43~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/594c71d3301544e48f6cc7468724b964~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b633844afb7a43e488cd3ab81d7c08a9~tplv-k3u1fbpfcp-watermark.image?)\n\n至此，jnekins的自动化构建的邮件通知已配置完成，在gitlab点击push event发起构建进行测试。\n\n发送成功的话，可看到如下图的提示：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a26d60de670c48ca991975dc2d20fa20~tplv-k3u1fbpfcp-watermark.image?)\n\n## 总结\n\n经过多款插件的安装配置，逐步掌握了如何上床Spring Boot项目到Gitlab中，并使用Jenkins自动构建任务，另外依托于Docker，让这一切变得更加方便，希望大家都多多思考，让机器自动干活，减少我们IT从业人员的重复、繁琐的工作量。\n\n\n', '小白学习gitlab+jenkins进行自动化构建(docker)之springboot项目', 0, 7, 2, 9, 0, '2023-06-09 16:56:30', '2023-06-09 16:56:30', 0);
INSERT INTO `tb_article` VALUES (14, '小白学习gitlab+jenkins进行自动化构建(docker)之springboot项目', '## 前言\ngitlab和jenkins的安装参考我的另外两篇博客：\n* gitlab安装：[小白搭建gitlab(docker)](https://juejin.cn/post/7032898607686778910)\n* jenkins安装：[小白学习搭建jenkins(docker)](https://juejin.cn/post/7032891246490157093/)\n\n## 在Jenkins上安装必要的插件\n所需插件：`Maven Integration`、`Pipeline Maven Integration`、`Gitlab`、`GitLab Authentication`、`SSH`、`Publish Over SSH`、`Docker`\n\n点击 Manage Jenkins（系统管理） ——> Manage Plugins（插件管理）\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5d15509337b44198064ba2bd41f221e~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Maven插件\n\n点击可选插件 ——> 过滤Maven Integration插件 ——> 勾选Maven Integration和Pipeline Maven Integration ——> 点击直接安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e496dbb12972454789d19546d660c88d~tplv-k3u1fbpfcp-watermark.image?)\n\n如图开始安装插件：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/134fef5f496c468b8dad342454c83b45~tplv-k3u1fbpfcp-watermark.image?)\n\n安装完成后，即可在插件管理下的已安装选项卡下看到刚刚已经安装的插件。\n\n#### 安装Gitlab插件\n\n点击可选插件 ——> 过滤Gitlab插件 ——> 勾选Gitlab和Gitlab Authentication ——> 点击直接安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6171674e55b428c9eba7be7cc2f516c~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装SSH插件和Publish Over SSH插件\n安装Publish Over SSH插件的原因：因为本方式是使用docker启动jenkins服务，所以在jenkins后续执行构建任务时候，需要在build成功后，将服务的jar包（以spring boot服务为例）拷贝到Dockerfile所在服务器的指定目录，进行微服务的启动；所以，此处需要配置SSH服务器的连接，意思就是在jenkins的任务结束后，去执行指定的服务器上的shell命令，做spring boot或cloud服务的镜像的构建，容器的运行，等一系列的事情。\n\n点击可选插件 ——> 过滤SSH插件 ——> 勾选SSH和Publish Over SSH ——> 点击直接安装\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d21ba2054860482b8b07684f48468538~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Docker插件\n\n点击可选插件 ——> 过滤Docker插件 ——> 勾选Docker ——> 点击直接安装\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1501abfe94b431a91e5692c41d12f72~tplv-k3u1fbpfcp-watermark.image?)\n\n插件全部安装完成后，可以重启一下Jenkins。\n\n## 相关配置\n\n#### 添加凭据\n\n点击 Manage Jenkins（系统管理） ——> Manage Credentials（凭据管理）\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0d3890020d34004adb05cab48310dd1~tplv-k3u1fbpfcp-watermark.image?)\n\n点击添加凭据 ——> 输入宿主机服务器的用户名和密码等信息并保存\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8eb6e5330d2140cb9705256fc722dc9d~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 配置SSH remote hosts\n\n这个配置是干什么的呢？配置SSH连接Dockerfile所在服务器的相关信息，并添加凭证，最后测试连接并保存，以备后面使用！！！\n\n点击 Manage Jenkins（系统管理） ——> 系统配置\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3813b66e9134305a1acb1d7515110bd~tplv-k3u1fbpfcp-watermark.image?)\n\n找到配置 ——> 下拉选择SSH remote hosts\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7436757a876049db93e6b255662001f2~tplv-k3u1fbpfcp-watermark.image?)\n\n如下图，输入对应的信息，并校验是否连接成功！成功后，点击应用 ——> 点击保存\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3559c64c918c4355aaff8d136e689da9~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 配置Publish over SSH\n\n找到配置 ——> 下拉选择Publish over SSH，进行相关配置即可。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0bb12f108302405ba90bb33e80fd0d5e~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78ad24f26a2a46b68ea44ea1c6ceb537~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de7ba1ca4a074ad1bb6f6a4b8fe71ee3~tplv-k3u1fbpfcp-watermark.image?)\n\n这里配置的数据，目前只能在Post Steps中选中send files or execute commands over ssh使用，要想能够在execute shell script on remote host using ssh方式中使用，需要再配置一份SSH remote hosts和它配套使用\n\n## 全局工具配置\n\n由于我们要实现的是SpringBoot项目的自动化部署操作，所以需要安装JDK、Git、Maven、Docker。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0dec279d6d44a83b2138cd7663e0995~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装JDK\n\n可以安装多个，根据项目JDK版本需求。\n\n输入自定义JDK名称 ——> 勾选自动安装 ——> 输入Oracle账户、密码 ——> 选择JDK版本 ——> 勾选同意协议\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72aa67fd5a494228840c5bef060e36b8~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Git\n\n输入自定义Git名称 ——> 勾选自动安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b49eb7bd11d48ab9ffce4f29431c216~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Maven\n\n输入自定义名称 ——> 勾选自动安装 ——> 选择版本\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5394195a98b647189dfaa5cd74b1a0b0~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Docker\n\n输入自定义名称 ——> 勾选自动安装\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/893704cbe8fe449fb615534bf9e82cea~tplv-k3u1fbpfcp-watermark.image?)\n\n最后，点击应用 ——> 点击保存即可。\n\n## 新建Jenkins任务\n\n### 点击新建任务，输入名称\n\n注意：本名称必须和项目名称一致，因为本名称会在jenkins工作空间下生成目录，类似于IDEA或Eclipse的工作空间的概念。所以，一般情况下，保证本名称=项目名称=docker镜像名称=docker容器名称 这样能尽可能的减轻jenkins配置的shell命令的复杂性！（空间命名要小写：因为镜像名不允许存在大写字母）\n\n选择构建一个Maven项目（因为是Spring Boot的服务）\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5a510bcf4ac49159f3f3b2960ae4fc5~tplv-k3u1fbpfcp-watermark.image?)\n\n### 源码管理\n\n输入描述信息，源码管理选择Git，从gitlab复制克隆地址（http协议的）粘贴到Repository URL中。未添加凭证会报授权失败的错误。错误如下：\n```\n![]()无法连接仓库：Command \"git ls-remote -h -- http://192.168.57.128:8880/root/video-book-backend.git HEAD\" returned status code 128:\\\nstdout:\\\nstderr: remote: HTTP Basic: Access denied\\\nfatal: Authentication failed for \'http://192.168.57.128:8880/root/video-book-backend.git/\'\n```\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94c2477c80724a959f8bb9f461814f41~tplv-k3u1fbpfcp-watermark.image?)\n\n添加gitlab凭证：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e08c1c343564fda9d5c599e985c38f5~tplv-k3u1fbpfcp-watermark.image?)\n\n### 构建触发器\n\n接下来将会生成供gitlab配置webhook使用的URL和Token，请记录下来，后面会使用。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1016fa1f35f24be7bf16ebe0a503bb8e~tplv-k3u1fbpfcp-watermark.image?)\n\n点击高级，拉下来找到Generate并点击，生成一串Secret Token。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13fb693d0ed14c63b8b613cccc7cd5b9~tplv-k3u1fbpfcp-watermark.image?)\n\n### 添加webhook\n\n前往gitlab，进入要构建的项目，在setting中选择Webhooks，输入URL和Secret Token 这两在上面图中已经给你标注了，去掉Enable SSL verification的勾选。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/904006704c604f6da4f2d1989200d462~tplv-k3u1fbpfcp-watermark.image?)\n\n点击Add webhook，如图表示成功添加了webhook：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6928c377f94748d0b70f57189e42e6cd~tplv-k3u1fbpfcp-watermark.image?)\n\n如果添加不成功解决方案请参考：[解决 Url is blocked: Requests to the local network are not allowed](https://www.cnblogs.com/zhongyuanzhao000/p/11379098.html)\n\n### 构建环境\n\n勾选Add timestamps to the Console Output，等下可以看到控制台打印的信息，这个根据自己的需求勾选。\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/badcdddabcc643b19f5a41fdc9f3416e~tplv-k3u1fbpfcp-watermark.image?)\n\n### Pre Steps(构建之前的步骤)\n\n配置前一步需要做的事情是：清理本项目在jenkins的workspace中的历史文件夹。\n\n你可以不用知道WORKSPACE具体的地址在哪里，因为下方有链接可以查看到当前jenkins中有哪些可用的变量供你使用。\n\n默认WORKSPACE地址：`/var/jenkins_home/workspace`（如果你jenkins是docker启动的，并且挂载了目录在宿主机，那你在宿主机也是可以看到的，即 `/usr/local/docker/workspace`）\n\n本处选择的是执行shell，则表示本处配置的shell命令，是默认在jenkins容器中执行的，而不是在宿主机上。\n\n下拉选择执行 shell：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c2e1bd362944ff2aab0a62646bae53d~tplv-k3u1fbpfcp-watermark.image?)\n\n在执行shell的命令中输入以下命令，设置全局变量：\n```\nSERVER_NAME_1=video-book-backend\necho \"=========================>>>>>>>工作空间WORKSPACE的地址：$WORKSPACE \"\ncd $WORKSPACE\necho \"=========================>>>>>>>进入工作空间WORKSPACE，清除工作空间中原项目的工作空间$SERVER_NAME_1 \"\nrm -rf $SERVER_NAME_1\necho \"=========================>>>>>>>清除工作空间中原项目的工作空间$SERVER_NAME_1 ......成功success\"\n```\n注意：本处的SERVER_NAME_1=jenkins-docker-gitlab-springboot是配置项目的名称(和gitlab中的项目名保持一致)\n\n### Build(构建)\n\n我们是SpringBoot项目，所以用到maven，这里设置一下全局操作，clean项目，并打成jar包，所以这里输入：`clean package`\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a41ff4b5061f48f39de4738c6282ec78~tplv-k3u1fbpfcp-watermark.image?)\n\n### Post Steps(执行任务)\n\n只在jenkins构建成功后，才执行这一步。\n\n因为最后的构建成功的maven项目的jar包是以docker启动服务为目的，所以最后的docker操作，一定是在jenkins容器以外的服务器上运行的，可能是本机宿主机，也可能是远程的服务器，这个根据自己的情况去配置。\n\n本处选择，在远程的SSH执行shell脚本。\n\n选中只有构建成功才执行这些命令，然后选择Execute shell script on remote host using ssh。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c25a57ddb8f4b10b31e4832503d4af2~tplv-k3u1fbpfcp-watermark.image?)\n\nshell命令:\n```\n# =====================================================================================\n# =================================定义初始化变量======================================\n# =====================================================================================\n\n# 操作/项目路径(Dockerfile存放的路径，Dockerfile一般都放在项目的根目录下)\n# 如果Dockerfile放在项目根目录的子目录下，则子目录不能与项目同名\n# 会导致在复制jar包的时候，覆盖子目录为jar包,同时没有扩展名jar,原因我暂时不知道\n# 目前我的做法是将Dockerfile放在项目根目录下\nBASE_PATH=/usr/local/docker/jenkins/workspace/video-book-backend\n\n# jenkins构建好的源jar路径\n# 这个路径是jenkins容器挂载在宿主机上的路径\n# 我的jenkins的目录被我挂载在了/usr/local/docker/jenkins上\nSOURCE_PATH=/usr/local/docker/jenkins/workspace\n\n# docker镜像、docker容器、Dockerfile同目录下的jar名字[用它build生成image的jar]、jenkins的workspace下的项目名称\n# 注意统一名称！！！！！\nSERVER_NAME=video-book-backend\n\n# 容器id  [grep -w 全量匹配容器名] [awk 获取信息行的第一列，即容器ID]  [无论容器启动与否，都获取到]\nCID=$(docker ps -a | grep -w \"$SERVER_NAME\" | awk \'{print $1}\')\n\n# 镜像id  [grep -w 全量匹配镜像名] [awk 获取信息行的第三列，即镜像ID]\nIID=$(docker images | grep -w \"$SERVER_NAME\" | awk \'{print $3}\')\n\n# 源jar完整地址[jenkins构建成功后，会在自己的workspace/项目/target下生成maven构建成功的jar包，获取jar包名的完整路径]\n# 例如：/usr/local/docker/jenkins/workspace/video-book-backend/target/video-book-backend-0.0.1-SNAPSHOT.jar\nSOURCE_JAR_PATH=$(find \"$SOURCE_PATH/$SERVER_NAME/target/\"  -name \"*$SERVER_NAME*.jar\" )\n\nDATE=`date +%Y%m%d%H%M%S`\n\n# =====================================================================================\n# ============================对原本已存在的jar进行备份================================\n# =====================================================================================\n\n# 备份\nfunction backup(){\n    if [ -f \"$BASE_PATH/$SERVER_NAME.jar\" ]; then\n        echo \"=========================>>>>>>>$SERVER_NAME.jar 备份...\"\n            mv $BASE_PATH/$SERVER_NAME.jar $BASE_PATH/backup/$SERVER_NAME-$DATE.jar\n        echo \"=========================>>>>>>>备份老的 $SERVER_NAME.jar 完成\"\n\n    else\n        echo \"=========================>>>>>>>老的$BASE_PATH/$SERVER_NAME.jar不存在，跳过备份\"\n    fi\n}\n\n# =====================================================================================\n# =========================移动最新源jar包到Dockerfile所在目录=========================\n# =====================================================================================\n\n\n \n# 查找源jar文件名，进行重命名，最后将源文件移动到Dockerfile文件所在目录\nfunction transfer(){\n      \n    echo \"=========================>>>>>>>源文件完整地址为 $SOURCE_JAR_PATH\"\n\n    echo \"=========================>>>>>>>重命名源文件\"\n        mv $SOURCE_JAR_PATH  $SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar\n\n    echo \"=========================>>>>>>>最新构建代码 将$SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar 迁移至 $BASE_PATH\"\n        cp $SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar $BASE_PATH\n        \n    echo \"=========================>>>>>>>迁移完成Success\"\n\n}\n \n# =====================================================================================\n# ==================================构建最新镜像=======================================\n# =====================================================================================\n\n# 构建docker镜像\nfunction build(){\n    \n    # 无论镜像存在与否，都停止原容器服务，并移除原容器服务\n    echo \"=========================>>>>>>>停止$SERVER_NAME容器，CID=$CID\"\n    docker stop $CID\n\n    echo \"=========================>>>>>>>移除$SERVER_NAME容器，CID=$CID\"\n    docker rm $CID\n\n    # 无论如何，都去构建新的镜像\n    if [ -n \"$IID\" ]; then\n        echo \"=========================>>>>>>>存在$SERVER_NAME镜像，IID=$IID\"\n\n        echo \"=========================>>>>>>>移除老的$SERVER_NAME镜像，IID=$IID\"\n        \n        docker rmi $IID\n\n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，开始---->\"\n        \n        cd $BASE_PATH\n        docker build -t $SERVER_NAME .\n        \n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，完成---->\"\n\n    else\n        echo \"=========================>>>>>>>不存在$SERVER_NAME镜像，构建新的镜像，开始--->\"\n        \n        cd $BASE_PATH\n        docker build -t $SERVER_NAME .\n        \n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，结束--->\"\n    fi\n}\n \n\n# =====================================================================================\n# ==============================运行docker容器，启动服务===============================\n# =====================================================================================\n\n# 运行docker容器\nfunction run(){\n    backup\n    transfer\n    build\n\n    # 创建容器\n    docker run --name $SERVER_NAME -itd --net=host -v /etc/localtime:/etc/localtime:ro  -v /etc/timezone:/etc/timezone:ro  $SERVER_NAME \n\n}\n \n# 入口\nrun\n```\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e67ba6d7cf14d52b00009c09afc9349~tplv-k3u1fbpfcp-watermark.image?)\n\nOK，到这里基本的任务已经新建成功，至于后续的两个步骤，根据自己的需求自行配置，没有难度的。\n\n点击应用，保存。\n\n### 测试\n\n测试push事件触发自动化构建和部署，点击test下拉选择push events，出现HTTP 200表示OK了。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e85f532d1c2b4643996604347b945f51~tplv-k3u1fbpfcp-watermark.image?)\n\n回到Jenkins可以看到任务列表，查看构建信息等。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f954757d41324660ae01ff5de6afe17e~tplv-k3u1fbpfcp-watermark.image?)\n\n待Jenkins构建成功之后，在服务器上执行命令：`docker ps`，可以看到我们启动起来的 SpringBoot 容器：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8556de2ce136416ea36e817b661c2f80~tplv-k3u1fbpfcp-watermark.image?)\n\n## 邮件通知\n\n有时候团队合作，我们希望能通过邮件通知每一个开发者，项目是否构建成功。jenkins/jenkins:2.332.1默认安装了`# Email Extension Template`这个插件，还需要安装`Email Extension Template`这个插件\n\n系统管理->插件管理->可选插件->搜索`Email Extension Template`\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51c60941d3d3422e88db89b5188a3168~tplv-k3u1fbpfcp-watermark.image?)\n\n直接安装\n\n### 配置Email(Jenkins自带)\n\n#### 2.1 基础信息查询\n\n>找到所要配置邮箱的基础信息，这里以QQ邮箱为例\n\n1. 通过网页端QQ邮箱的设置进入到邮箱客户端设置页面\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f31038ef147f4c728540bc581f64d522~tplv-k3u1fbpfcp-watermark.image?)\n\n2. 找到邮箱的基础信息\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5694801b0ed74685a76cade6b358c5fc~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 2.2 Jenkins邮件通知配置\n\n在Jenkins：`系统管理->系统配置`中，最底部找到`邮件通知`，打开`高级`,注意到在配置的下方有个\"通过发送测试邮件测试配置\"，我们可以讲其勾选，填入邮箱地址，点击`Test configuration`来先测试一下邮件的发送。\n\n> 这边最好先保存一下再测试，否则出错，又得重配。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6420215d674647fb824854fd68a3efd6~tplv-k3u1fbpfcp-watermark.image?)\n\n如果报错如下：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8481f74294404047a2671bc8e2a3297e~tplv-k3u1fbpfcp-watermark.image?)\n\n这是因为我们还需要在设置`Jenkins Location`中配置`系统管理员邮件地址`，此地址要和`邮件通知`中的`用户名`一致\n\n### 配置Email(Extended E-mail Notification)\n\n>记得文章一开头提到的下载Extended插件，没错，Jenkins系统设置里还可以通过`Extended E-mail Notification`对邮件发送进行模板格式的自定义\n\n#### 3.1 基础信息配置\n\n基础信息配置与上述一致,唯一要注意的是这里需要重新生成一个授权码\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cb0934380904b098a035e54297946d4~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 3.2 模板格式配置\n\n接3.1配置继续。这里主要就是配置展示的模板格式，常用的格式化的参数有：\n```\n- $BUILD_STATUS – 构建结果\n- $PROJECT_NAME – 构建脚本名称\n- $BUILD_NUMBER – 构建脚本编号\n- $JOB_DESCRIPTION – 构建项目描述 \n- $CAUSE – 脚本启动原因\n- $BUILD_URL – 脚本构建详情URL地址\n```\n\n这里选择以HTML的格式展示，填入模板：\n```\n<!DOCTYPE html>    \n<html>    \n<head>    \n<meta charset=\"UTF-8\">    \n<title>${ENV, var=\"JOB_NAME\"}-第${BUILD_NUMBER}次构建日志</title>    \n</head>    \n    \n<body leftmargin=\"8\" marginwidth=\"0\" topmargin=\"8\" marginheight=\"4\"    \n    offset=\"0\">    \n    <table width=\"95%\" cellpadding=\"0\" cellspacing=\"0\"  style=\"font-size: 11pt; font-family: Tahoma, Arial, Helvetica, sans-serif\">    \n        <tr>    \n            本邮件由系统自动发出，无需回复！<br/>            \n            各位同事，大家好，以下为${PROJECT_NAME}项目构建信息</br> \n            <td><font color=\"#CC0000\">构建结果 - ${BUILD_STATUS}</font></td>   \n        </tr>    \n        <tr>    \n            <td><br />    \n            <b><font color=\"#0B610B\">构建信息</font></b>    \n            <hr size=\"2\" width=\"100%\" align=\"center\" /></td>    \n        </tr>    \n        <tr>    \n            <td>    \n                <ul>    \n                    <li>项目名称 ： ${PROJECT_NAME}</li>    \n                    <li>构建编号 ： 第${BUILD_NUMBER}次构建</li>    \n                    <li>触发原因： ${CAUSE}</li>    \n                    <li>构建状态： ${BUILD_STATUS}</li>    \n                    <li>构建日志： <a href=\"${BUILD_URL}console\">${BUILD_URL}console</a></li>    \n                    <li>构建  Url ： <a href=\"${BUILD_URL}\">${BUILD_URL}</a></li>    \n                    <li>工作目录 ： <a href=\"${PROJECT_URL}ws\">${PROJECT_URL}ws</a></li>    \n                    <li>项目  Url ： <a href=\"${PROJECT_URL}\">${PROJECT_URL}</a></li>    \n                </ul>    \n\n<h4><font color=\"#0B610B\">失败用例</font></h4>\n<hr size=\"2\" width=\"100%\" />\n$FAILED_TESTS<br/>\n\n<h4><font color=\"#0B610B\">最近提交(#$SVN_REVISION)</font></h4>\n<hr size=\"2\" width=\"100%\" />\n<ul>\n${CHANGES_SINCE_LAST_SUCCESS, reverse=true, format=\"%c\", changesFormat=\"<li>%d [%a] %m</li>\"}\n</ul>\n详细提交: <a href=\"${PROJECT_URL}changes\">${PROJECT_URL}changes</a><br/>\n\n            </td>    \n        </tr>    \n    </table>    \n</body>    \n</html>\n```\n\n如下图：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8b10b649f4943e1944fc094c72a3d2e~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 3.3 触发条件配置\n\n我们还可以在`Default Triggers`中根据自己的需要配置邮件的触发条件\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4328af1e2934c81b61f8c0429b6313b~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16835dfc64334f0e93a6cb7fd262922a~tplv-k3u1fbpfcp-watermark.image?)\n\n>这里为了防止因为构建一直尝试结果均为失败而造成的邮件轰炸，可以设置邮件仅第一次或第二次构建结果为失败时才发送邮件，后续失败的邮件将不再发送。我选择的是每一次失败和构建成功都会发邮件通知\n\n#### 3.4 jenkins的任务中配置邮件通知\n\n1. 在对应的任务中的构建设置中，勾选`E-mail Notification Recipients`\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/224fb406029d46d489cb6192848fdb6e~tplv-k3u1fbpfcp-watermark.image?)\n\n2. 在对应的任务中的构建后操作中，下拉选择`Editable Email Notification`\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1abc14189c874a818e5fe42a90371e43~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/594c71d3301544e48f6cc7468724b964~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b633844afb7a43e488cd3ab81d7c08a9~tplv-k3u1fbpfcp-watermark.image?)\n\n至此，jnekins的自动化构建的邮件通知已配置完成，在gitlab点击push event发起构建进行测试。\n\n发送成功的话，可看到如下图的提示：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a26d60de670c48ca991975dc2d20fa20~tplv-k3u1fbpfcp-watermark.image?)\n\n## 总结\n\n经过多款插件的安装配置，逐步掌握了如何上床Spring Boot项目到Gitlab中，并使用Jenkins自动构建任务，另外依托于Docker，让这一切变得更加方便，希望大家都多多思考，让机器自动干活，减少我们IT从业人员的重复、繁琐的工作量。\n\n\n', '小白学习gitlab+jenkins进行自动化构建(docker)之springboot项目', 0, 7, 2, 9, 0, '2023-06-09 16:56:30', '2023-06-09 16:56:30', 0);
INSERT INTO `tb_article` VALUES (15, '小白学习gitlab+jenkins进行自动化构建(docker)之springboot项目', '## 前言\ngitlab和jenkins的安装参考我的另外两篇博客：\n* gitlab安装：[小白搭建gitlab(docker)](https://juejin.cn/post/7032898607686778910)\n* jenkins安装：[小白学习搭建jenkins(docker)](https://juejin.cn/post/7032891246490157093/)\n\n## 在Jenkins上安装必要的插件\n所需插件：`Maven Integration`、`Pipeline Maven Integration`、`Gitlab`、`GitLab Authentication`、`SSH`、`Publish Over SSH`、`Docker`\n\n点击 Manage Jenkins（系统管理） ——> Manage Plugins（插件管理）\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5d15509337b44198064ba2bd41f221e~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Maven插件\n\n点击可选插件 ——> 过滤Maven Integration插件 ——> 勾选Maven Integration和Pipeline Maven Integration ——> 点击直接安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e496dbb12972454789d19546d660c88d~tplv-k3u1fbpfcp-watermark.image?)\n\n如图开始安装插件：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/134fef5f496c468b8dad342454c83b45~tplv-k3u1fbpfcp-watermark.image?)\n\n安装完成后，即可在插件管理下的已安装选项卡下看到刚刚已经安装的插件。\n\n#### 安装Gitlab插件\n\n点击可选插件 ——> 过滤Gitlab插件 ——> 勾选Gitlab和Gitlab Authentication ——> 点击直接安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6171674e55b428c9eba7be7cc2f516c~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装SSH插件和Publish Over SSH插件\n安装Publish Over SSH插件的原因：因为本方式是使用docker启动jenkins服务，所以在jenkins后续执行构建任务时候，需要在build成功后，将服务的jar包（以spring boot服务为例）拷贝到Dockerfile所在服务器的指定目录，进行微服务的启动；所以，此处需要配置SSH服务器的连接，意思就是在jenkins的任务结束后，去执行指定的服务器上的shell命令，做spring boot或cloud服务的镜像的构建，容器的运行，等一系列的事情。\n\n点击可选插件 ——> 过滤SSH插件 ——> 勾选SSH和Publish Over SSH ——> 点击直接安装\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d21ba2054860482b8b07684f48468538~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Docker插件\n\n点击可选插件 ——> 过滤Docker插件 ——> 勾选Docker ——> 点击直接安装\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1501abfe94b431a91e5692c41d12f72~tplv-k3u1fbpfcp-watermark.image?)\n\n插件全部安装完成后，可以重启一下Jenkins。\n\n## 相关配置\n\n#### 添加凭据\n\n点击 Manage Jenkins（系统管理） ——> Manage Credentials（凭据管理）\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0d3890020d34004adb05cab48310dd1~tplv-k3u1fbpfcp-watermark.image?)\n\n点击添加凭据 ——> 输入宿主机服务器的用户名和密码等信息并保存\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8eb6e5330d2140cb9705256fc722dc9d~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 配置SSH remote hosts\n\n这个配置是干什么的呢？配置SSH连接Dockerfile所在服务器的相关信息，并添加凭证，最后测试连接并保存，以备后面使用！！！\n\n点击 Manage Jenkins（系统管理） ——> 系统配置\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3813b66e9134305a1acb1d7515110bd~tplv-k3u1fbpfcp-watermark.image?)\n\n找到配置 ——> 下拉选择SSH remote hosts\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7436757a876049db93e6b255662001f2~tplv-k3u1fbpfcp-watermark.image?)\n\n如下图，输入对应的信息，并校验是否连接成功！成功后，点击应用 ——> 点击保存\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3559c64c918c4355aaff8d136e689da9~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 配置Publish over SSH\n\n找到配置 ——> 下拉选择Publish over SSH，进行相关配置即可。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0bb12f108302405ba90bb33e80fd0d5e~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78ad24f26a2a46b68ea44ea1c6ceb537~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de7ba1ca4a074ad1bb6f6a4b8fe71ee3~tplv-k3u1fbpfcp-watermark.image?)\n\n这里配置的数据，目前只能在Post Steps中选中send files or execute commands over ssh使用，要想能够在execute shell script on remote host using ssh方式中使用，需要再配置一份SSH remote hosts和它配套使用\n\n## 全局工具配置\n\n由于我们要实现的是SpringBoot项目的自动化部署操作，所以需要安装JDK、Git、Maven、Docker。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0dec279d6d44a83b2138cd7663e0995~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装JDK\n\n可以安装多个，根据项目JDK版本需求。\n\n输入自定义JDK名称 ——> 勾选自动安装 ——> 输入Oracle账户、密码 ——> 选择JDK版本 ——> 勾选同意协议\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72aa67fd5a494228840c5bef060e36b8~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Git\n\n输入自定义Git名称 ——> 勾选自动安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b49eb7bd11d48ab9ffce4f29431c216~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Maven\n\n输入自定义名称 ——> 勾选自动安装 ——> 选择版本\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5394195a98b647189dfaa5cd74b1a0b0~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Docker\n\n输入自定义名称 ——> 勾选自动安装\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/893704cbe8fe449fb615534bf9e82cea~tplv-k3u1fbpfcp-watermark.image?)\n\n最后，点击应用 ——> 点击保存即可。\n\n## 新建Jenkins任务\n\n### 点击新建任务，输入名称\n\n注意：本名称必须和项目名称一致，因为本名称会在jenkins工作空间下生成目录，类似于IDEA或Eclipse的工作空间的概念。所以，一般情况下，保证本名称=项目名称=docker镜像名称=docker容器名称 这样能尽可能的减轻jenkins配置的shell命令的复杂性！（空间命名要小写：因为镜像名不允许存在大写字母）\n\n选择构建一个Maven项目（因为是Spring Boot的服务）\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5a510bcf4ac49159f3f3b2960ae4fc5~tplv-k3u1fbpfcp-watermark.image?)\n\n### 源码管理\n\n输入描述信息，源码管理选择Git，从gitlab复制克隆地址（http协议的）粘贴到Repository URL中。未添加凭证会报授权失败的错误。错误如下：\n```\n![]()无法连接仓库：Command \"git ls-remote -h -- http://192.168.57.128:8880/root/video-book-backend.git HEAD\" returned status code 128:\\\nstdout:\\\nstderr: remote: HTTP Basic: Access denied\\\nfatal: Authentication failed for \'http://192.168.57.128:8880/root/video-book-backend.git/\'\n```\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94c2477c80724a959f8bb9f461814f41~tplv-k3u1fbpfcp-watermark.image?)\n\n添加gitlab凭证：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e08c1c343564fda9d5c599e985c38f5~tplv-k3u1fbpfcp-watermark.image?)\n\n### 构建触发器\n\n接下来将会生成供gitlab配置webhook使用的URL和Token，请记录下来，后面会使用。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1016fa1f35f24be7bf16ebe0a503bb8e~tplv-k3u1fbpfcp-watermark.image?)\n\n点击高级，拉下来找到Generate并点击，生成一串Secret Token。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13fb693d0ed14c63b8b613cccc7cd5b9~tplv-k3u1fbpfcp-watermark.image?)\n\n### 添加webhook\n\n前往gitlab，进入要构建的项目，在setting中选择Webhooks，输入URL和Secret Token 这两在上面图中已经给你标注了，去掉Enable SSL verification的勾选。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/904006704c604f6da4f2d1989200d462~tplv-k3u1fbpfcp-watermark.image?)\n\n点击Add webhook，如图表示成功添加了webhook：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6928c377f94748d0b70f57189e42e6cd~tplv-k3u1fbpfcp-watermark.image?)\n\n如果添加不成功解决方案请参考：[解决 Url is blocked: Requests to the local network are not allowed](https://www.cnblogs.com/zhongyuanzhao000/p/11379098.html)\n\n### 构建环境\n\n勾选Add timestamps to the Console Output，等下可以看到控制台打印的信息，这个根据自己的需求勾选。\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/badcdddabcc643b19f5a41fdc9f3416e~tplv-k3u1fbpfcp-watermark.image?)\n\n### Pre Steps(构建之前的步骤)\n\n配置前一步需要做的事情是：清理本项目在jenkins的workspace中的历史文件夹。\n\n你可以不用知道WORKSPACE具体的地址在哪里，因为下方有链接可以查看到当前jenkins中有哪些可用的变量供你使用。\n\n默认WORKSPACE地址：`/var/jenkins_home/workspace`（如果你jenkins是docker启动的，并且挂载了目录在宿主机，那你在宿主机也是可以看到的，即 `/usr/local/docker/workspace`）\n\n本处选择的是执行shell，则表示本处配置的shell命令，是默认在jenkins容器中执行的，而不是在宿主机上。\n\n下拉选择执行 shell：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c2e1bd362944ff2aab0a62646bae53d~tplv-k3u1fbpfcp-watermark.image?)\n\n在执行shell的命令中输入以下命令，设置全局变量：\n```\nSERVER_NAME_1=video-book-backend\necho \"=========================>>>>>>>工作空间WORKSPACE的地址：$WORKSPACE \"\ncd $WORKSPACE\necho \"=========================>>>>>>>进入工作空间WORKSPACE，清除工作空间中原项目的工作空间$SERVER_NAME_1 \"\nrm -rf $SERVER_NAME_1\necho \"=========================>>>>>>>清除工作空间中原项目的工作空间$SERVER_NAME_1 ......成功success\"\n```\n注意：本处的SERVER_NAME_1=jenkins-docker-gitlab-springboot是配置项目的名称(和gitlab中的项目名保持一致)\n\n### Build(构建)\n\n我们是SpringBoot项目，所以用到maven，这里设置一下全局操作，clean项目，并打成jar包，所以这里输入：`clean package`\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a41ff4b5061f48f39de4738c6282ec78~tplv-k3u1fbpfcp-watermark.image?)\n\n### Post Steps(执行任务)\n\n只在jenkins构建成功后，才执行这一步。\n\n因为最后的构建成功的maven项目的jar包是以docker启动服务为目的，所以最后的docker操作，一定是在jenkins容器以外的服务器上运行的，可能是本机宿主机，也可能是远程的服务器，这个根据自己的情况去配置。\n\n本处选择，在远程的SSH执行shell脚本。\n\n选中只有构建成功才执行这些命令，然后选择Execute shell script on remote host using ssh。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c25a57ddb8f4b10b31e4832503d4af2~tplv-k3u1fbpfcp-watermark.image?)\n\nshell命令:\n```\n# =====================================================================================\n# =================================定义初始化变量======================================\n# =====================================================================================\n\n# 操作/项目路径(Dockerfile存放的路径，Dockerfile一般都放在项目的根目录下)\n# 如果Dockerfile放在项目根目录的子目录下，则子目录不能与项目同名\n# 会导致在复制jar包的时候，覆盖子目录为jar包,同时没有扩展名jar,原因我暂时不知道\n# 目前我的做法是将Dockerfile放在项目根目录下\nBASE_PATH=/usr/local/docker/jenkins/workspace/video-book-backend\n\n# jenkins构建好的源jar路径\n# 这个路径是jenkins容器挂载在宿主机上的路径\n# 我的jenkins的目录被我挂载在了/usr/local/docker/jenkins上\nSOURCE_PATH=/usr/local/docker/jenkins/workspace\n\n# docker镜像、docker容器、Dockerfile同目录下的jar名字[用它build生成image的jar]、jenkins的workspace下的项目名称\n# 注意统一名称！！！！！\nSERVER_NAME=video-book-backend\n\n# 容器id  [grep -w 全量匹配容器名] [awk 获取信息行的第一列，即容器ID]  [无论容器启动与否，都获取到]\nCID=$(docker ps -a | grep -w \"$SERVER_NAME\" | awk \'{print $1}\')\n\n# 镜像id  [grep -w 全量匹配镜像名] [awk 获取信息行的第三列，即镜像ID]\nIID=$(docker images | grep -w \"$SERVER_NAME\" | awk \'{print $3}\')\n\n# 源jar完整地址[jenkins构建成功后，会在自己的workspace/项目/target下生成maven构建成功的jar包，获取jar包名的完整路径]\n# 例如：/usr/local/docker/jenkins/workspace/video-book-backend/target/video-book-backend-0.0.1-SNAPSHOT.jar\nSOURCE_JAR_PATH=$(find \"$SOURCE_PATH/$SERVER_NAME/target/\"  -name \"*$SERVER_NAME*.jar\" )\n\nDATE=`date +%Y%m%d%H%M%S`\n\n# =====================================================================================\n# ============================对原本已存在的jar进行备份================================\n# =====================================================================================\n\n# 备份\nfunction backup(){\n    if [ -f \"$BASE_PATH/$SERVER_NAME.jar\" ]; then\n        echo \"=========================>>>>>>>$SERVER_NAME.jar 备份...\"\n            mv $BASE_PATH/$SERVER_NAME.jar $BASE_PATH/backup/$SERVER_NAME-$DATE.jar\n        echo \"=========================>>>>>>>备份老的 $SERVER_NAME.jar 完成\"\n\n    else\n        echo \"=========================>>>>>>>老的$BASE_PATH/$SERVER_NAME.jar不存在，跳过备份\"\n    fi\n}\n\n# =====================================================================================\n# =========================移动最新源jar包到Dockerfile所在目录=========================\n# =====================================================================================\n\n\n \n# 查找源jar文件名，进行重命名，最后将源文件移动到Dockerfile文件所在目录\nfunction transfer(){\n      \n    echo \"=========================>>>>>>>源文件完整地址为 $SOURCE_JAR_PATH\"\n\n    echo \"=========================>>>>>>>重命名源文件\"\n        mv $SOURCE_JAR_PATH  $SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar\n\n    echo \"=========================>>>>>>>最新构建代码 将$SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar 迁移至 $BASE_PATH\"\n        cp $SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar $BASE_PATH\n        \n    echo \"=========================>>>>>>>迁移完成Success\"\n\n}\n \n# =====================================================================================\n# ==================================构建最新镜像=======================================\n# =====================================================================================\n\n# 构建docker镜像\nfunction build(){\n    \n    # 无论镜像存在与否，都停止原容器服务，并移除原容器服务\n    echo \"=========================>>>>>>>停止$SERVER_NAME容器，CID=$CID\"\n    docker stop $CID\n\n    echo \"=========================>>>>>>>移除$SERVER_NAME容器，CID=$CID\"\n    docker rm $CID\n\n    # 无论如何，都去构建新的镜像\n    if [ -n \"$IID\" ]; then\n        echo \"=========================>>>>>>>存在$SERVER_NAME镜像，IID=$IID\"\n\n        echo \"=========================>>>>>>>移除老的$SERVER_NAME镜像，IID=$IID\"\n        \n        docker rmi $IID\n\n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，开始---->\"\n        \n        cd $BASE_PATH\n        docker build -t $SERVER_NAME .\n        \n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，完成---->\"\n\n    else\n        echo \"=========================>>>>>>>不存在$SERVER_NAME镜像，构建新的镜像，开始--->\"\n        \n        cd $BASE_PATH\n        docker build -t $SERVER_NAME .\n        \n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，结束--->\"\n    fi\n}\n \n\n# =====================================================================================\n# ==============================运行docker容器，启动服务===============================\n# =====================================================================================\n\n# 运行docker容器\nfunction run(){\n    backup\n    transfer\n    build\n\n    # 创建容器\n    docker run --name $SERVER_NAME -itd --net=host -v /etc/localtime:/etc/localtime:ro  -v /etc/timezone:/etc/timezone:ro  $SERVER_NAME \n\n}\n \n# 入口\nrun\n```\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e67ba6d7cf14d52b00009c09afc9349~tplv-k3u1fbpfcp-watermark.image?)\n\nOK，到这里基本的任务已经新建成功，至于后续的两个步骤，根据自己的需求自行配置，没有难度的。\n\n点击应用，保存。\n\n### 测试\n\n测试push事件触发自动化构建和部署，点击test下拉选择push events，出现HTTP 200表示OK了。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e85f532d1c2b4643996604347b945f51~tplv-k3u1fbpfcp-watermark.image?)\n\n回到Jenkins可以看到任务列表，查看构建信息等。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f954757d41324660ae01ff5de6afe17e~tplv-k3u1fbpfcp-watermark.image?)\n\n待Jenkins构建成功之后，在服务器上执行命令：`docker ps`，可以看到我们启动起来的 SpringBoot 容器：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8556de2ce136416ea36e817b661c2f80~tplv-k3u1fbpfcp-watermark.image?)\n\n## 邮件通知\n\n有时候团队合作，我们希望能通过邮件通知每一个开发者，项目是否构建成功。jenkins/jenkins:2.332.1默认安装了`# Email Extension Template`这个插件，还需要安装`Email Extension Template`这个插件\n\n系统管理->插件管理->可选插件->搜索`Email Extension Template`\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51c60941d3d3422e88db89b5188a3168~tplv-k3u1fbpfcp-watermark.image?)\n\n直接安装\n\n### 配置Email(Jenkins自带)\n\n#### 2.1 基础信息查询\n\n>找到所要配置邮箱的基础信息，这里以QQ邮箱为例\n\n1. 通过网页端QQ邮箱的设置进入到邮箱客户端设置页面\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f31038ef147f4c728540bc581f64d522~tplv-k3u1fbpfcp-watermark.image?)\n\n2. 找到邮箱的基础信息\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5694801b0ed74685a76cade6b358c5fc~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 2.2 Jenkins邮件通知配置\n\n在Jenkins：`系统管理->系统配置`中，最底部找到`邮件通知`，打开`高级`,注意到在配置的下方有个\"通过发送测试邮件测试配置\"，我们可以讲其勾选，填入邮箱地址，点击`Test configuration`来先测试一下邮件的发送。\n\n> 这边最好先保存一下再测试，否则出错，又得重配。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6420215d674647fb824854fd68a3efd6~tplv-k3u1fbpfcp-watermark.image?)\n\n如果报错如下：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8481f74294404047a2671bc8e2a3297e~tplv-k3u1fbpfcp-watermark.image?)\n\n这是因为我们还需要在设置`Jenkins Location`中配置`系统管理员邮件地址`，此地址要和`邮件通知`中的`用户名`一致\n\n### 配置Email(Extended E-mail Notification)\n\n>记得文章一开头提到的下载Extended插件，没错，Jenkins系统设置里还可以通过`Extended E-mail Notification`对邮件发送进行模板格式的自定义\n\n#### 3.1 基础信息配置\n\n基础信息配置与上述一致,唯一要注意的是这里需要重新生成一个授权码\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cb0934380904b098a035e54297946d4~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 3.2 模板格式配置\n\n接3.1配置继续。这里主要就是配置展示的模板格式，常用的格式化的参数有：\n```\n- $BUILD_STATUS – 构建结果\n- $PROJECT_NAME – 构建脚本名称\n- $BUILD_NUMBER – 构建脚本编号\n- $JOB_DESCRIPTION – 构建项目描述 \n- $CAUSE – 脚本启动原因\n- $BUILD_URL – 脚本构建详情URL地址\n```\n\n这里选择以HTML的格式展示，填入模板：\n```\n<!DOCTYPE html>    \n<html>    \n<head>    \n<meta charset=\"UTF-8\">    \n<title>${ENV, var=\"JOB_NAME\"}-第${BUILD_NUMBER}次构建日志</title>    \n</head>    \n    \n<body leftmargin=\"8\" marginwidth=\"0\" topmargin=\"8\" marginheight=\"4\"    \n    offset=\"0\">    \n    <table width=\"95%\" cellpadding=\"0\" cellspacing=\"0\"  style=\"font-size: 11pt; font-family: Tahoma, Arial, Helvetica, sans-serif\">    \n        <tr>    \n            本邮件由系统自动发出，无需回复！<br/>            \n            各位同事，大家好，以下为${PROJECT_NAME}项目构建信息</br> \n            <td><font color=\"#CC0000\">构建结果 - ${BUILD_STATUS}</font></td>   \n        </tr>    \n        <tr>    \n            <td><br />    \n            <b><font color=\"#0B610B\">构建信息</font></b>    \n            <hr size=\"2\" width=\"100%\" align=\"center\" /></td>    \n        </tr>    \n        <tr>    \n            <td>    \n                <ul>    \n                    <li>项目名称 ： ${PROJECT_NAME}</li>    \n                    <li>构建编号 ： 第${BUILD_NUMBER}次构建</li>    \n                    <li>触发原因： ${CAUSE}</li>    \n                    <li>构建状态： ${BUILD_STATUS}</li>    \n                    <li>构建日志： <a href=\"${BUILD_URL}console\">${BUILD_URL}console</a></li>    \n                    <li>构建  Url ： <a href=\"${BUILD_URL}\">${BUILD_URL}</a></li>    \n                    <li>工作目录 ： <a href=\"${PROJECT_URL}ws\">${PROJECT_URL}ws</a></li>    \n                    <li>项目  Url ： <a href=\"${PROJECT_URL}\">${PROJECT_URL}</a></li>    \n                </ul>    \n\n<h4><font color=\"#0B610B\">失败用例</font></h4>\n<hr size=\"2\" width=\"100%\" />\n$FAILED_TESTS<br/>\n\n<h4><font color=\"#0B610B\">最近提交(#$SVN_REVISION)</font></h4>\n<hr size=\"2\" width=\"100%\" />\n<ul>\n${CHANGES_SINCE_LAST_SUCCESS, reverse=true, format=\"%c\", changesFormat=\"<li>%d [%a] %m</li>\"}\n</ul>\n详细提交: <a href=\"${PROJECT_URL}changes\">${PROJECT_URL}changes</a><br/>\n\n            </td>    \n        </tr>    \n    </table>    \n</body>    \n</html>\n```\n\n如下图：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8b10b649f4943e1944fc094c72a3d2e~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 3.3 触发条件配置\n\n我们还可以在`Default Triggers`中根据自己的需要配置邮件的触发条件\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4328af1e2934c81b61f8c0429b6313b~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16835dfc64334f0e93a6cb7fd262922a~tplv-k3u1fbpfcp-watermark.image?)\n\n>这里为了防止因为构建一直尝试结果均为失败而造成的邮件轰炸，可以设置邮件仅第一次或第二次构建结果为失败时才发送邮件，后续失败的邮件将不再发送。我选择的是每一次失败和构建成功都会发邮件通知\n\n#### 3.4 jenkins的任务中配置邮件通知\n\n1. 在对应的任务中的构建设置中，勾选`E-mail Notification Recipients`\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/224fb406029d46d489cb6192848fdb6e~tplv-k3u1fbpfcp-watermark.image?)\n\n2. 在对应的任务中的构建后操作中，下拉选择`Editable Email Notification`\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1abc14189c874a818e5fe42a90371e43~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/594c71d3301544e48f6cc7468724b964~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b633844afb7a43e488cd3ab81d7c08a9~tplv-k3u1fbpfcp-watermark.image?)\n\n至此，jnekins的自动化构建的邮件通知已配置完成，在gitlab点击push event发起构建进行测试。\n\n发送成功的话，可看到如下图的提示：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a26d60de670c48ca991975dc2d20fa20~tplv-k3u1fbpfcp-watermark.image?)\n\n## 总结\n\n经过多款插件的安装配置，逐步掌握了如何上床Spring Boot项目到Gitlab中，并使用Jenkins自动构建任务，另外依托于Docker，让这一切变得更加方便，希望大家都多多思考，让机器自动干活，减少我们IT从业人员的重复、繁琐的工作量。\n\n\n', '小白学习gitlab+jenkins进行自动化构建(docker)之springboot项目', 0, 7, 2, 9, 0, '2023-06-09 16:56:30', '2023-06-09 16:56:30', 0);
INSERT INTO `tb_article` VALUES (16, '小白学习gitlab+jenkins进行自动化构建(docker)之springboot项目', '## 前言\ngitlab和jenkins的安装参考我的另外两篇博客：\n* gitlab安装：[小白搭建gitlab(docker)](https://juejin.cn/post/7032898607686778910)\n* jenkins安装：[小白学习搭建jenkins(docker)](https://juejin.cn/post/7032891246490157093/)\n\n## 在Jenkins上安装必要的插件\n所需插件：`Maven Integration`、`Pipeline Maven Integration`、`Gitlab`、`GitLab Authentication`、`SSH`、`Publish Over SSH`、`Docker`\n\n点击 Manage Jenkins（系统管理） ——> Manage Plugins（插件管理）\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5d15509337b44198064ba2bd41f221e~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Maven插件\n\n点击可选插件 ——> 过滤Maven Integration插件 ——> 勾选Maven Integration和Pipeline Maven Integration ——> 点击直接安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e496dbb12972454789d19546d660c88d~tplv-k3u1fbpfcp-watermark.image?)\n\n如图开始安装插件：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/134fef5f496c468b8dad342454c83b45~tplv-k3u1fbpfcp-watermark.image?)\n\n安装完成后，即可在插件管理下的已安装选项卡下看到刚刚已经安装的插件。\n\n#### 安装Gitlab插件\n\n点击可选插件 ——> 过滤Gitlab插件 ——> 勾选Gitlab和Gitlab Authentication ——> 点击直接安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6171674e55b428c9eba7be7cc2f516c~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装SSH插件和Publish Over SSH插件\n安装Publish Over SSH插件的原因：因为本方式是使用docker启动jenkins服务，所以在jenkins后续执行构建任务时候，需要在build成功后，将服务的jar包（以spring boot服务为例）拷贝到Dockerfile所在服务器的指定目录，进行微服务的启动；所以，此处需要配置SSH服务器的连接，意思就是在jenkins的任务结束后，去执行指定的服务器上的shell命令，做spring boot或cloud服务的镜像的构建，容器的运行，等一系列的事情。\n\n点击可选插件 ——> 过滤SSH插件 ——> 勾选SSH和Publish Over SSH ——> 点击直接安装\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d21ba2054860482b8b07684f48468538~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Docker插件\n\n点击可选插件 ——> 过滤Docker插件 ——> 勾选Docker ——> 点击直接安装\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1501abfe94b431a91e5692c41d12f72~tplv-k3u1fbpfcp-watermark.image?)\n\n插件全部安装完成后，可以重启一下Jenkins。\n\n## 相关配置\n\n#### 添加凭据\n\n点击 Manage Jenkins（系统管理） ——> Manage Credentials（凭据管理）\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0d3890020d34004adb05cab48310dd1~tplv-k3u1fbpfcp-watermark.image?)\n\n点击添加凭据 ——> 输入宿主机服务器的用户名和密码等信息并保存\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8eb6e5330d2140cb9705256fc722dc9d~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 配置SSH remote hosts\n\n这个配置是干什么的呢？配置SSH连接Dockerfile所在服务器的相关信息，并添加凭证，最后测试连接并保存，以备后面使用！！！\n\n点击 Manage Jenkins（系统管理） ——> 系统配置\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3813b66e9134305a1acb1d7515110bd~tplv-k3u1fbpfcp-watermark.image?)\n\n找到配置 ——> 下拉选择SSH remote hosts\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7436757a876049db93e6b255662001f2~tplv-k3u1fbpfcp-watermark.image?)\n\n如下图，输入对应的信息，并校验是否连接成功！成功后，点击应用 ——> 点击保存\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3559c64c918c4355aaff8d136e689da9~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 配置Publish over SSH\n\n找到配置 ——> 下拉选择Publish over SSH，进行相关配置即可。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0bb12f108302405ba90bb33e80fd0d5e~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78ad24f26a2a46b68ea44ea1c6ceb537~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de7ba1ca4a074ad1bb6f6a4b8fe71ee3~tplv-k3u1fbpfcp-watermark.image?)\n\n这里配置的数据，目前只能在Post Steps中选中send files or execute commands over ssh使用，要想能够在execute shell script on remote host using ssh方式中使用，需要再配置一份SSH remote hosts和它配套使用\n\n## 全局工具配置\n\n由于我们要实现的是SpringBoot项目的自动化部署操作，所以需要安装JDK、Git、Maven、Docker。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0dec279d6d44a83b2138cd7663e0995~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装JDK\n\n可以安装多个，根据项目JDK版本需求。\n\n输入自定义JDK名称 ——> 勾选自动安装 ——> 输入Oracle账户、密码 ——> 选择JDK版本 ——> 勾选同意协议\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72aa67fd5a494228840c5bef060e36b8~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Git\n\n输入自定义Git名称 ——> 勾选自动安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b49eb7bd11d48ab9ffce4f29431c216~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Maven\n\n输入自定义名称 ——> 勾选自动安装 ——> 选择版本\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5394195a98b647189dfaa5cd74b1a0b0~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Docker\n\n输入自定义名称 ——> 勾选自动安装\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/893704cbe8fe449fb615534bf9e82cea~tplv-k3u1fbpfcp-watermark.image?)\n\n最后，点击应用 ——> 点击保存即可。\n\n## 新建Jenkins任务\n\n### 点击新建任务，输入名称\n\n注意：本名称必须和项目名称一致，因为本名称会在jenkins工作空间下生成目录，类似于IDEA或Eclipse的工作空间的概念。所以，一般情况下，保证本名称=项目名称=docker镜像名称=docker容器名称 这样能尽可能的减轻jenkins配置的shell命令的复杂性！（空间命名要小写：因为镜像名不允许存在大写字母）\n\n选择构建一个Maven项目（因为是Spring Boot的服务）\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5a510bcf4ac49159f3f3b2960ae4fc5~tplv-k3u1fbpfcp-watermark.image?)\n\n### 源码管理\n\n输入描述信息，源码管理选择Git，从gitlab复制克隆地址（http协议的）粘贴到Repository URL中。未添加凭证会报授权失败的错误。错误如下：\n```\n![]()无法连接仓库：Command \"git ls-remote -h -- http://192.168.57.128:8880/root/video-book-backend.git HEAD\" returned status code 128:\\\nstdout:\\\nstderr: remote: HTTP Basic: Access denied\\\nfatal: Authentication failed for \'http://192.168.57.128:8880/root/video-book-backend.git/\'\n```\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94c2477c80724a959f8bb9f461814f41~tplv-k3u1fbpfcp-watermark.image?)\n\n添加gitlab凭证：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e08c1c343564fda9d5c599e985c38f5~tplv-k3u1fbpfcp-watermark.image?)\n\n### 构建触发器\n\n接下来将会生成供gitlab配置webhook使用的URL和Token，请记录下来，后面会使用。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1016fa1f35f24be7bf16ebe0a503bb8e~tplv-k3u1fbpfcp-watermark.image?)\n\n点击高级，拉下来找到Generate并点击，生成一串Secret Token。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13fb693d0ed14c63b8b613cccc7cd5b9~tplv-k3u1fbpfcp-watermark.image?)\n\n### 添加webhook\n\n前往gitlab，进入要构建的项目，在setting中选择Webhooks，输入URL和Secret Token 这两在上面图中已经给你标注了，去掉Enable SSL verification的勾选。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/904006704c604f6da4f2d1989200d462~tplv-k3u1fbpfcp-watermark.image?)\n\n点击Add webhook，如图表示成功添加了webhook：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6928c377f94748d0b70f57189e42e6cd~tplv-k3u1fbpfcp-watermark.image?)\n\n如果添加不成功解决方案请参考：[解决 Url is blocked: Requests to the local network are not allowed](https://www.cnblogs.com/zhongyuanzhao000/p/11379098.html)\n\n### 构建环境\n\n勾选Add timestamps to the Console Output，等下可以看到控制台打印的信息，这个根据自己的需求勾选。\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/badcdddabcc643b19f5a41fdc9f3416e~tplv-k3u1fbpfcp-watermark.image?)\n\n### Pre Steps(构建之前的步骤)\n\n配置前一步需要做的事情是：清理本项目在jenkins的workspace中的历史文件夹。\n\n你可以不用知道WORKSPACE具体的地址在哪里，因为下方有链接可以查看到当前jenkins中有哪些可用的变量供你使用。\n\n默认WORKSPACE地址：`/var/jenkins_home/workspace`（如果你jenkins是docker启动的，并且挂载了目录在宿主机，那你在宿主机也是可以看到的，即 `/usr/local/docker/workspace`）\n\n本处选择的是执行shell，则表示本处配置的shell命令，是默认在jenkins容器中执行的，而不是在宿主机上。\n\n下拉选择执行 shell：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c2e1bd362944ff2aab0a62646bae53d~tplv-k3u1fbpfcp-watermark.image?)\n\n在执行shell的命令中输入以下命令，设置全局变量：\n```\nSERVER_NAME_1=video-book-backend\necho \"=========================>>>>>>>工作空间WORKSPACE的地址：$WORKSPACE \"\ncd $WORKSPACE\necho \"=========================>>>>>>>进入工作空间WORKSPACE，清除工作空间中原项目的工作空间$SERVER_NAME_1 \"\nrm -rf $SERVER_NAME_1\necho \"=========================>>>>>>>清除工作空间中原项目的工作空间$SERVER_NAME_1 ......成功success\"\n```\n注意：本处的SERVER_NAME_1=jenkins-docker-gitlab-springboot是配置项目的名称(和gitlab中的项目名保持一致)\n\n### Build(构建)\n\n我们是SpringBoot项目，所以用到maven，这里设置一下全局操作，clean项目，并打成jar包，所以这里输入：`clean package`\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a41ff4b5061f48f39de4738c6282ec78~tplv-k3u1fbpfcp-watermark.image?)\n\n### Post Steps(执行任务)\n\n只在jenkins构建成功后，才执行这一步。\n\n因为最后的构建成功的maven项目的jar包是以docker启动服务为目的，所以最后的docker操作，一定是在jenkins容器以外的服务器上运行的，可能是本机宿主机，也可能是远程的服务器，这个根据自己的情况去配置。\n\n本处选择，在远程的SSH执行shell脚本。\n\n选中只有构建成功才执行这些命令，然后选择Execute shell script on remote host using ssh。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c25a57ddb8f4b10b31e4832503d4af2~tplv-k3u1fbpfcp-watermark.image?)\n\nshell命令:\n```\n# =====================================================================================\n# =================================定义初始化变量======================================\n# =====================================================================================\n\n# 操作/项目路径(Dockerfile存放的路径，Dockerfile一般都放在项目的根目录下)\n# 如果Dockerfile放在项目根目录的子目录下，则子目录不能与项目同名\n# 会导致在复制jar包的时候，覆盖子目录为jar包,同时没有扩展名jar,原因我暂时不知道\n# 目前我的做法是将Dockerfile放在项目根目录下\nBASE_PATH=/usr/local/docker/jenkins/workspace/video-book-backend\n\n# jenkins构建好的源jar路径\n# 这个路径是jenkins容器挂载在宿主机上的路径\n# 我的jenkins的目录被我挂载在了/usr/local/docker/jenkins上\nSOURCE_PATH=/usr/local/docker/jenkins/workspace\n\n# docker镜像、docker容器、Dockerfile同目录下的jar名字[用它build生成image的jar]、jenkins的workspace下的项目名称\n# 注意统一名称！！！！！\nSERVER_NAME=video-book-backend\n\n# 容器id  [grep -w 全量匹配容器名] [awk 获取信息行的第一列，即容器ID]  [无论容器启动与否，都获取到]\nCID=$(docker ps -a | grep -w \"$SERVER_NAME\" | awk \'{print $1}\')\n\n# 镜像id  [grep -w 全量匹配镜像名] [awk 获取信息行的第三列，即镜像ID]\nIID=$(docker images | grep -w \"$SERVER_NAME\" | awk \'{print $3}\')\n\n# 源jar完整地址[jenkins构建成功后，会在自己的workspace/项目/target下生成maven构建成功的jar包，获取jar包名的完整路径]\n# 例如：/usr/local/docker/jenkins/workspace/video-book-backend/target/video-book-backend-0.0.1-SNAPSHOT.jar\nSOURCE_JAR_PATH=$(find \"$SOURCE_PATH/$SERVER_NAME/target/\"  -name \"*$SERVER_NAME*.jar\" )\n\nDATE=`date +%Y%m%d%H%M%S`\n\n# =====================================================================================\n# ============================对原本已存在的jar进行备份================================\n# =====================================================================================\n\n# 备份\nfunction backup(){\n    if [ -f \"$BASE_PATH/$SERVER_NAME.jar\" ]; then\n        echo \"=========================>>>>>>>$SERVER_NAME.jar 备份...\"\n            mv $BASE_PATH/$SERVER_NAME.jar $BASE_PATH/backup/$SERVER_NAME-$DATE.jar\n        echo \"=========================>>>>>>>备份老的 $SERVER_NAME.jar 完成\"\n\n    else\n        echo \"=========================>>>>>>>老的$BASE_PATH/$SERVER_NAME.jar不存在，跳过备份\"\n    fi\n}\n\n# =====================================================================================\n# =========================移动最新源jar包到Dockerfile所在目录=========================\n# =====================================================================================\n\n\n \n# 查找源jar文件名，进行重命名，最后将源文件移动到Dockerfile文件所在目录\nfunction transfer(){\n      \n    echo \"=========================>>>>>>>源文件完整地址为 $SOURCE_JAR_PATH\"\n\n    echo \"=========================>>>>>>>重命名源文件\"\n        mv $SOURCE_JAR_PATH  $SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar\n\n    echo \"=========================>>>>>>>最新构建代码 将$SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar 迁移至 $BASE_PATH\"\n        cp $SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar $BASE_PATH\n        \n    echo \"=========================>>>>>>>迁移完成Success\"\n\n}\n \n# =====================================================================================\n# ==================================构建最新镜像=======================================\n# =====================================================================================\n\n# 构建docker镜像\nfunction build(){\n    \n    # 无论镜像存在与否，都停止原容器服务，并移除原容器服务\n    echo \"=========================>>>>>>>停止$SERVER_NAME容器，CID=$CID\"\n    docker stop $CID\n\n    echo \"=========================>>>>>>>移除$SERVER_NAME容器，CID=$CID\"\n    docker rm $CID\n\n    # 无论如何，都去构建新的镜像\n    if [ -n \"$IID\" ]; then\n        echo \"=========================>>>>>>>存在$SERVER_NAME镜像，IID=$IID\"\n\n        echo \"=========================>>>>>>>移除老的$SERVER_NAME镜像，IID=$IID\"\n        \n        docker rmi $IID\n\n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，开始---->\"\n        \n        cd $BASE_PATH\n        docker build -t $SERVER_NAME .\n        \n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，完成---->\"\n\n    else\n        echo \"=========================>>>>>>>不存在$SERVER_NAME镜像，构建新的镜像，开始--->\"\n        \n        cd $BASE_PATH\n        docker build -t $SERVER_NAME .\n        \n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，结束--->\"\n    fi\n}\n \n\n# =====================================================================================\n# ==============================运行docker容器，启动服务===============================\n# =====================================================================================\n\n# 运行docker容器\nfunction run(){\n    backup\n    transfer\n    build\n\n    # 创建容器\n    docker run --name $SERVER_NAME -itd --net=host -v /etc/localtime:/etc/localtime:ro  -v /etc/timezone:/etc/timezone:ro  $SERVER_NAME \n\n}\n \n# 入口\nrun\n```\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e67ba6d7cf14d52b00009c09afc9349~tplv-k3u1fbpfcp-watermark.image?)\n\nOK，到这里基本的任务已经新建成功，至于后续的两个步骤，根据自己的需求自行配置，没有难度的。\n\n点击应用，保存。\n\n### 测试\n\n测试push事件触发自动化构建和部署，点击test下拉选择push events，出现HTTP 200表示OK了。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e85f532d1c2b4643996604347b945f51~tplv-k3u1fbpfcp-watermark.image?)\n\n回到Jenkins可以看到任务列表，查看构建信息等。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f954757d41324660ae01ff5de6afe17e~tplv-k3u1fbpfcp-watermark.image?)\n\n待Jenkins构建成功之后，在服务器上执行命令：`docker ps`，可以看到我们启动起来的 SpringBoot 容器：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8556de2ce136416ea36e817b661c2f80~tplv-k3u1fbpfcp-watermark.image?)\n\n## 邮件通知\n\n有时候团队合作，我们希望能通过邮件通知每一个开发者，项目是否构建成功。jenkins/jenkins:2.332.1默认安装了`# Email Extension Template`这个插件，还需要安装`Email Extension Template`这个插件\n\n系统管理->插件管理->可选插件->搜索`Email Extension Template`\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51c60941d3d3422e88db89b5188a3168~tplv-k3u1fbpfcp-watermark.image?)\n\n直接安装\n\n### 配置Email(Jenkins自带)\n\n#### 2.1 基础信息查询\n\n>找到所要配置邮箱的基础信息，这里以QQ邮箱为例\n\n1. 通过网页端QQ邮箱的设置进入到邮箱客户端设置页面\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f31038ef147f4c728540bc581f64d522~tplv-k3u1fbpfcp-watermark.image?)\n\n2. 找到邮箱的基础信息\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5694801b0ed74685a76cade6b358c5fc~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 2.2 Jenkins邮件通知配置\n\n在Jenkins：`系统管理->系统配置`中，最底部找到`邮件通知`，打开`高级`,注意到在配置的下方有个\"通过发送测试邮件测试配置\"，我们可以讲其勾选，填入邮箱地址，点击`Test configuration`来先测试一下邮件的发送。\n\n> 这边最好先保存一下再测试，否则出错，又得重配。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6420215d674647fb824854fd68a3efd6~tplv-k3u1fbpfcp-watermark.image?)\n\n如果报错如下：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8481f74294404047a2671bc8e2a3297e~tplv-k3u1fbpfcp-watermark.image?)\n\n这是因为我们还需要在设置`Jenkins Location`中配置`系统管理员邮件地址`，此地址要和`邮件通知`中的`用户名`一致\n\n### 配置Email(Extended E-mail Notification)\n\n>记得文章一开头提到的下载Extended插件，没错，Jenkins系统设置里还可以通过`Extended E-mail Notification`对邮件发送进行模板格式的自定义\n\n#### 3.1 基础信息配置\n\n基础信息配置与上述一致,唯一要注意的是这里需要重新生成一个授权码\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cb0934380904b098a035e54297946d4~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 3.2 模板格式配置\n\n接3.1配置继续。这里主要就是配置展示的模板格式，常用的格式化的参数有：\n```\n- $BUILD_STATUS – 构建结果\n- $PROJECT_NAME – 构建脚本名称\n- $BUILD_NUMBER – 构建脚本编号\n- $JOB_DESCRIPTION – 构建项目描述 \n- $CAUSE – 脚本启动原因\n- $BUILD_URL – 脚本构建详情URL地址\n```\n\n这里选择以HTML的格式展示，填入模板：\n```\n<!DOCTYPE html>    \n<html>    \n<head>    \n<meta charset=\"UTF-8\">    \n<title>${ENV, var=\"JOB_NAME\"}-第${BUILD_NUMBER}次构建日志</title>    \n</head>    \n    \n<body leftmargin=\"8\" marginwidth=\"0\" topmargin=\"8\" marginheight=\"4\"    \n    offset=\"0\">    \n    <table width=\"95%\" cellpadding=\"0\" cellspacing=\"0\"  style=\"font-size: 11pt; font-family: Tahoma, Arial, Helvetica, sans-serif\">    \n        <tr>    \n            本邮件由系统自动发出，无需回复！<br/>            \n            各位同事，大家好，以下为${PROJECT_NAME}项目构建信息</br> \n            <td><font color=\"#CC0000\">构建结果 - ${BUILD_STATUS}</font></td>   \n        </tr>    \n        <tr>    \n            <td><br />    \n            <b><font color=\"#0B610B\">构建信息</font></b>    \n            <hr size=\"2\" width=\"100%\" align=\"center\" /></td>    \n        </tr>    \n        <tr>    \n            <td>    \n                <ul>    \n                    <li>项目名称 ： ${PROJECT_NAME}</li>    \n                    <li>构建编号 ： 第${BUILD_NUMBER}次构建</li>    \n                    <li>触发原因： ${CAUSE}</li>    \n                    <li>构建状态： ${BUILD_STATUS}</li>    \n                    <li>构建日志： <a href=\"${BUILD_URL}console\">${BUILD_URL}console</a></li>    \n                    <li>构建  Url ： <a href=\"${BUILD_URL}\">${BUILD_URL}</a></li>    \n                    <li>工作目录 ： <a href=\"${PROJECT_URL}ws\">${PROJECT_URL}ws</a></li>    \n                    <li>项目  Url ： <a href=\"${PROJECT_URL}\">${PROJECT_URL}</a></li>    \n                </ul>    \n\n<h4><font color=\"#0B610B\">失败用例</font></h4>\n<hr size=\"2\" width=\"100%\" />\n$FAILED_TESTS<br/>\n\n<h4><font color=\"#0B610B\">最近提交(#$SVN_REVISION)</font></h4>\n<hr size=\"2\" width=\"100%\" />\n<ul>\n${CHANGES_SINCE_LAST_SUCCESS, reverse=true, format=\"%c\", changesFormat=\"<li>%d [%a] %m</li>\"}\n</ul>\n详细提交: <a href=\"${PROJECT_URL}changes\">${PROJECT_URL}changes</a><br/>\n\n            </td>    \n        </tr>    \n    </table>    \n</body>    \n</html>\n```\n\n如下图：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8b10b649f4943e1944fc094c72a3d2e~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 3.3 触发条件配置\n\n我们还可以在`Default Triggers`中根据自己的需要配置邮件的触发条件\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4328af1e2934c81b61f8c0429b6313b~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16835dfc64334f0e93a6cb7fd262922a~tplv-k3u1fbpfcp-watermark.image?)\n\n>这里为了防止因为构建一直尝试结果均为失败而造成的邮件轰炸，可以设置邮件仅第一次或第二次构建结果为失败时才发送邮件，后续失败的邮件将不再发送。我选择的是每一次失败和构建成功都会发邮件通知\n\n#### 3.4 jenkins的任务中配置邮件通知\n\n1. 在对应的任务中的构建设置中，勾选`E-mail Notification Recipients`\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/224fb406029d46d489cb6192848fdb6e~tplv-k3u1fbpfcp-watermark.image?)\n\n2. 在对应的任务中的构建后操作中，下拉选择`Editable Email Notification`\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1abc14189c874a818e5fe42a90371e43~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/594c71d3301544e48f6cc7468724b964~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b633844afb7a43e488cd3ab81d7c08a9~tplv-k3u1fbpfcp-watermark.image?)\n\n至此，jnekins的自动化构建的邮件通知已配置完成，在gitlab点击push event发起构建进行测试。\n\n发送成功的话，可看到如下图的提示：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a26d60de670c48ca991975dc2d20fa20~tplv-k3u1fbpfcp-watermark.image?)\n\n## 总结\n\n经过多款插件的安装配置，逐步掌握了如何上床Spring Boot项目到Gitlab中，并使用Jenkins自动构建任务，另外依托于Docker，让这一切变得更加方便，希望大家都多多思考，让机器自动干活，减少我们IT从业人员的重复、繁琐的工作量。\n\n\n', '小白学习gitlab+jenkins进行自动化构建(docker)之springboot项目', 0, 7, 2, 9, 0, '2023-06-09 16:56:30', '2023-06-09 16:56:30', 0);
INSERT INTO `tb_article` VALUES (17, '小白学习gitlab+jenkins进行自动化构建(docker)之springboot项目', '## 前言\ngitlab和jenkins的安装参考我的另外两篇博客：\n* gitlab安装：[小白搭建gitlab(docker)](https://juejin.cn/post/7032898607686778910)\n* jenkins安装：[小白学习搭建jenkins(docker)](https://juejin.cn/post/7032891246490157093/)\n\n## 在Jenkins上安装必要的插件\n所需插件：`Maven Integration`、`Pipeline Maven Integration`、`Gitlab`、`GitLab Authentication`、`SSH`、`Publish Over SSH`、`Docker`\n\n点击 Manage Jenkins（系统管理） ——> Manage Plugins（插件管理）\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5d15509337b44198064ba2bd41f221e~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Maven插件\n\n点击可选插件 ——> 过滤Maven Integration插件 ——> 勾选Maven Integration和Pipeline Maven Integration ——> 点击直接安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e496dbb12972454789d19546d660c88d~tplv-k3u1fbpfcp-watermark.image?)\n\n如图开始安装插件：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/134fef5f496c468b8dad342454c83b45~tplv-k3u1fbpfcp-watermark.image?)\n\n安装完成后，即可在插件管理下的已安装选项卡下看到刚刚已经安装的插件。\n\n#### 安装Gitlab插件\n\n点击可选插件 ——> 过滤Gitlab插件 ——> 勾选Gitlab和Gitlab Authentication ——> 点击直接安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6171674e55b428c9eba7be7cc2f516c~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装SSH插件和Publish Over SSH插件\n安装Publish Over SSH插件的原因：因为本方式是使用docker启动jenkins服务，所以在jenkins后续执行构建任务时候，需要在build成功后，将服务的jar包（以spring boot服务为例）拷贝到Dockerfile所在服务器的指定目录，进行微服务的启动；所以，此处需要配置SSH服务器的连接，意思就是在jenkins的任务结束后，去执行指定的服务器上的shell命令，做spring boot或cloud服务的镜像的构建，容器的运行，等一系列的事情。\n\n点击可选插件 ——> 过滤SSH插件 ——> 勾选SSH和Publish Over SSH ——> 点击直接安装\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d21ba2054860482b8b07684f48468538~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Docker插件\n\n点击可选插件 ——> 过滤Docker插件 ——> 勾选Docker ——> 点击直接安装\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1501abfe94b431a91e5692c41d12f72~tplv-k3u1fbpfcp-watermark.image?)\n\n插件全部安装完成后，可以重启一下Jenkins。\n\n## 相关配置\n\n#### 添加凭据\n\n点击 Manage Jenkins（系统管理） ——> Manage Credentials（凭据管理）\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0d3890020d34004adb05cab48310dd1~tplv-k3u1fbpfcp-watermark.image?)\n\n点击添加凭据 ——> 输入宿主机服务器的用户名和密码等信息并保存\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8eb6e5330d2140cb9705256fc722dc9d~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 配置SSH remote hosts\n\n这个配置是干什么的呢？配置SSH连接Dockerfile所在服务器的相关信息，并添加凭证，最后测试连接并保存，以备后面使用！！！\n\n点击 Manage Jenkins（系统管理） ——> 系统配置\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3813b66e9134305a1acb1d7515110bd~tplv-k3u1fbpfcp-watermark.image?)\n\n找到配置 ——> 下拉选择SSH remote hosts\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7436757a876049db93e6b255662001f2~tplv-k3u1fbpfcp-watermark.image?)\n\n如下图，输入对应的信息，并校验是否连接成功！成功后，点击应用 ——> 点击保存\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3559c64c918c4355aaff8d136e689da9~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 配置Publish over SSH\n\n找到配置 ——> 下拉选择Publish over SSH，进行相关配置即可。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0bb12f108302405ba90bb33e80fd0d5e~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78ad24f26a2a46b68ea44ea1c6ceb537~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de7ba1ca4a074ad1bb6f6a4b8fe71ee3~tplv-k3u1fbpfcp-watermark.image?)\n\n这里配置的数据，目前只能在Post Steps中选中send files or execute commands over ssh使用，要想能够在execute shell script on remote host using ssh方式中使用，需要再配置一份SSH remote hosts和它配套使用\n\n## 全局工具配置\n\n由于我们要实现的是SpringBoot项目的自动化部署操作，所以需要安装JDK、Git、Maven、Docker。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0dec279d6d44a83b2138cd7663e0995~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装JDK\n\n可以安装多个，根据项目JDK版本需求。\n\n输入自定义JDK名称 ——> 勾选自动安装 ——> 输入Oracle账户、密码 ——> 选择JDK版本 ——> 勾选同意协议\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72aa67fd5a494228840c5bef060e36b8~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Git\n\n输入自定义Git名称 ——> 勾选自动安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b49eb7bd11d48ab9ffce4f29431c216~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Maven\n\n输入自定义名称 ——> 勾选自动安装 ——> 选择版本\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5394195a98b647189dfaa5cd74b1a0b0~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Docker\n\n输入自定义名称 ——> 勾选自动安装\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/893704cbe8fe449fb615534bf9e82cea~tplv-k3u1fbpfcp-watermark.image?)\n\n最后，点击应用 ——> 点击保存即可。\n\n## 新建Jenkins任务\n\n### 点击新建任务，输入名称\n\n注意：本名称必须和项目名称一致，因为本名称会在jenkins工作空间下生成目录，类似于IDEA或Eclipse的工作空间的概念。所以，一般情况下，保证本名称=项目名称=docker镜像名称=docker容器名称 这样能尽可能的减轻jenkins配置的shell命令的复杂性！（空间命名要小写：因为镜像名不允许存在大写字母）\n\n选择构建一个Maven项目（因为是Spring Boot的服务）\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5a510bcf4ac49159f3f3b2960ae4fc5~tplv-k3u1fbpfcp-watermark.image?)\n\n### 源码管理\n\n输入描述信息，源码管理选择Git，从gitlab复制克隆地址（http协议的）粘贴到Repository URL中。未添加凭证会报授权失败的错误。错误如下：\n```\n![]()无法连接仓库：Command \"git ls-remote -h -- http://192.168.57.128:8880/root/video-book-backend.git HEAD\" returned status code 128:\\\nstdout:\\\nstderr: remote: HTTP Basic: Access denied\\\nfatal: Authentication failed for \'http://192.168.57.128:8880/root/video-book-backend.git/\'\n```\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94c2477c80724a959f8bb9f461814f41~tplv-k3u1fbpfcp-watermark.image?)\n\n添加gitlab凭证：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e08c1c343564fda9d5c599e985c38f5~tplv-k3u1fbpfcp-watermark.image?)\n\n### 构建触发器\n\n接下来将会生成供gitlab配置webhook使用的URL和Token，请记录下来，后面会使用。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1016fa1f35f24be7bf16ebe0a503bb8e~tplv-k3u1fbpfcp-watermark.image?)\n\n点击高级，拉下来找到Generate并点击，生成一串Secret Token。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13fb693d0ed14c63b8b613cccc7cd5b9~tplv-k3u1fbpfcp-watermark.image?)\n\n### 添加webhook\n\n前往gitlab，进入要构建的项目，在setting中选择Webhooks，输入URL和Secret Token 这两在上面图中已经给你标注了，去掉Enable SSL verification的勾选。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/904006704c604f6da4f2d1989200d462~tplv-k3u1fbpfcp-watermark.image?)\n\n点击Add webhook，如图表示成功添加了webhook：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6928c377f94748d0b70f57189e42e6cd~tplv-k3u1fbpfcp-watermark.image?)\n\n如果添加不成功解决方案请参考：[解决 Url is blocked: Requests to the local network are not allowed](https://www.cnblogs.com/zhongyuanzhao000/p/11379098.html)\n\n### 构建环境\n\n勾选Add timestamps to the Console Output，等下可以看到控制台打印的信息，这个根据自己的需求勾选。\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/badcdddabcc643b19f5a41fdc9f3416e~tplv-k3u1fbpfcp-watermark.image?)\n\n### Pre Steps(构建之前的步骤)\n\n配置前一步需要做的事情是：清理本项目在jenkins的workspace中的历史文件夹。\n\n你可以不用知道WORKSPACE具体的地址在哪里，因为下方有链接可以查看到当前jenkins中有哪些可用的变量供你使用。\n\n默认WORKSPACE地址：`/var/jenkins_home/workspace`（如果你jenkins是docker启动的，并且挂载了目录在宿主机，那你在宿主机也是可以看到的，即 `/usr/local/docker/workspace`）\n\n本处选择的是执行shell，则表示本处配置的shell命令，是默认在jenkins容器中执行的，而不是在宿主机上。\n\n下拉选择执行 shell：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c2e1bd362944ff2aab0a62646bae53d~tplv-k3u1fbpfcp-watermark.image?)\n\n在执行shell的命令中输入以下命令，设置全局变量：\n```\nSERVER_NAME_1=video-book-backend\necho \"=========================>>>>>>>工作空间WORKSPACE的地址：$WORKSPACE \"\ncd $WORKSPACE\necho \"=========================>>>>>>>进入工作空间WORKSPACE，清除工作空间中原项目的工作空间$SERVER_NAME_1 \"\nrm -rf $SERVER_NAME_1\necho \"=========================>>>>>>>清除工作空间中原项目的工作空间$SERVER_NAME_1 ......成功success\"\n```\n注意：本处的SERVER_NAME_1=jenkins-docker-gitlab-springboot是配置项目的名称(和gitlab中的项目名保持一致)\n\n### Build(构建)\n\n我们是SpringBoot项目，所以用到maven，这里设置一下全局操作，clean项目，并打成jar包，所以这里输入：`clean package`\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a41ff4b5061f48f39de4738c6282ec78~tplv-k3u1fbpfcp-watermark.image?)\n\n### Post Steps(执行任务)\n\n只在jenkins构建成功后，才执行这一步。\n\n因为最后的构建成功的maven项目的jar包是以docker启动服务为目的，所以最后的docker操作，一定是在jenkins容器以外的服务器上运行的，可能是本机宿主机，也可能是远程的服务器，这个根据自己的情况去配置。\n\n本处选择，在远程的SSH执行shell脚本。\n\n选中只有构建成功才执行这些命令，然后选择Execute shell script on remote host using ssh。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c25a57ddb8f4b10b31e4832503d4af2~tplv-k3u1fbpfcp-watermark.image?)\n\nshell命令:\n```\n# =====================================================================================\n# =================================定义初始化变量======================================\n# =====================================================================================\n\n# 操作/项目路径(Dockerfile存放的路径，Dockerfile一般都放在项目的根目录下)\n# 如果Dockerfile放在项目根目录的子目录下，则子目录不能与项目同名\n# 会导致在复制jar包的时候，覆盖子目录为jar包,同时没有扩展名jar,原因我暂时不知道\n# 目前我的做法是将Dockerfile放在项目根目录下\nBASE_PATH=/usr/local/docker/jenkins/workspace/video-book-backend\n\n# jenkins构建好的源jar路径\n# 这个路径是jenkins容器挂载在宿主机上的路径\n# 我的jenkins的目录被我挂载在了/usr/local/docker/jenkins上\nSOURCE_PATH=/usr/local/docker/jenkins/workspace\n\n# docker镜像、docker容器、Dockerfile同目录下的jar名字[用它build生成image的jar]、jenkins的workspace下的项目名称\n# 注意统一名称！！！！！\nSERVER_NAME=video-book-backend\n\n# 容器id  [grep -w 全量匹配容器名] [awk 获取信息行的第一列，即容器ID]  [无论容器启动与否，都获取到]\nCID=$(docker ps -a | grep -w \"$SERVER_NAME\" | awk \'{print $1}\')\n\n# 镜像id  [grep -w 全量匹配镜像名] [awk 获取信息行的第三列，即镜像ID]\nIID=$(docker images | grep -w \"$SERVER_NAME\" | awk \'{print $3}\')\n\n# 源jar完整地址[jenkins构建成功后，会在自己的workspace/项目/target下生成maven构建成功的jar包，获取jar包名的完整路径]\n# 例如：/usr/local/docker/jenkins/workspace/video-book-backend/target/video-book-backend-0.0.1-SNAPSHOT.jar\nSOURCE_JAR_PATH=$(find \"$SOURCE_PATH/$SERVER_NAME/target/\"  -name \"*$SERVER_NAME*.jar\" )\n\nDATE=`date +%Y%m%d%H%M%S`\n\n# =====================================================================================\n# ============================对原本已存在的jar进行备份================================\n# =====================================================================================\n\n# 备份\nfunction backup(){\n    if [ -f \"$BASE_PATH/$SERVER_NAME.jar\" ]; then\n        echo \"=========================>>>>>>>$SERVER_NAME.jar 备份...\"\n            mv $BASE_PATH/$SERVER_NAME.jar $BASE_PATH/backup/$SERVER_NAME-$DATE.jar\n        echo \"=========================>>>>>>>备份老的 $SERVER_NAME.jar 完成\"\n\n    else\n        echo \"=========================>>>>>>>老的$BASE_PATH/$SERVER_NAME.jar不存在，跳过备份\"\n    fi\n}\n\n# =====================================================================================\n# =========================移动最新源jar包到Dockerfile所在目录=========================\n# =====================================================================================\n\n\n \n# 查找源jar文件名，进行重命名，最后将源文件移动到Dockerfile文件所在目录\nfunction transfer(){\n      \n    echo \"=========================>>>>>>>源文件完整地址为 $SOURCE_JAR_PATH\"\n\n    echo \"=========================>>>>>>>重命名源文件\"\n        mv $SOURCE_JAR_PATH  $SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar\n\n    echo \"=========================>>>>>>>最新构建代码 将$SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar 迁移至 $BASE_PATH\"\n        cp $SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar $BASE_PATH\n        \n    echo \"=========================>>>>>>>迁移完成Success\"\n\n}\n \n# =====================================================================================\n# ==================================构建最新镜像=======================================\n# =====================================================================================\n\n# 构建docker镜像\nfunction build(){\n    \n    # 无论镜像存在与否，都停止原容器服务，并移除原容器服务\n    echo \"=========================>>>>>>>停止$SERVER_NAME容器，CID=$CID\"\n    docker stop $CID\n\n    echo \"=========================>>>>>>>移除$SERVER_NAME容器，CID=$CID\"\n    docker rm $CID\n\n    # 无论如何，都去构建新的镜像\n    if [ -n \"$IID\" ]; then\n        echo \"=========================>>>>>>>存在$SERVER_NAME镜像，IID=$IID\"\n\n        echo \"=========================>>>>>>>移除老的$SERVER_NAME镜像，IID=$IID\"\n        \n        docker rmi $IID\n\n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，开始---->\"\n        \n        cd $BASE_PATH\n        docker build -t $SERVER_NAME .\n        \n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，完成---->\"\n\n    else\n        echo \"=========================>>>>>>>不存在$SERVER_NAME镜像，构建新的镜像，开始--->\"\n        \n        cd $BASE_PATH\n        docker build -t $SERVER_NAME .\n        \n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，结束--->\"\n    fi\n}\n \n\n# =====================================================================================\n# ==============================运行docker容器，启动服务===============================\n# =====================================================================================\n\n# 运行docker容器\nfunction run(){\n    backup\n    transfer\n    build\n\n    # 创建容器\n    docker run --name $SERVER_NAME -itd --net=host -v /etc/localtime:/etc/localtime:ro  -v /etc/timezone:/etc/timezone:ro  $SERVER_NAME \n\n}\n \n# 入口\nrun\n```\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e67ba6d7cf14d52b00009c09afc9349~tplv-k3u1fbpfcp-watermark.image?)\n\nOK，到这里基本的任务已经新建成功，至于后续的两个步骤，根据自己的需求自行配置，没有难度的。\n\n点击应用，保存。\n\n### 测试\n\n测试push事件触发自动化构建和部署，点击test下拉选择push events，出现HTTP 200表示OK了。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e85f532d1c2b4643996604347b945f51~tplv-k3u1fbpfcp-watermark.image?)\n\n回到Jenkins可以看到任务列表，查看构建信息等。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f954757d41324660ae01ff5de6afe17e~tplv-k3u1fbpfcp-watermark.image?)\n\n待Jenkins构建成功之后，在服务器上执行命令：`docker ps`，可以看到我们启动起来的 SpringBoot 容器：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8556de2ce136416ea36e817b661c2f80~tplv-k3u1fbpfcp-watermark.image?)\n\n## 邮件通知\n\n有时候团队合作，我们希望能通过邮件通知每一个开发者，项目是否构建成功。jenkins/jenkins:2.332.1默认安装了`# Email Extension Template`这个插件，还需要安装`Email Extension Template`这个插件\n\n系统管理->插件管理->可选插件->搜索`Email Extension Template`\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51c60941d3d3422e88db89b5188a3168~tplv-k3u1fbpfcp-watermark.image?)\n\n直接安装\n\n### 配置Email(Jenkins自带)\n\n#### 2.1 基础信息查询\n\n>找到所要配置邮箱的基础信息，这里以QQ邮箱为例\n\n1. 通过网页端QQ邮箱的设置进入到邮箱客户端设置页面\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f31038ef147f4c728540bc581f64d522~tplv-k3u1fbpfcp-watermark.image?)\n\n2. 找到邮箱的基础信息\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5694801b0ed74685a76cade6b358c5fc~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 2.2 Jenkins邮件通知配置\n\n在Jenkins：`系统管理->系统配置`中，最底部找到`邮件通知`，打开`高级`,注意到在配置的下方有个\"通过发送测试邮件测试配置\"，我们可以讲其勾选，填入邮箱地址，点击`Test configuration`来先测试一下邮件的发送。\n\n> 这边最好先保存一下再测试，否则出错，又得重配。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6420215d674647fb824854fd68a3efd6~tplv-k3u1fbpfcp-watermark.image?)\n\n如果报错如下：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8481f74294404047a2671bc8e2a3297e~tplv-k3u1fbpfcp-watermark.image?)\n\n这是因为我们还需要在设置`Jenkins Location`中配置`系统管理员邮件地址`，此地址要和`邮件通知`中的`用户名`一致\n\n### 配置Email(Extended E-mail Notification)\n\n>记得文章一开头提到的下载Extended插件，没错，Jenkins系统设置里还可以通过`Extended E-mail Notification`对邮件发送进行模板格式的自定义\n\n#### 3.1 基础信息配置\n\n基础信息配置与上述一致,唯一要注意的是这里需要重新生成一个授权码\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cb0934380904b098a035e54297946d4~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 3.2 模板格式配置\n\n接3.1配置继续。这里主要就是配置展示的模板格式，常用的格式化的参数有：\n```\n- $BUILD_STATUS – 构建结果\n- $PROJECT_NAME – 构建脚本名称\n- $BUILD_NUMBER – 构建脚本编号\n- $JOB_DESCRIPTION – 构建项目描述 \n- $CAUSE – 脚本启动原因\n- $BUILD_URL – 脚本构建详情URL地址\n```\n\n这里选择以HTML的格式展示，填入模板：\n```\n<!DOCTYPE html>    \n<html>    \n<head>    \n<meta charset=\"UTF-8\">    \n<title>${ENV, var=\"JOB_NAME\"}-第${BUILD_NUMBER}次构建日志</title>    \n</head>    \n    \n<body leftmargin=\"8\" marginwidth=\"0\" topmargin=\"8\" marginheight=\"4\"    \n    offset=\"0\">    \n    <table width=\"95%\" cellpadding=\"0\" cellspacing=\"0\"  style=\"font-size: 11pt; font-family: Tahoma, Arial, Helvetica, sans-serif\">    \n        <tr>    \n            本邮件由系统自动发出，无需回复！<br/>            \n            各位同事，大家好，以下为${PROJECT_NAME}项目构建信息</br> \n            <td><font color=\"#CC0000\">构建结果 - ${BUILD_STATUS}</font></td>   \n        </tr>    \n        <tr>    \n            <td><br />    \n            <b><font color=\"#0B610B\">构建信息</font></b>    \n            <hr size=\"2\" width=\"100%\" align=\"center\" /></td>    \n        </tr>    \n        <tr>    \n            <td>    \n                <ul>    \n                    <li>项目名称 ： ${PROJECT_NAME}</li>    \n                    <li>构建编号 ： 第${BUILD_NUMBER}次构建</li>    \n                    <li>触发原因： ${CAUSE}</li>    \n                    <li>构建状态： ${BUILD_STATUS}</li>    \n                    <li>构建日志： <a href=\"${BUILD_URL}console\">${BUILD_URL}console</a></li>    \n                    <li>构建  Url ： <a href=\"${BUILD_URL}\">${BUILD_URL}</a></li>    \n                    <li>工作目录 ： <a href=\"${PROJECT_URL}ws\">${PROJECT_URL}ws</a></li>    \n                    <li>项目  Url ： <a href=\"${PROJECT_URL}\">${PROJECT_URL}</a></li>    \n                </ul>    \n\n<h4><font color=\"#0B610B\">失败用例</font></h4>\n<hr size=\"2\" width=\"100%\" />\n$FAILED_TESTS<br/>\n\n<h4><font color=\"#0B610B\">最近提交(#$SVN_REVISION)</font></h4>\n<hr size=\"2\" width=\"100%\" />\n<ul>\n${CHANGES_SINCE_LAST_SUCCESS, reverse=true, format=\"%c\", changesFormat=\"<li>%d [%a] %m</li>\"}\n</ul>\n详细提交: <a href=\"${PROJECT_URL}changes\">${PROJECT_URL}changes</a><br/>\n\n            </td>    \n        </tr>    \n    </table>    \n</body>    \n</html>\n```\n\n如下图：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8b10b649f4943e1944fc094c72a3d2e~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 3.3 触发条件配置\n\n我们还可以在`Default Triggers`中根据自己的需要配置邮件的触发条件\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4328af1e2934c81b61f8c0429b6313b~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16835dfc64334f0e93a6cb7fd262922a~tplv-k3u1fbpfcp-watermark.image?)\n\n>这里为了防止因为构建一直尝试结果均为失败而造成的邮件轰炸，可以设置邮件仅第一次或第二次构建结果为失败时才发送邮件，后续失败的邮件将不再发送。我选择的是每一次失败和构建成功都会发邮件通知\n\n#### 3.4 jenkins的任务中配置邮件通知\n\n1. 在对应的任务中的构建设置中，勾选`E-mail Notification Recipients`\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/224fb406029d46d489cb6192848fdb6e~tplv-k3u1fbpfcp-watermark.image?)\n\n2. 在对应的任务中的构建后操作中，下拉选择`Editable Email Notification`\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1abc14189c874a818e5fe42a90371e43~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/594c71d3301544e48f6cc7468724b964~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b633844afb7a43e488cd3ab81d7c08a9~tplv-k3u1fbpfcp-watermark.image?)\n\n至此，jnekins的自动化构建的邮件通知已配置完成，在gitlab点击push event发起构建进行测试。\n\n发送成功的话，可看到如下图的提示：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a26d60de670c48ca991975dc2d20fa20~tplv-k3u1fbpfcp-watermark.image?)\n\n## 总结\n\n经过多款插件的安装配置，逐步掌握了如何上床Spring Boot项目到Gitlab中，并使用Jenkins自动构建任务，另外依托于Docker，让这一切变得更加方便，希望大家都多多思考，让机器自动干活，减少我们IT从业人员的重复、繁琐的工作量。\n\n\n', '小白学习gitlab+jenkins进行自动化构建(docker)之springboot项目', 0, 7, 2, 9, 0, '2023-06-09 16:56:30', '2023-06-09 16:56:30', 0);
INSERT INTO `tb_article` VALUES (18, '小白学习gitlab+jenkins进行自动化构建(docker)之springboot项目', '## 前言\ngitlab和jenkins的安装参考我的另外两篇博客：\n* gitlab安装：[小白搭建gitlab(docker)](https://juejin.cn/post/7032898607686778910)\n* jenkins安装：[小白学习搭建jenkins(docker)](https://juejin.cn/post/7032891246490157093/)\n\n## 在Jenkins上安装必要的插件\n所需插件：`Maven Integration`、`Pipeline Maven Integration`、`Gitlab`、`GitLab Authentication`、`SSH`、`Publish Over SSH`、`Docker`\n\n点击 Manage Jenkins（系统管理） ——> Manage Plugins（插件管理）\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5d15509337b44198064ba2bd41f221e~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Maven插件\n\n点击可选插件 ——> 过滤Maven Integration插件 ——> 勾选Maven Integration和Pipeline Maven Integration ——> 点击直接安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e496dbb12972454789d19546d660c88d~tplv-k3u1fbpfcp-watermark.image?)\n\n如图开始安装插件：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/134fef5f496c468b8dad342454c83b45~tplv-k3u1fbpfcp-watermark.image?)\n\n安装完成后，即可在插件管理下的已安装选项卡下看到刚刚已经安装的插件。\n\n#### 安装Gitlab插件\n\n点击可选插件 ——> 过滤Gitlab插件 ——> 勾选Gitlab和Gitlab Authentication ——> 点击直接安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6171674e55b428c9eba7be7cc2f516c~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装SSH插件和Publish Over SSH插件\n安装Publish Over SSH插件的原因：因为本方式是使用docker启动jenkins服务，所以在jenkins后续执行构建任务时候，需要在build成功后，将服务的jar包（以spring boot服务为例）拷贝到Dockerfile所在服务器的指定目录，进行微服务的启动；所以，此处需要配置SSH服务器的连接，意思就是在jenkins的任务结束后，去执行指定的服务器上的shell命令，做spring boot或cloud服务的镜像的构建，容器的运行，等一系列的事情。\n\n点击可选插件 ——> 过滤SSH插件 ——> 勾选SSH和Publish Over SSH ——> 点击直接安装\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d21ba2054860482b8b07684f48468538~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Docker插件\n\n点击可选插件 ——> 过滤Docker插件 ——> 勾选Docker ——> 点击直接安装\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1501abfe94b431a91e5692c41d12f72~tplv-k3u1fbpfcp-watermark.image?)\n\n插件全部安装完成后，可以重启一下Jenkins。\n\n## 相关配置\n\n#### 添加凭据\n\n点击 Manage Jenkins（系统管理） ——> Manage Credentials（凭据管理）\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0d3890020d34004adb05cab48310dd1~tplv-k3u1fbpfcp-watermark.image?)\n\n点击添加凭据 ——> 输入宿主机服务器的用户名和密码等信息并保存\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8eb6e5330d2140cb9705256fc722dc9d~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 配置SSH remote hosts\n\n这个配置是干什么的呢？配置SSH连接Dockerfile所在服务器的相关信息，并添加凭证，最后测试连接并保存，以备后面使用！！！\n\n点击 Manage Jenkins（系统管理） ——> 系统配置\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3813b66e9134305a1acb1d7515110bd~tplv-k3u1fbpfcp-watermark.image?)\n\n找到配置 ——> 下拉选择SSH remote hosts\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7436757a876049db93e6b255662001f2~tplv-k3u1fbpfcp-watermark.image?)\n\n如下图，输入对应的信息，并校验是否连接成功！成功后，点击应用 ——> 点击保存\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3559c64c918c4355aaff8d136e689da9~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 配置Publish over SSH\n\n找到配置 ——> 下拉选择Publish over SSH，进行相关配置即可。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0bb12f108302405ba90bb33e80fd0d5e~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78ad24f26a2a46b68ea44ea1c6ceb537~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de7ba1ca4a074ad1bb6f6a4b8fe71ee3~tplv-k3u1fbpfcp-watermark.image?)\n\n这里配置的数据，目前只能在Post Steps中选中send files or execute commands over ssh使用，要想能够在execute shell script on remote host using ssh方式中使用，需要再配置一份SSH remote hosts和它配套使用\n\n## 全局工具配置\n\n由于我们要实现的是SpringBoot项目的自动化部署操作，所以需要安装JDK、Git、Maven、Docker。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0dec279d6d44a83b2138cd7663e0995~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装JDK\n\n可以安装多个，根据项目JDK版本需求。\n\n输入自定义JDK名称 ——> 勾选自动安装 ——> 输入Oracle账户、密码 ——> 选择JDK版本 ——> 勾选同意协议\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72aa67fd5a494228840c5bef060e36b8~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Git\n\n输入自定义Git名称 ——> 勾选自动安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b49eb7bd11d48ab9ffce4f29431c216~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Maven\n\n输入自定义名称 ——> 勾选自动安装 ——> 选择版本\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5394195a98b647189dfaa5cd74b1a0b0~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Docker\n\n输入自定义名称 ——> 勾选自动安装\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/893704cbe8fe449fb615534bf9e82cea~tplv-k3u1fbpfcp-watermark.image?)\n\n最后，点击应用 ——> 点击保存即可。\n\n## 新建Jenkins任务\n\n### 点击新建任务，输入名称\n\n注意：本名称必须和项目名称一致，因为本名称会在jenkins工作空间下生成目录，类似于IDEA或Eclipse的工作空间的概念。所以，一般情况下，保证本名称=项目名称=docker镜像名称=docker容器名称 这样能尽可能的减轻jenkins配置的shell命令的复杂性！（空间命名要小写：因为镜像名不允许存在大写字母）\n\n选择构建一个Maven项目（因为是Spring Boot的服务）\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5a510bcf4ac49159f3f3b2960ae4fc5~tplv-k3u1fbpfcp-watermark.image?)\n\n### 源码管理\n\n输入描述信息，源码管理选择Git，从gitlab复制克隆地址（http协议的）粘贴到Repository URL中。未添加凭证会报授权失败的错误。错误如下：\n```\n![]()无法连接仓库：Command \"git ls-remote -h -- http://192.168.57.128:8880/root/video-book-backend.git HEAD\" returned status code 128:\\\nstdout:\\\nstderr: remote: HTTP Basic: Access denied\\\nfatal: Authentication failed for \'http://192.168.57.128:8880/root/video-book-backend.git/\'\n```\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94c2477c80724a959f8bb9f461814f41~tplv-k3u1fbpfcp-watermark.image?)\n\n添加gitlab凭证：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e08c1c343564fda9d5c599e985c38f5~tplv-k3u1fbpfcp-watermark.image?)\n\n### 构建触发器\n\n接下来将会生成供gitlab配置webhook使用的URL和Token，请记录下来，后面会使用。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1016fa1f35f24be7bf16ebe0a503bb8e~tplv-k3u1fbpfcp-watermark.image?)\n\n点击高级，拉下来找到Generate并点击，生成一串Secret Token。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13fb693d0ed14c63b8b613cccc7cd5b9~tplv-k3u1fbpfcp-watermark.image?)\n\n### 添加webhook\n\n前往gitlab，进入要构建的项目，在setting中选择Webhooks，输入URL和Secret Token 这两在上面图中已经给你标注了，去掉Enable SSL verification的勾选。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/904006704c604f6da4f2d1989200d462~tplv-k3u1fbpfcp-watermark.image?)\n\n点击Add webhook，如图表示成功添加了webhook：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6928c377f94748d0b70f57189e42e6cd~tplv-k3u1fbpfcp-watermark.image?)\n\n如果添加不成功解决方案请参考：[解决 Url is blocked: Requests to the local network are not allowed](https://www.cnblogs.com/zhongyuanzhao000/p/11379098.html)\n\n### 构建环境\n\n勾选Add timestamps to the Console Output，等下可以看到控制台打印的信息，这个根据自己的需求勾选。\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/badcdddabcc643b19f5a41fdc9f3416e~tplv-k3u1fbpfcp-watermark.image?)\n\n### Pre Steps(构建之前的步骤)\n\n配置前一步需要做的事情是：清理本项目在jenkins的workspace中的历史文件夹。\n\n你可以不用知道WORKSPACE具体的地址在哪里，因为下方有链接可以查看到当前jenkins中有哪些可用的变量供你使用。\n\n默认WORKSPACE地址：`/var/jenkins_home/workspace`（如果你jenkins是docker启动的，并且挂载了目录在宿主机，那你在宿主机也是可以看到的，即 `/usr/local/docker/workspace`）\n\n本处选择的是执行shell，则表示本处配置的shell命令，是默认在jenkins容器中执行的，而不是在宿主机上。\n\n下拉选择执行 shell：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c2e1bd362944ff2aab0a62646bae53d~tplv-k3u1fbpfcp-watermark.image?)\n\n在执行shell的命令中输入以下命令，设置全局变量：\n```\nSERVER_NAME_1=video-book-backend\necho \"=========================>>>>>>>工作空间WORKSPACE的地址：$WORKSPACE \"\ncd $WORKSPACE\necho \"=========================>>>>>>>进入工作空间WORKSPACE，清除工作空间中原项目的工作空间$SERVER_NAME_1 \"\nrm -rf $SERVER_NAME_1\necho \"=========================>>>>>>>清除工作空间中原项目的工作空间$SERVER_NAME_1 ......成功success\"\n```\n注意：本处的SERVER_NAME_1=jenkins-docker-gitlab-springboot是配置项目的名称(和gitlab中的项目名保持一致)\n\n### Build(构建)\n\n我们是SpringBoot项目，所以用到maven，这里设置一下全局操作，clean项目，并打成jar包，所以这里输入：`clean package`\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a41ff4b5061f48f39de4738c6282ec78~tplv-k3u1fbpfcp-watermark.image?)\n\n### Post Steps(执行任务)\n\n只在jenkins构建成功后，才执行这一步。\n\n因为最后的构建成功的maven项目的jar包是以docker启动服务为目的，所以最后的docker操作，一定是在jenkins容器以外的服务器上运行的，可能是本机宿主机，也可能是远程的服务器，这个根据自己的情况去配置。\n\n本处选择，在远程的SSH执行shell脚本。\n\n选中只有构建成功才执行这些命令，然后选择Execute shell script on remote host using ssh。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c25a57ddb8f4b10b31e4832503d4af2~tplv-k3u1fbpfcp-watermark.image?)\n\nshell命令:\n```\n# =====================================================================================\n# =================================定义初始化变量======================================\n# =====================================================================================\n\n# 操作/项目路径(Dockerfile存放的路径，Dockerfile一般都放在项目的根目录下)\n# 如果Dockerfile放在项目根目录的子目录下，则子目录不能与项目同名\n# 会导致在复制jar包的时候，覆盖子目录为jar包,同时没有扩展名jar,原因我暂时不知道\n# 目前我的做法是将Dockerfile放在项目根目录下\nBASE_PATH=/usr/local/docker/jenkins/workspace/video-book-backend\n\n# jenkins构建好的源jar路径\n# 这个路径是jenkins容器挂载在宿主机上的路径\n# 我的jenkins的目录被我挂载在了/usr/local/docker/jenkins上\nSOURCE_PATH=/usr/local/docker/jenkins/workspace\n\n# docker镜像、docker容器、Dockerfile同目录下的jar名字[用它build生成image的jar]、jenkins的workspace下的项目名称\n# 注意统一名称！！！！！\nSERVER_NAME=video-book-backend\n\n# 容器id  [grep -w 全量匹配容器名] [awk 获取信息行的第一列，即容器ID]  [无论容器启动与否，都获取到]\nCID=$(docker ps -a | grep -w \"$SERVER_NAME\" | awk \'{print $1}\')\n\n# 镜像id  [grep -w 全量匹配镜像名] [awk 获取信息行的第三列，即镜像ID]\nIID=$(docker images | grep -w \"$SERVER_NAME\" | awk \'{print $3}\')\n\n# 源jar完整地址[jenkins构建成功后，会在自己的workspace/项目/target下生成maven构建成功的jar包，获取jar包名的完整路径]\n# 例如：/usr/local/docker/jenkins/workspace/video-book-backend/target/video-book-backend-0.0.1-SNAPSHOT.jar\nSOURCE_JAR_PATH=$(find \"$SOURCE_PATH/$SERVER_NAME/target/\"  -name \"*$SERVER_NAME*.jar\" )\n\nDATE=`date +%Y%m%d%H%M%S`\n\n# =====================================================================================\n# ============================对原本已存在的jar进行备份================================\n# =====================================================================================\n\n# 备份\nfunction backup(){\n    if [ -f \"$BASE_PATH/$SERVER_NAME.jar\" ]; then\n        echo \"=========================>>>>>>>$SERVER_NAME.jar 备份...\"\n            mv $BASE_PATH/$SERVER_NAME.jar $BASE_PATH/backup/$SERVER_NAME-$DATE.jar\n        echo \"=========================>>>>>>>备份老的 $SERVER_NAME.jar 完成\"\n\n    else\n        echo \"=========================>>>>>>>老的$BASE_PATH/$SERVER_NAME.jar不存在，跳过备份\"\n    fi\n}\n\n# =====================================================================================\n# =========================移动最新源jar包到Dockerfile所在目录=========================\n# =====================================================================================\n\n\n \n# 查找源jar文件名，进行重命名，最后将源文件移动到Dockerfile文件所在目录\nfunction transfer(){\n      \n    echo \"=========================>>>>>>>源文件完整地址为 $SOURCE_JAR_PATH\"\n\n    echo \"=========================>>>>>>>重命名源文件\"\n        mv $SOURCE_JAR_PATH  $SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar\n\n    echo \"=========================>>>>>>>最新构建代码 将$SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar 迁移至 $BASE_PATH\"\n        cp $SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar $BASE_PATH\n        \n    echo \"=========================>>>>>>>迁移完成Success\"\n\n}\n \n# =====================================================================================\n# ==================================构建最新镜像=======================================\n# =====================================================================================\n\n# 构建docker镜像\nfunction build(){\n    \n    # 无论镜像存在与否，都停止原容器服务，并移除原容器服务\n    echo \"=========================>>>>>>>停止$SERVER_NAME容器，CID=$CID\"\n    docker stop $CID\n\n    echo \"=========================>>>>>>>移除$SERVER_NAME容器，CID=$CID\"\n    docker rm $CID\n\n    # 无论如何，都去构建新的镜像\n    if [ -n \"$IID\" ]; then\n        echo \"=========================>>>>>>>存在$SERVER_NAME镜像，IID=$IID\"\n\n        echo \"=========================>>>>>>>移除老的$SERVER_NAME镜像，IID=$IID\"\n        \n        docker rmi $IID\n\n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，开始---->\"\n        \n        cd $BASE_PATH\n        docker build -t $SERVER_NAME .\n        \n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，完成---->\"\n\n    else\n        echo \"=========================>>>>>>>不存在$SERVER_NAME镜像，构建新的镜像，开始--->\"\n        \n        cd $BASE_PATH\n        docker build -t $SERVER_NAME .\n        \n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，结束--->\"\n    fi\n}\n \n\n# =====================================================================================\n# ==============================运行docker容器，启动服务===============================\n# =====================================================================================\n\n# 运行docker容器\nfunction run(){\n    backup\n    transfer\n    build\n\n    # 创建容器\n    docker run --name $SERVER_NAME -itd --net=host -v /etc/localtime:/etc/localtime:ro  -v /etc/timezone:/etc/timezone:ro  $SERVER_NAME \n\n}\n \n# 入口\nrun\n```\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e67ba6d7cf14d52b00009c09afc9349~tplv-k3u1fbpfcp-watermark.image?)\n\nOK，到这里基本的任务已经新建成功，至于后续的两个步骤，根据自己的需求自行配置，没有难度的。\n\n点击应用，保存。\n\n### 测试\n\n测试push事件触发自动化构建和部署，点击test下拉选择push events，出现HTTP 200表示OK了。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e85f532d1c2b4643996604347b945f51~tplv-k3u1fbpfcp-watermark.image?)\n\n回到Jenkins可以看到任务列表，查看构建信息等。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f954757d41324660ae01ff5de6afe17e~tplv-k3u1fbpfcp-watermark.image?)\n\n待Jenkins构建成功之后，在服务器上执行命令：`docker ps`，可以看到我们启动起来的 SpringBoot 容器：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8556de2ce136416ea36e817b661c2f80~tplv-k3u1fbpfcp-watermark.image?)\n\n## 邮件通知\n\n有时候团队合作，我们希望能通过邮件通知每一个开发者，项目是否构建成功。jenkins/jenkins:2.332.1默认安装了`# Email Extension Template`这个插件，还需要安装`Email Extension Template`这个插件\n\n系统管理->插件管理->可选插件->搜索`Email Extension Template`\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51c60941d3d3422e88db89b5188a3168~tplv-k3u1fbpfcp-watermark.image?)\n\n直接安装\n\n### 配置Email(Jenkins自带)\n\n#### 2.1 基础信息查询\n\n>找到所要配置邮箱的基础信息，这里以QQ邮箱为例\n\n1. 通过网页端QQ邮箱的设置进入到邮箱客户端设置页面\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f31038ef147f4c728540bc581f64d522~tplv-k3u1fbpfcp-watermark.image?)\n\n2. 找到邮箱的基础信息\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5694801b0ed74685a76cade6b358c5fc~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 2.2 Jenkins邮件通知配置\n\n在Jenkins：`系统管理->系统配置`中，最底部找到`邮件通知`，打开`高级`,注意到在配置的下方有个\"通过发送测试邮件测试配置\"，我们可以讲其勾选，填入邮箱地址，点击`Test configuration`来先测试一下邮件的发送。\n\n> 这边最好先保存一下再测试，否则出错，又得重配。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6420215d674647fb824854fd68a3efd6~tplv-k3u1fbpfcp-watermark.image?)\n\n如果报错如下：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8481f74294404047a2671bc8e2a3297e~tplv-k3u1fbpfcp-watermark.image?)\n\n这是因为我们还需要在设置`Jenkins Location`中配置`系统管理员邮件地址`，此地址要和`邮件通知`中的`用户名`一致\n\n### 配置Email(Extended E-mail Notification)\n\n>记得文章一开头提到的下载Extended插件，没错，Jenkins系统设置里还可以通过`Extended E-mail Notification`对邮件发送进行模板格式的自定义\n\n#### 3.1 基础信息配置\n\n基础信息配置与上述一致,唯一要注意的是这里需要重新生成一个授权码\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cb0934380904b098a035e54297946d4~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 3.2 模板格式配置\n\n接3.1配置继续。这里主要就是配置展示的模板格式，常用的格式化的参数有：\n```\n- $BUILD_STATUS – 构建结果\n- $PROJECT_NAME – 构建脚本名称\n- $BUILD_NUMBER – 构建脚本编号\n- $JOB_DESCRIPTION – 构建项目描述 \n- $CAUSE – 脚本启动原因\n- $BUILD_URL – 脚本构建详情URL地址\n```\n\n这里选择以HTML的格式展示，填入模板：\n```\n<!DOCTYPE html>    \n<html>    \n<head>    \n<meta charset=\"UTF-8\">    \n<title>${ENV, var=\"JOB_NAME\"}-第${BUILD_NUMBER}次构建日志</title>    \n</head>    \n    \n<body leftmargin=\"8\" marginwidth=\"0\" topmargin=\"8\" marginheight=\"4\"    \n    offset=\"0\">    \n    <table width=\"95%\" cellpadding=\"0\" cellspacing=\"0\"  style=\"font-size: 11pt; font-family: Tahoma, Arial, Helvetica, sans-serif\">    \n        <tr>    \n            本邮件由系统自动发出，无需回复！<br/>            \n            各位同事，大家好，以下为${PROJECT_NAME}项目构建信息</br> \n            <td><font color=\"#CC0000\">构建结果 - ${BUILD_STATUS}</font></td>   \n        </tr>    \n        <tr>    \n            <td><br />    \n            <b><font color=\"#0B610B\">构建信息</font></b>    \n            <hr size=\"2\" width=\"100%\" align=\"center\" /></td>    \n        </tr>    \n        <tr>    \n            <td>    \n                <ul>    \n                    <li>项目名称 ： ${PROJECT_NAME}</li>    \n                    <li>构建编号 ： 第${BUILD_NUMBER}次构建</li>    \n                    <li>触发原因： ${CAUSE}</li>    \n                    <li>构建状态： ${BUILD_STATUS}</li>    \n                    <li>构建日志： <a href=\"${BUILD_URL}console\">${BUILD_URL}console</a></li>    \n                    <li>构建  Url ： <a href=\"${BUILD_URL}\">${BUILD_URL}</a></li>    \n                    <li>工作目录 ： <a href=\"${PROJECT_URL}ws\">${PROJECT_URL}ws</a></li>    \n                    <li>项目  Url ： <a href=\"${PROJECT_URL}\">${PROJECT_URL}</a></li>    \n                </ul>    \n\n<h4><font color=\"#0B610B\">失败用例</font></h4>\n<hr size=\"2\" width=\"100%\" />\n$FAILED_TESTS<br/>\n\n<h4><font color=\"#0B610B\">最近提交(#$SVN_REVISION)</font></h4>\n<hr size=\"2\" width=\"100%\" />\n<ul>\n${CHANGES_SINCE_LAST_SUCCESS, reverse=true, format=\"%c\", changesFormat=\"<li>%d [%a] %m</li>\"}\n</ul>\n详细提交: <a href=\"${PROJECT_URL}changes\">${PROJECT_URL}changes</a><br/>\n\n            </td>    \n        </tr>    \n    </table>    \n</body>    \n</html>\n```\n\n如下图：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8b10b649f4943e1944fc094c72a3d2e~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 3.3 触发条件配置\n\n我们还可以在`Default Triggers`中根据自己的需要配置邮件的触发条件\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4328af1e2934c81b61f8c0429b6313b~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16835dfc64334f0e93a6cb7fd262922a~tplv-k3u1fbpfcp-watermark.image?)\n\n>这里为了防止因为构建一直尝试结果均为失败而造成的邮件轰炸，可以设置邮件仅第一次或第二次构建结果为失败时才发送邮件，后续失败的邮件将不再发送。我选择的是每一次失败和构建成功都会发邮件通知\n\n#### 3.4 jenkins的任务中配置邮件通知\n\n1. 在对应的任务中的构建设置中，勾选`E-mail Notification Recipients`\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/224fb406029d46d489cb6192848fdb6e~tplv-k3u1fbpfcp-watermark.image?)\n\n2. 在对应的任务中的构建后操作中，下拉选择`Editable Email Notification`\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1abc14189c874a818e5fe42a90371e43~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/594c71d3301544e48f6cc7468724b964~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b633844afb7a43e488cd3ab81d7c08a9~tplv-k3u1fbpfcp-watermark.image?)\n\n至此，jnekins的自动化构建的邮件通知已配置完成，在gitlab点击push event发起构建进行测试。\n\n发送成功的话，可看到如下图的提示：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a26d60de670c48ca991975dc2d20fa20~tplv-k3u1fbpfcp-watermark.image?)\n\n## 总结\n\n经过多款插件的安装配置，逐步掌握了如何上床Spring Boot项目到Gitlab中，并使用Jenkins自动构建任务，另外依托于Docker，让这一切变得更加方便，希望大家都多多思考，让机器自动干活，减少我们IT从业人员的重复、繁琐的工作量。\n\n\n', '小白学习gitlab+jenkins进行自动化构建(docker)之springboot项目', 0, 7, 2, 9, 0, '2023-06-09 16:56:30', '2023-06-09 16:56:30', 0);
INSERT INTO `tb_article` VALUES (19, '小白学习gitlab+jenkins进行自动化构建(docker)之springboot项目', '## 前言\ngitlab和jenkins的安装参考我的另外两篇博客：\n* gitlab安装：[小白搭建gitlab(docker)](https://juejin.cn/post/7032898607686778910)\n* jenkins安装：[小白学习搭建jenkins(docker)](https://juejin.cn/post/7032891246490157093/)\n\n## 在Jenkins上安装必要的插件\n所需插件：`Maven Integration`、`Pipeline Maven Integration`、`Gitlab`、`GitLab Authentication`、`SSH`、`Publish Over SSH`、`Docker`\n\n点击 Manage Jenkins（系统管理） ——> Manage Plugins（插件管理）\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5d15509337b44198064ba2bd41f221e~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Maven插件\n\n点击可选插件 ——> 过滤Maven Integration插件 ——> 勾选Maven Integration和Pipeline Maven Integration ——> 点击直接安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e496dbb12972454789d19546d660c88d~tplv-k3u1fbpfcp-watermark.image?)\n\n如图开始安装插件：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/134fef5f496c468b8dad342454c83b45~tplv-k3u1fbpfcp-watermark.image?)\n\n安装完成后，即可在插件管理下的已安装选项卡下看到刚刚已经安装的插件。\n\n#### 安装Gitlab插件\n\n点击可选插件 ——> 过滤Gitlab插件 ——> 勾选Gitlab和Gitlab Authentication ——> 点击直接安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6171674e55b428c9eba7be7cc2f516c~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装SSH插件和Publish Over SSH插件\n安装Publish Over SSH插件的原因：因为本方式是使用docker启动jenkins服务，所以在jenkins后续执行构建任务时候，需要在build成功后，将服务的jar包（以spring boot服务为例）拷贝到Dockerfile所在服务器的指定目录，进行微服务的启动；所以，此处需要配置SSH服务器的连接，意思就是在jenkins的任务结束后，去执行指定的服务器上的shell命令，做spring boot或cloud服务的镜像的构建，容器的运行，等一系列的事情。\n\n点击可选插件 ——> 过滤SSH插件 ——> 勾选SSH和Publish Over SSH ——> 点击直接安装\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d21ba2054860482b8b07684f48468538~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Docker插件\n\n点击可选插件 ——> 过滤Docker插件 ——> 勾选Docker ——> 点击直接安装\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1501abfe94b431a91e5692c41d12f72~tplv-k3u1fbpfcp-watermark.image?)\n\n插件全部安装完成后，可以重启一下Jenkins。\n\n## 相关配置\n\n#### 添加凭据\n\n点击 Manage Jenkins（系统管理） ——> Manage Credentials（凭据管理）\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0d3890020d34004adb05cab48310dd1~tplv-k3u1fbpfcp-watermark.image?)\n\n点击添加凭据 ——> 输入宿主机服务器的用户名和密码等信息并保存\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8eb6e5330d2140cb9705256fc722dc9d~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 配置SSH remote hosts\n\n这个配置是干什么的呢？配置SSH连接Dockerfile所在服务器的相关信息，并添加凭证，最后测试连接并保存，以备后面使用！！！\n\n点击 Manage Jenkins（系统管理） ——> 系统配置\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3813b66e9134305a1acb1d7515110bd~tplv-k3u1fbpfcp-watermark.image?)\n\n找到配置 ——> 下拉选择SSH remote hosts\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7436757a876049db93e6b255662001f2~tplv-k3u1fbpfcp-watermark.image?)\n\n如下图，输入对应的信息，并校验是否连接成功！成功后，点击应用 ——> 点击保存\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3559c64c918c4355aaff8d136e689da9~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 配置Publish over SSH\n\n找到配置 ——> 下拉选择Publish over SSH，进行相关配置即可。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0bb12f108302405ba90bb33e80fd0d5e~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78ad24f26a2a46b68ea44ea1c6ceb537~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de7ba1ca4a074ad1bb6f6a4b8fe71ee3~tplv-k3u1fbpfcp-watermark.image?)\n\n这里配置的数据，目前只能在Post Steps中选中send files or execute commands over ssh使用，要想能够在execute shell script on remote host using ssh方式中使用，需要再配置一份SSH remote hosts和它配套使用\n\n## 全局工具配置\n\n由于我们要实现的是SpringBoot项目的自动化部署操作，所以需要安装JDK、Git、Maven、Docker。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0dec279d6d44a83b2138cd7663e0995~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装JDK\n\n可以安装多个，根据项目JDK版本需求。\n\n输入自定义JDK名称 ——> 勾选自动安装 ——> 输入Oracle账户、密码 ——> 选择JDK版本 ——> 勾选同意协议\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72aa67fd5a494228840c5bef060e36b8~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Git\n\n输入自定义Git名称 ——> 勾选自动安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b49eb7bd11d48ab9ffce4f29431c216~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Maven\n\n输入自定义名称 ——> 勾选自动安装 ——> 选择版本\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5394195a98b647189dfaa5cd74b1a0b0~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Docker\n\n输入自定义名称 ——> 勾选自动安装\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/893704cbe8fe449fb615534bf9e82cea~tplv-k3u1fbpfcp-watermark.image?)\n\n最后，点击应用 ——> 点击保存即可。\n\n## 新建Jenkins任务\n\n### 点击新建任务，输入名称\n\n注意：本名称必须和项目名称一致，因为本名称会在jenkins工作空间下生成目录，类似于IDEA或Eclipse的工作空间的概念。所以，一般情况下，保证本名称=项目名称=docker镜像名称=docker容器名称 这样能尽可能的减轻jenkins配置的shell命令的复杂性！（空间命名要小写：因为镜像名不允许存在大写字母）\n\n选择构建一个Maven项目（因为是Spring Boot的服务）\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5a510bcf4ac49159f3f3b2960ae4fc5~tplv-k3u1fbpfcp-watermark.image?)\n\n### 源码管理\n\n输入描述信息，源码管理选择Git，从gitlab复制克隆地址（http协议的）粘贴到Repository URL中。未添加凭证会报授权失败的错误。错误如下：\n```\n![]()无法连接仓库：Command \"git ls-remote -h -- http://192.168.57.128:8880/root/video-book-backend.git HEAD\" returned status code 128:\\\nstdout:\\\nstderr: remote: HTTP Basic: Access denied\\\nfatal: Authentication failed for \'http://192.168.57.128:8880/root/video-book-backend.git/\'\n```\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94c2477c80724a959f8bb9f461814f41~tplv-k3u1fbpfcp-watermark.image?)\n\n添加gitlab凭证：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e08c1c343564fda9d5c599e985c38f5~tplv-k3u1fbpfcp-watermark.image?)\n\n### 构建触发器\n\n接下来将会生成供gitlab配置webhook使用的URL和Token，请记录下来，后面会使用。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1016fa1f35f24be7bf16ebe0a503bb8e~tplv-k3u1fbpfcp-watermark.image?)\n\n点击高级，拉下来找到Generate并点击，生成一串Secret Token。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13fb693d0ed14c63b8b613cccc7cd5b9~tplv-k3u1fbpfcp-watermark.image?)\n\n### 添加webhook\n\n前往gitlab，进入要构建的项目，在setting中选择Webhooks，输入URL和Secret Token 这两在上面图中已经给你标注了，去掉Enable SSL verification的勾选。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/904006704c604f6da4f2d1989200d462~tplv-k3u1fbpfcp-watermark.image?)\n\n点击Add webhook，如图表示成功添加了webhook：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6928c377f94748d0b70f57189e42e6cd~tplv-k3u1fbpfcp-watermark.image?)\n\n如果添加不成功解决方案请参考：[解决 Url is blocked: Requests to the local network are not allowed](https://www.cnblogs.com/zhongyuanzhao000/p/11379098.html)\n\n### 构建环境\n\n勾选Add timestamps to the Console Output，等下可以看到控制台打印的信息，这个根据自己的需求勾选。\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/badcdddabcc643b19f5a41fdc9f3416e~tplv-k3u1fbpfcp-watermark.image?)\n\n### Pre Steps(构建之前的步骤)\n\n配置前一步需要做的事情是：清理本项目在jenkins的workspace中的历史文件夹。\n\n你可以不用知道WORKSPACE具体的地址在哪里，因为下方有链接可以查看到当前jenkins中有哪些可用的变量供你使用。\n\n默认WORKSPACE地址：`/var/jenkins_home/workspace`（如果你jenkins是docker启动的，并且挂载了目录在宿主机，那你在宿主机也是可以看到的，即 `/usr/local/docker/workspace`）\n\n本处选择的是执行shell，则表示本处配置的shell命令，是默认在jenkins容器中执行的，而不是在宿主机上。\n\n下拉选择执行 shell：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c2e1bd362944ff2aab0a62646bae53d~tplv-k3u1fbpfcp-watermark.image?)\n\n在执行shell的命令中输入以下命令，设置全局变量：\n```\nSERVER_NAME_1=video-book-backend\necho \"=========================>>>>>>>工作空间WORKSPACE的地址：$WORKSPACE \"\ncd $WORKSPACE\necho \"=========================>>>>>>>进入工作空间WORKSPACE，清除工作空间中原项目的工作空间$SERVER_NAME_1 \"\nrm -rf $SERVER_NAME_1\necho \"=========================>>>>>>>清除工作空间中原项目的工作空间$SERVER_NAME_1 ......成功success\"\n```\n注意：本处的SERVER_NAME_1=jenkins-docker-gitlab-springboot是配置项目的名称(和gitlab中的项目名保持一致)\n\n### Build(构建)\n\n我们是SpringBoot项目，所以用到maven，这里设置一下全局操作，clean项目，并打成jar包，所以这里输入：`clean package`\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a41ff4b5061f48f39de4738c6282ec78~tplv-k3u1fbpfcp-watermark.image?)\n\n### Post Steps(执行任务)\n\n只在jenkins构建成功后，才执行这一步。\n\n因为最后的构建成功的maven项目的jar包是以docker启动服务为目的，所以最后的docker操作，一定是在jenkins容器以外的服务器上运行的，可能是本机宿主机，也可能是远程的服务器，这个根据自己的情况去配置。\n\n本处选择，在远程的SSH执行shell脚本。\n\n选中只有构建成功才执行这些命令，然后选择Execute shell script on remote host using ssh。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c25a57ddb8f4b10b31e4832503d4af2~tplv-k3u1fbpfcp-watermark.image?)\n\nshell命令:\n```\n# =====================================================================================\n# =================================定义初始化变量======================================\n# =====================================================================================\n\n# 操作/项目路径(Dockerfile存放的路径，Dockerfile一般都放在项目的根目录下)\n# 如果Dockerfile放在项目根目录的子目录下，则子目录不能与项目同名\n# 会导致在复制jar包的时候，覆盖子目录为jar包,同时没有扩展名jar,原因我暂时不知道\n# 目前我的做法是将Dockerfile放在项目根目录下\nBASE_PATH=/usr/local/docker/jenkins/workspace/video-book-backend\n\n# jenkins构建好的源jar路径\n# 这个路径是jenkins容器挂载在宿主机上的路径\n# 我的jenkins的目录被我挂载在了/usr/local/docker/jenkins上\nSOURCE_PATH=/usr/local/docker/jenkins/workspace\n\n# docker镜像、docker容器、Dockerfile同目录下的jar名字[用它build生成image的jar]、jenkins的workspace下的项目名称\n# 注意统一名称！！！！！\nSERVER_NAME=video-book-backend\n\n# 容器id  [grep -w 全量匹配容器名] [awk 获取信息行的第一列，即容器ID]  [无论容器启动与否，都获取到]\nCID=$(docker ps -a | grep -w \"$SERVER_NAME\" | awk \'{print $1}\')\n\n# 镜像id  [grep -w 全量匹配镜像名] [awk 获取信息行的第三列，即镜像ID]\nIID=$(docker images | grep -w \"$SERVER_NAME\" | awk \'{print $3}\')\n\n# 源jar完整地址[jenkins构建成功后，会在自己的workspace/项目/target下生成maven构建成功的jar包，获取jar包名的完整路径]\n# 例如：/usr/local/docker/jenkins/workspace/video-book-backend/target/video-book-backend-0.0.1-SNAPSHOT.jar\nSOURCE_JAR_PATH=$(find \"$SOURCE_PATH/$SERVER_NAME/target/\"  -name \"*$SERVER_NAME*.jar\" )\n\nDATE=`date +%Y%m%d%H%M%S`\n\n# =====================================================================================\n# ============================对原本已存在的jar进行备份================================\n# =====================================================================================\n\n# 备份\nfunction backup(){\n    if [ -f \"$BASE_PATH/$SERVER_NAME.jar\" ]; then\n        echo \"=========================>>>>>>>$SERVER_NAME.jar 备份...\"\n            mv $BASE_PATH/$SERVER_NAME.jar $BASE_PATH/backup/$SERVER_NAME-$DATE.jar\n        echo \"=========================>>>>>>>备份老的 $SERVER_NAME.jar 完成\"\n\n    else\n        echo \"=========================>>>>>>>老的$BASE_PATH/$SERVER_NAME.jar不存在，跳过备份\"\n    fi\n}\n\n# =====================================================================================\n# =========================移动最新源jar包到Dockerfile所在目录=========================\n# =====================================================================================\n\n\n \n# 查找源jar文件名，进行重命名，最后将源文件移动到Dockerfile文件所在目录\nfunction transfer(){\n      \n    echo \"=========================>>>>>>>源文件完整地址为 $SOURCE_JAR_PATH\"\n\n    echo \"=========================>>>>>>>重命名源文件\"\n        mv $SOURCE_JAR_PATH  $SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar\n\n    echo \"=========================>>>>>>>最新构建代码 将$SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar 迁移至 $BASE_PATH\"\n        cp $SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar $BASE_PATH\n        \n    echo \"=========================>>>>>>>迁移完成Success\"\n\n}\n \n# =====================================================================================\n# ==================================构建最新镜像=======================================\n# =====================================================================================\n\n# 构建docker镜像\nfunction build(){\n    \n    # 无论镜像存在与否，都停止原容器服务，并移除原容器服务\n    echo \"=========================>>>>>>>停止$SERVER_NAME容器，CID=$CID\"\n    docker stop $CID\n\n    echo \"=========================>>>>>>>移除$SERVER_NAME容器，CID=$CID\"\n    docker rm $CID\n\n    # 无论如何，都去构建新的镜像\n    if [ -n \"$IID\" ]; then\n        echo \"=========================>>>>>>>存在$SERVER_NAME镜像，IID=$IID\"\n\n        echo \"=========================>>>>>>>移除老的$SERVER_NAME镜像，IID=$IID\"\n        \n        docker rmi $IID\n\n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，开始---->\"\n        \n        cd $BASE_PATH\n        docker build -t $SERVER_NAME .\n        \n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，完成---->\"\n\n    else\n        echo \"=========================>>>>>>>不存在$SERVER_NAME镜像，构建新的镜像，开始--->\"\n        \n        cd $BASE_PATH\n        docker build -t $SERVER_NAME .\n        \n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，结束--->\"\n    fi\n}\n \n\n# =====================================================================================\n# ==============================运行docker容器，启动服务===============================\n# =====================================================================================\n\n# 运行docker容器\nfunction run(){\n    backup\n    transfer\n    build\n\n    # 创建容器\n    docker run --name $SERVER_NAME -itd --net=host -v /etc/localtime:/etc/localtime:ro  -v /etc/timezone:/etc/timezone:ro  $SERVER_NAME \n\n}\n \n# 入口\nrun\n```\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e67ba6d7cf14d52b00009c09afc9349~tplv-k3u1fbpfcp-watermark.image?)\n\nOK，到这里基本的任务已经新建成功，至于后续的两个步骤，根据自己的需求自行配置，没有难度的。\n\n点击应用，保存。\n\n### 测试\n\n测试push事件触发自动化构建和部署，点击test下拉选择push events，出现HTTP 200表示OK了。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e85f532d1c2b4643996604347b945f51~tplv-k3u1fbpfcp-watermark.image?)\n\n回到Jenkins可以看到任务列表，查看构建信息等。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f954757d41324660ae01ff5de6afe17e~tplv-k3u1fbpfcp-watermark.image?)\n\n待Jenkins构建成功之后，在服务器上执行命令：`docker ps`，可以看到我们启动起来的 SpringBoot 容器：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8556de2ce136416ea36e817b661c2f80~tplv-k3u1fbpfcp-watermark.image?)\n\n## 邮件通知\n\n有时候团队合作，我们希望能通过邮件通知每一个开发者，项目是否构建成功。jenkins/jenkins:2.332.1默认安装了`# Email Extension Template`这个插件，还需要安装`Email Extension Template`这个插件\n\n系统管理->插件管理->可选插件->搜索`Email Extension Template`\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51c60941d3d3422e88db89b5188a3168~tplv-k3u1fbpfcp-watermark.image?)\n\n直接安装\n\n### 配置Email(Jenkins自带)\n\n#### 2.1 基础信息查询\n\n>找到所要配置邮箱的基础信息，这里以QQ邮箱为例\n\n1. 通过网页端QQ邮箱的设置进入到邮箱客户端设置页面\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f31038ef147f4c728540bc581f64d522~tplv-k3u1fbpfcp-watermark.image?)\n\n2. 找到邮箱的基础信息\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5694801b0ed74685a76cade6b358c5fc~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 2.2 Jenkins邮件通知配置\n\n在Jenkins：`系统管理->系统配置`中，最底部找到`邮件通知`，打开`高级`,注意到在配置的下方有个\"通过发送测试邮件测试配置\"，我们可以讲其勾选，填入邮箱地址，点击`Test configuration`来先测试一下邮件的发送。\n\n> 这边最好先保存一下再测试，否则出错，又得重配。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6420215d674647fb824854fd68a3efd6~tplv-k3u1fbpfcp-watermark.image?)\n\n如果报错如下：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8481f74294404047a2671bc8e2a3297e~tplv-k3u1fbpfcp-watermark.image?)\n\n这是因为我们还需要在设置`Jenkins Location`中配置`系统管理员邮件地址`，此地址要和`邮件通知`中的`用户名`一致\n\n### 配置Email(Extended E-mail Notification)\n\n>记得文章一开头提到的下载Extended插件，没错，Jenkins系统设置里还可以通过`Extended E-mail Notification`对邮件发送进行模板格式的自定义\n\n#### 3.1 基础信息配置\n\n基础信息配置与上述一致,唯一要注意的是这里需要重新生成一个授权码\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cb0934380904b098a035e54297946d4~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 3.2 模板格式配置\n\n接3.1配置继续。这里主要就是配置展示的模板格式，常用的格式化的参数有：\n```\n- $BUILD_STATUS – 构建结果\n- $PROJECT_NAME – 构建脚本名称\n- $BUILD_NUMBER – 构建脚本编号\n- $JOB_DESCRIPTION – 构建项目描述 \n- $CAUSE – 脚本启动原因\n- $BUILD_URL – 脚本构建详情URL地址\n```\n\n这里选择以HTML的格式展示，填入模板：\n```\n<!DOCTYPE html>    \n<html>    \n<head>    \n<meta charset=\"UTF-8\">    \n<title>${ENV, var=\"JOB_NAME\"}-第${BUILD_NUMBER}次构建日志</title>    \n</head>    \n    \n<body leftmargin=\"8\" marginwidth=\"0\" topmargin=\"8\" marginheight=\"4\"    \n    offset=\"0\">    \n    <table width=\"95%\" cellpadding=\"0\" cellspacing=\"0\"  style=\"font-size: 11pt; font-family: Tahoma, Arial, Helvetica, sans-serif\">    \n        <tr>    \n            本邮件由系统自动发出，无需回复！<br/>            \n            各位同事，大家好，以下为${PROJECT_NAME}项目构建信息</br> \n            <td><font color=\"#CC0000\">构建结果 - ${BUILD_STATUS}</font></td>   \n        </tr>    \n        <tr>    \n            <td><br />    \n            <b><font color=\"#0B610B\">构建信息</font></b>    \n            <hr size=\"2\" width=\"100%\" align=\"center\" /></td>    \n        </tr>    \n        <tr>    \n            <td>    \n                <ul>    \n                    <li>项目名称 ： ${PROJECT_NAME}</li>    \n                    <li>构建编号 ： 第${BUILD_NUMBER}次构建</li>    \n                    <li>触发原因： ${CAUSE}</li>    \n                    <li>构建状态： ${BUILD_STATUS}</li>    \n                    <li>构建日志： <a href=\"${BUILD_URL}console\">${BUILD_URL}console</a></li>    \n                    <li>构建  Url ： <a href=\"${BUILD_URL}\">${BUILD_URL}</a></li>    \n                    <li>工作目录 ： <a href=\"${PROJECT_URL}ws\">${PROJECT_URL}ws</a></li>    \n                    <li>项目  Url ： <a href=\"${PROJECT_URL}\">${PROJECT_URL}</a></li>    \n                </ul>    \n\n<h4><font color=\"#0B610B\">失败用例</font></h4>\n<hr size=\"2\" width=\"100%\" />\n$FAILED_TESTS<br/>\n\n<h4><font color=\"#0B610B\">最近提交(#$SVN_REVISION)</font></h4>\n<hr size=\"2\" width=\"100%\" />\n<ul>\n${CHANGES_SINCE_LAST_SUCCESS, reverse=true, format=\"%c\", changesFormat=\"<li>%d [%a] %m</li>\"}\n</ul>\n详细提交: <a href=\"${PROJECT_URL}changes\">${PROJECT_URL}changes</a><br/>\n\n            </td>    \n        </tr>    \n    </table>    \n</body>    \n</html>\n```\n\n如下图：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8b10b649f4943e1944fc094c72a3d2e~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 3.3 触发条件配置\n\n我们还可以在`Default Triggers`中根据自己的需要配置邮件的触发条件\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4328af1e2934c81b61f8c0429b6313b~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16835dfc64334f0e93a6cb7fd262922a~tplv-k3u1fbpfcp-watermark.image?)\n\n>这里为了防止因为构建一直尝试结果均为失败而造成的邮件轰炸，可以设置邮件仅第一次或第二次构建结果为失败时才发送邮件，后续失败的邮件将不再发送。我选择的是每一次失败和构建成功都会发邮件通知\n\n#### 3.4 jenkins的任务中配置邮件通知\n\n1. 在对应的任务中的构建设置中，勾选`E-mail Notification Recipients`\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/224fb406029d46d489cb6192848fdb6e~tplv-k3u1fbpfcp-watermark.image?)\n\n2. 在对应的任务中的构建后操作中，下拉选择`Editable Email Notification`\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1abc14189c874a818e5fe42a90371e43~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/594c71d3301544e48f6cc7468724b964~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b633844afb7a43e488cd3ab81d7c08a9~tplv-k3u1fbpfcp-watermark.image?)\n\n至此，jnekins的自动化构建的邮件通知已配置完成，在gitlab点击push event发起构建进行测试。\n\n发送成功的话，可看到如下图的提示：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a26d60de670c48ca991975dc2d20fa20~tplv-k3u1fbpfcp-watermark.image?)\n\n## 总结\n\n经过多款插件的安装配置，逐步掌握了如何上床Spring Boot项目到Gitlab中，并使用Jenkins自动构建任务，另外依托于Docker，让这一切变得更加方便，希望大家都多多思考，让机器自动干活，减少我们IT从业人员的重复、繁琐的工作量。\n\n\n', '小白学习gitlab+jenkins进行自动化构建(docker)之springboot项目', 0, 7, 2, 9, 0, '2023-06-09 16:56:30', '2023-06-09 16:56:30', 0);
INSERT INTO `tb_article` VALUES (20, '小白学习gitlab+jenkins进行自动化构建(docker)之springboot项目', '## 前言\ngitlab和jenkins的安装参考我的另外两篇博客：\n* gitlab安装：[小白搭建gitlab(docker)](https://juejin.cn/post/7032898607686778910)\n* jenkins安装：[小白学习搭建jenkins(docker)](https://juejin.cn/post/7032891246490157093/)\n\n## 在Jenkins上安装必要的插件\n所需插件：`Maven Integration`、`Pipeline Maven Integration`、`Gitlab`、`GitLab Authentication`、`SSH`、`Publish Over SSH`、`Docker`\n\n点击 Manage Jenkins（系统管理） ——> Manage Plugins（插件管理）\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5d15509337b44198064ba2bd41f221e~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Maven插件\n\n点击可选插件 ——> 过滤Maven Integration插件 ——> 勾选Maven Integration和Pipeline Maven Integration ——> 点击直接安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e496dbb12972454789d19546d660c88d~tplv-k3u1fbpfcp-watermark.image?)\n\n如图开始安装插件：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/134fef5f496c468b8dad342454c83b45~tplv-k3u1fbpfcp-watermark.image?)\n\n安装完成后，即可在插件管理下的已安装选项卡下看到刚刚已经安装的插件。\n\n#### 安装Gitlab插件\n\n点击可选插件 ——> 过滤Gitlab插件 ——> 勾选Gitlab和Gitlab Authentication ——> 点击直接安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6171674e55b428c9eba7be7cc2f516c~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装SSH插件和Publish Over SSH插件\n安装Publish Over SSH插件的原因：因为本方式是使用docker启动jenkins服务，所以在jenkins后续执行构建任务时候，需要在build成功后，将服务的jar包（以spring boot服务为例）拷贝到Dockerfile所在服务器的指定目录，进行微服务的启动；所以，此处需要配置SSH服务器的连接，意思就是在jenkins的任务结束后，去执行指定的服务器上的shell命令，做spring boot或cloud服务的镜像的构建，容器的运行，等一系列的事情。\n\n点击可选插件 ——> 过滤SSH插件 ——> 勾选SSH和Publish Over SSH ——> 点击直接安装\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d21ba2054860482b8b07684f48468538~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Docker插件\n\n点击可选插件 ——> 过滤Docker插件 ——> 勾选Docker ——> 点击直接安装\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1501abfe94b431a91e5692c41d12f72~tplv-k3u1fbpfcp-watermark.image?)\n\n插件全部安装完成后，可以重启一下Jenkins。\n\n## 相关配置\n\n#### 添加凭据\n\n点击 Manage Jenkins（系统管理） ——> Manage Credentials（凭据管理）\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0d3890020d34004adb05cab48310dd1~tplv-k3u1fbpfcp-watermark.image?)\n\n点击添加凭据 ——> 输入宿主机服务器的用户名和密码等信息并保存\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8eb6e5330d2140cb9705256fc722dc9d~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 配置SSH remote hosts\n\n这个配置是干什么的呢？配置SSH连接Dockerfile所在服务器的相关信息，并添加凭证，最后测试连接并保存，以备后面使用！！！\n\n点击 Manage Jenkins（系统管理） ——> 系统配置\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3813b66e9134305a1acb1d7515110bd~tplv-k3u1fbpfcp-watermark.image?)\n\n找到配置 ——> 下拉选择SSH remote hosts\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7436757a876049db93e6b255662001f2~tplv-k3u1fbpfcp-watermark.image?)\n\n如下图，输入对应的信息，并校验是否连接成功！成功后，点击应用 ——> 点击保存\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3559c64c918c4355aaff8d136e689da9~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 配置Publish over SSH\n\n找到配置 ——> 下拉选择Publish over SSH，进行相关配置即可。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0bb12f108302405ba90bb33e80fd0d5e~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78ad24f26a2a46b68ea44ea1c6ceb537~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de7ba1ca4a074ad1bb6f6a4b8fe71ee3~tplv-k3u1fbpfcp-watermark.image?)\n\n这里配置的数据，目前只能在Post Steps中选中send files or execute commands over ssh使用，要想能够在execute shell script on remote host using ssh方式中使用，需要再配置一份SSH remote hosts和它配套使用\n\n## 全局工具配置\n\n由于我们要实现的是SpringBoot项目的自动化部署操作，所以需要安装JDK、Git、Maven、Docker。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0dec279d6d44a83b2138cd7663e0995~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装JDK\n\n可以安装多个，根据项目JDK版本需求。\n\n输入自定义JDK名称 ——> 勾选自动安装 ——> 输入Oracle账户、密码 ——> 选择JDK版本 ——> 勾选同意协议\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72aa67fd5a494228840c5bef060e36b8~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Git\n\n输入自定义Git名称 ——> 勾选自动安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b49eb7bd11d48ab9ffce4f29431c216~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Maven\n\n输入自定义名称 ——> 勾选自动安装 ——> 选择版本\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5394195a98b647189dfaa5cd74b1a0b0~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Docker\n\n输入自定义名称 ——> 勾选自动安装\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/893704cbe8fe449fb615534bf9e82cea~tplv-k3u1fbpfcp-watermark.image?)\n\n最后，点击应用 ——> 点击保存即可。\n\n## 新建Jenkins任务\n\n### 点击新建任务，输入名称\n\n注意：本名称必须和项目名称一致，因为本名称会在jenkins工作空间下生成目录，类似于IDEA或Eclipse的工作空间的概念。所以，一般情况下，保证本名称=项目名称=docker镜像名称=docker容器名称 这样能尽可能的减轻jenkins配置的shell命令的复杂性！（空间命名要小写：因为镜像名不允许存在大写字母）\n\n选择构建一个Maven项目（因为是Spring Boot的服务）\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5a510bcf4ac49159f3f3b2960ae4fc5~tplv-k3u1fbpfcp-watermark.image?)\n\n### 源码管理\n\n输入描述信息，源码管理选择Git，从gitlab复制克隆地址（http协议的）粘贴到Repository URL中。未添加凭证会报授权失败的错误。错误如下：\n```\n![]()无法连接仓库：Command \"git ls-remote -h -- http://192.168.57.128:8880/root/video-book-backend.git HEAD\" returned status code 128:\\\nstdout:\\\nstderr: remote: HTTP Basic: Access denied\\\nfatal: Authentication failed for \'http://192.168.57.128:8880/root/video-book-backend.git/\'\n```\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94c2477c80724a959f8bb9f461814f41~tplv-k3u1fbpfcp-watermark.image?)\n\n添加gitlab凭证：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e08c1c343564fda9d5c599e985c38f5~tplv-k3u1fbpfcp-watermark.image?)\n\n### 构建触发器\n\n接下来将会生成供gitlab配置webhook使用的URL和Token，请记录下来，后面会使用。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1016fa1f35f24be7bf16ebe0a503bb8e~tplv-k3u1fbpfcp-watermark.image?)\n\n点击高级，拉下来找到Generate并点击，生成一串Secret Token。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13fb693d0ed14c63b8b613cccc7cd5b9~tplv-k3u1fbpfcp-watermark.image?)\n\n### 添加webhook\n\n前往gitlab，进入要构建的项目，在setting中选择Webhooks，输入URL和Secret Token 这两在上面图中已经给你标注了，去掉Enable SSL verification的勾选。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/904006704c604f6da4f2d1989200d462~tplv-k3u1fbpfcp-watermark.image?)\n\n点击Add webhook，如图表示成功添加了webhook：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6928c377f94748d0b70f57189e42e6cd~tplv-k3u1fbpfcp-watermark.image?)\n\n如果添加不成功解决方案请参考：[解决 Url is blocked: Requests to the local network are not allowed](https://www.cnblogs.com/zhongyuanzhao000/p/11379098.html)\n\n### 构建环境\n\n勾选Add timestamps to the Console Output，等下可以看到控制台打印的信息，这个根据自己的需求勾选。\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/badcdddabcc643b19f5a41fdc9f3416e~tplv-k3u1fbpfcp-watermark.image?)\n\n### Pre Steps(构建之前的步骤)\n\n配置前一步需要做的事情是：清理本项目在jenkins的workspace中的历史文件夹。\n\n你可以不用知道WORKSPACE具体的地址在哪里，因为下方有链接可以查看到当前jenkins中有哪些可用的变量供你使用。\n\n默认WORKSPACE地址：`/var/jenkins_home/workspace`（如果你jenkins是docker启动的，并且挂载了目录在宿主机，那你在宿主机也是可以看到的，即 `/usr/local/docker/workspace`）\n\n本处选择的是执行shell，则表示本处配置的shell命令，是默认在jenkins容器中执行的，而不是在宿主机上。\n\n下拉选择执行 shell：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c2e1bd362944ff2aab0a62646bae53d~tplv-k3u1fbpfcp-watermark.image?)\n\n在执行shell的命令中输入以下命令，设置全局变量：\n```\nSERVER_NAME_1=video-book-backend\necho \"=========================>>>>>>>工作空间WORKSPACE的地址：$WORKSPACE \"\ncd $WORKSPACE\necho \"=========================>>>>>>>进入工作空间WORKSPACE，清除工作空间中原项目的工作空间$SERVER_NAME_1 \"\nrm -rf $SERVER_NAME_1\necho \"=========================>>>>>>>清除工作空间中原项目的工作空间$SERVER_NAME_1 ......成功success\"\n```\n注意：本处的SERVER_NAME_1=jenkins-docker-gitlab-springboot是配置项目的名称(和gitlab中的项目名保持一致)\n\n### Build(构建)\n\n我们是SpringBoot项目，所以用到maven，这里设置一下全局操作，clean项目，并打成jar包，所以这里输入：`clean package`\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a41ff4b5061f48f39de4738c6282ec78~tplv-k3u1fbpfcp-watermark.image?)\n\n### Post Steps(执行任务)\n\n只在jenkins构建成功后，才执行这一步。\n\n因为最后的构建成功的maven项目的jar包是以docker启动服务为目的，所以最后的docker操作，一定是在jenkins容器以外的服务器上运行的，可能是本机宿主机，也可能是远程的服务器，这个根据自己的情况去配置。\n\n本处选择，在远程的SSH执行shell脚本。\n\n选中只有构建成功才执行这些命令，然后选择Execute shell script on remote host using ssh。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c25a57ddb8f4b10b31e4832503d4af2~tplv-k3u1fbpfcp-watermark.image?)\n\nshell命令:\n```\n# =====================================================================================\n# =================================定义初始化变量======================================\n# =====================================================================================\n\n# 操作/项目路径(Dockerfile存放的路径，Dockerfile一般都放在项目的根目录下)\n# 如果Dockerfile放在项目根目录的子目录下，则子目录不能与项目同名\n# 会导致在复制jar包的时候，覆盖子目录为jar包,同时没有扩展名jar,原因我暂时不知道\n# 目前我的做法是将Dockerfile放在项目根目录下\nBASE_PATH=/usr/local/docker/jenkins/workspace/video-book-backend\n\n# jenkins构建好的源jar路径\n# 这个路径是jenkins容器挂载在宿主机上的路径\n# 我的jenkins的目录被我挂载在了/usr/local/docker/jenkins上\nSOURCE_PATH=/usr/local/docker/jenkins/workspace\n\n# docker镜像、docker容器、Dockerfile同目录下的jar名字[用它build生成image的jar]、jenkins的workspace下的项目名称\n# 注意统一名称！！！！！\nSERVER_NAME=video-book-backend\n\n# 容器id  [grep -w 全量匹配容器名] [awk 获取信息行的第一列，即容器ID]  [无论容器启动与否，都获取到]\nCID=$(docker ps -a | grep -w \"$SERVER_NAME\" | awk \'{print $1}\')\n\n# 镜像id  [grep -w 全量匹配镜像名] [awk 获取信息行的第三列，即镜像ID]\nIID=$(docker images | grep -w \"$SERVER_NAME\" | awk \'{print $3}\')\n\n# 源jar完整地址[jenkins构建成功后，会在自己的workspace/项目/target下生成maven构建成功的jar包，获取jar包名的完整路径]\n# 例如：/usr/local/docker/jenkins/workspace/video-book-backend/target/video-book-backend-0.0.1-SNAPSHOT.jar\nSOURCE_JAR_PATH=$(find \"$SOURCE_PATH/$SERVER_NAME/target/\"  -name \"*$SERVER_NAME*.jar\" )\n\nDATE=`date +%Y%m%d%H%M%S`\n\n# =====================================================================================\n# ============================对原本已存在的jar进行备份================================\n# =====================================================================================\n\n# 备份\nfunction backup(){\n    if [ -f \"$BASE_PATH/$SERVER_NAME.jar\" ]; then\n        echo \"=========================>>>>>>>$SERVER_NAME.jar 备份...\"\n            mv $BASE_PATH/$SERVER_NAME.jar $BASE_PATH/backup/$SERVER_NAME-$DATE.jar\n        echo \"=========================>>>>>>>备份老的 $SERVER_NAME.jar 完成\"\n\n    else\n        echo \"=========================>>>>>>>老的$BASE_PATH/$SERVER_NAME.jar不存在，跳过备份\"\n    fi\n}\n\n# =====================================================================================\n# =========================移动最新源jar包到Dockerfile所在目录=========================\n# =====================================================================================\n\n\n \n# 查找源jar文件名，进行重命名，最后将源文件移动到Dockerfile文件所在目录\nfunction transfer(){\n      \n    echo \"=========================>>>>>>>源文件完整地址为 $SOURCE_JAR_PATH\"\n\n    echo \"=========================>>>>>>>重命名源文件\"\n        mv $SOURCE_JAR_PATH  $SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar\n\n    echo \"=========================>>>>>>>最新构建代码 将$SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar 迁移至 $BASE_PATH\"\n        cp $SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar $BASE_PATH\n        \n    echo \"=========================>>>>>>>迁移完成Success\"\n\n}\n \n# =====================================================================================\n# ==================================构建最新镜像=======================================\n# =====================================================================================\n\n# 构建docker镜像\nfunction build(){\n    \n    # 无论镜像存在与否，都停止原容器服务，并移除原容器服务\n    echo \"=========================>>>>>>>停止$SERVER_NAME容器，CID=$CID\"\n    docker stop $CID\n\n    echo \"=========================>>>>>>>移除$SERVER_NAME容器，CID=$CID\"\n    docker rm $CID\n\n    # 无论如何，都去构建新的镜像\n    if [ -n \"$IID\" ]; then\n        echo \"=========================>>>>>>>存在$SERVER_NAME镜像，IID=$IID\"\n\n        echo \"=========================>>>>>>>移除老的$SERVER_NAME镜像，IID=$IID\"\n        \n        docker rmi $IID\n\n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，开始---->\"\n        \n        cd $BASE_PATH\n        docker build -t $SERVER_NAME .\n        \n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，完成---->\"\n\n    else\n        echo \"=========================>>>>>>>不存在$SERVER_NAME镜像，构建新的镜像，开始--->\"\n        \n        cd $BASE_PATH\n        docker build -t $SERVER_NAME .\n        \n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，结束--->\"\n    fi\n}\n \n\n# =====================================================================================\n# ==============================运行docker容器，启动服务===============================\n# =====================================================================================\n\n# 运行docker容器\nfunction run(){\n    backup\n    transfer\n    build\n\n    # 创建容器\n    docker run --name $SERVER_NAME -itd --net=host -v /etc/localtime:/etc/localtime:ro  -v /etc/timezone:/etc/timezone:ro  $SERVER_NAME \n\n}\n \n# 入口\nrun\n```\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e67ba6d7cf14d52b00009c09afc9349~tplv-k3u1fbpfcp-watermark.image?)\n\nOK，到这里基本的任务已经新建成功，至于后续的两个步骤，根据自己的需求自行配置，没有难度的。\n\n点击应用，保存。\n\n### 测试\n\n测试push事件触发自动化构建和部署，点击test下拉选择push events，出现HTTP 200表示OK了。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e85f532d1c2b4643996604347b945f51~tplv-k3u1fbpfcp-watermark.image?)\n\n回到Jenkins可以看到任务列表，查看构建信息等。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f954757d41324660ae01ff5de6afe17e~tplv-k3u1fbpfcp-watermark.image?)\n\n待Jenkins构建成功之后，在服务器上执行命令：`docker ps`，可以看到我们启动起来的 SpringBoot 容器：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8556de2ce136416ea36e817b661c2f80~tplv-k3u1fbpfcp-watermark.image?)\n\n## 邮件通知\n\n有时候团队合作，我们希望能通过邮件通知每一个开发者，项目是否构建成功。jenkins/jenkins:2.332.1默认安装了`# Email Extension Template`这个插件，还需要安装`Email Extension Template`这个插件\n\n系统管理->插件管理->可选插件->搜索`Email Extension Template`\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51c60941d3d3422e88db89b5188a3168~tplv-k3u1fbpfcp-watermark.image?)\n\n直接安装\n\n### 配置Email(Jenkins自带)\n\n#### 2.1 基础信息查询\n\n>找到所要配置邮箱的基础信息，这里以QQ邮箱为例\n\n1. 通过网页端QQ邮箱的设置进入到邮箱客户端设置页面\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f31038ef147f4c728540bc581f64d522~tplv-k3u1fbpfcp-watermark.image?)\n\n2. 找到邮箱的基础信息\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5694801b0ed74685a76cade6b358c5fc~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 2.2 Jenkins邮件通知配置\n\n在Jenkins：`系统管理->系统配置`中，最底部找到`邮件通知`，打开`高级`,注意到在配置的下方有个\"通过发送测试邮件测试配置\"，我们可以讲其勾选，填入邮箱地址，点击`Test configuration`来先测试一下邮件的发送。\n\n> 这边最好先保存一下再测试，否则出错，又得重配。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6420215d674647fb824854fd68a3efd6~tplv-k3u1fbpfcp-watermark.image?)\n\n如果报错如下：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8481f74294404047a2671bc8e2a3297e~tplv-k3u1fbpfcp-watermark.image?)\n\n这是因为我们还需要在设置`Jenkins Location`中配置`系统管理员邮件地址`，此地址要和`邮件通知`中的`用户名`一致\n\n### 配置Email(Extended E-mail Notification)\n\n>记得文章一开头提到的下载Extended插件，没错，Jenkins系统设置里还可以通过`Extended E-mail Notification`对邮件发送进行模板格式的自定义\n\n#### 3.1 基础信息配置\n\n基础信息配置与上述一致,唯一要注意的是这里需要重新生成一个授权码\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cb0934380904b098a035e54297946d4~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 3.2 模板格式配置\n\n接3.1配置继续。这里主要就是配置展示的模板格式，常用的格式化的参数有：\n```\n- $BUILD_STATUS – 构建结果\n- $PROJECT_NAME – 构建脚本名称\n- $BUILD_NUMBER – 构建脚本编号\n- $JOB_DESCRIPTION – 构建项目描述 \n- $CAUSE – 脚本启动原因\n- $BUILD_URL – 脚本构建详情URL地址\n```\n\n这里选择以HTML的格式展示，填入模板：\n```\n<!DOCTYPE html>    \n<html>    \n<head>    \n<meta charset=\"UTF-8\">    \n<title>${ENV, var=\"JOB_NAME\"}-第${BUILD_NUMBER}次构建日志</title>    \n</head>    \n    \n<body leftmargin=\"8\" marginwidth=\"0\" topmargin=\"8\" marginheight=\"4\"    \n    offset=\"0\">    \n    <table width=\"95%\" cellpadding=\"0\" cellspacing=\"0\"  style=\"font-size: 11pt; font-family: Tahoma, Arial, Helvetica, sans-serif\">    \n        <tr>    \n            本邮件由系统自动发出，无需回复！<br/>            \n            各位同事，大家好，以下为${PROJECT_NAME}项目构建信息</br> \n            <td><font color=\"#CC0000\">构建结果 - ${BUILD_STATUS}</font></td>   \n        </tr>    \n        <tr>    \n            <td><br />    \n            <b><font color=\"#0B610B\">构建信息</font></b>    \n            <hr size=\"2\" width=\"100%\" align=\"center\" /></td>    \n        </tr>    \n        <tr>    \n            <td>    \n                <ul>    \n                    <li>项目名称 ： ${PROJECT_NAME}</li>    \n                    <li>构建编号 ： 第${BUILD_NUMBER}次构建</li>    \n                    <li>触发原因： ${CAUSE}</li>    \n                    <li>构建状态： ${BUILD_STATUS}</li>    \n                    <li>构建日志： <a href=\"${BUILD_URL}console\">${BUILD_URL}console</a></li>    \n                    <li>构建  Url ： <a href=\"${BUILD_URL}\">${BUILD_URL}</a></li>    \n                    <li>工作目录 ： <a href=\"${PROJECT_URL}ws\">${PROJECT_URL}ws</a></li>    \n                    <li>项目  Url ： <a href=\"${PROJECT_URL}\">${PROJECT_URL}</a></li>    \n                </ul>    \n\n<h4><font color=\"#0B610B\">失败用例</font></h4>\n<hr size=\"2\" width=\"100%\" />\n$FAILED_TESTS<br/>\n\n<h4><font color=\"#0B610B\">最近提交(#$SVN_REVISION)</font></h4>\n<hr size=\"2\" width=\"100%\" />\n<ul>\n${CHANGES_SINCE_LAST_SUCCESS, reverse=true, format=\"%c\", changesFormat=\"<li>%d [%a] %m</li>\"}\n</ul>\n详细提交: <a href=\"${PROJECT_URL}changes\">${PROJECT_URL}changes</a><br/>\n\n            </td>    \n        </tr>    \n    </table>    \n</body>    \n</html>\n```\n\n如下图：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8b10b649f4943e1944fc094c72a3d2e~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 3.3 触发条件配置\n\n我们还可以在`Default Triggers`中根据自己的需要配置邮件的触发条件\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4328af1e2934c81b61f8c0429b6313b~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16835dfc64334f0e93a6cb7fd262922a~tplv-k3u1fbpfcp-watermark.image?)\n\n>这里为了防止因为构建一直尝试结果均为失败而造成的邮件轰炸，可以设置邮件仅第一次或第二次构建结果为失败时才发送邮件，后续失败的邮件将不再发送。我选择的是每一次失败和构建成功都会发邮件通知\n\n#### 3.4 jenkins的任务中配置邮件通知\n\n1. 在对应的任务中的构建设置中，勾选`E-mail Notification Recipients`\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/224fb406029d46d489cb6192848fdb6e~tplv-k3u1fbpfcp-watermark.image?)\n\n2. 在对应的任务中的构建后操作中，下拉选择`Editable Email Notification`\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1abc14189c874a818e5fe42a90371e43~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/594c71d3301544e48f6cc7468724b964~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b633844afb7a43e488cd3ab81d7c08a9~tplv-k3u1fbpfcp-watermark.image?)\n\n至此，jnekins的自动化构建的邮件通知已配置完成，在gitlab点击push event发起构建进行测试。\n\n发送成功的话，可看到如下图的提示：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a26d60de670c48ca991975dc2d20fa20~tplv-k3u1fbpfcp-watermark.image?)\n\n## 总结\n\n经过多款插件的安装配置，逐步掌握了如何上床Spring Boot项目到Gitlab中，并使用Jenkins自动构建任务，另外依托于Docker，让这一切变得更加方便，希望大家都多多思考，让机器自动干活，减少我们IT从业人员的重复、繁琐的工作量。\n\n\n', '小白学习gitlab+jenkins进行自动化构建(docker)之springboot项目', 0, 7, 2, 9, 0, '2023-06-09 16:56:30', '2023-06-09 16:56:30', 0);
INSERT INTO `tb_article` VALUES (21, '小白学习gitlab+jenkins进行自动化构建(docker)之springboot项目', '## 前言\ngitlab和jenkins的安装参考我的另外两篇博客：\n* gitlab安装：[小白搭建gitlab(docker)](https://juejin.cn/post/7032898607686778910)\n* jenkins安装：[小白学习搭建jenkins(docker)](https://juejin.cn/post/7032891246490157093/)\n\n## 在Jenkins上安装必要的插件\n所需插件：`Maven Integration`、`Pipeline Maven Integration`、`Gitlab`、`GitLab Authentication`、`SSH`、`Publish Over SSH`、`Docker`\n\n点击 Manage Jenkins（系统管理） ——> Manage Plugins（插件管理）\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5d15509337b44198064ba2bd41f221e~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Maven插件\n\n点击可选插件 ——> 过滤Maven Integration插件 ——> 勾选Maven Integration和Pipeline Maven Integration ——> 点击直接安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e496dbb12972454789d19546d660c88d~tplv-k3u1fbpfcp-watermark.image?)\n\n如图开始安装插件：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/134fef5f496c468b8dad342454c83b45~tplv-k3u1fbpfcp-watermark.image?)\n\n安装完成后，即可在插件管理下的已安装选项卡下看到刚刚已经安装的插件。\n\n#### 安装Gitlab插件\n\n点击可选插件 ——> 过滤Gitlab插件 ——> 勾选Gitlab和Gitlab Authentication ——> 点击直接安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6171674e55b428c9eba7be7cc2f516c~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装SSH插件和Publish Over SSH插件\n安装Publish Over SSH插件的原因：因为本方式是使用docker启动jenkins服务，所以在jenkins后续执行构建任务时候，需要在build成功后，将服务的jar包（以spring boot服务为例）拷贝到Dockerfile所在服务器的指定目录，进行微服务的启动；所以，此处需要配置SSH服务器的连接，意思就是在jenkins的任务结束后，去执行指定的服务器上的shell命令，做spring boot或cloud服务的镜像的构建，容器的运行，等一系列的事情。\n\n点击可选插件 ——> 过滤SSH插件 ——> 勾选SSH和Publish Over SSH ——> 点击直接安装\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d21ba2054860482b8b07684f48468538~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Docker插件\n\n点击可选插件 ——> 过滤Docker插件 ——> 勾选Docker ——> 点击直接安装\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1501abfe94b431a91e5692c41d12f72~tplv-k3u1fbpfcp-watermark.image?)\n\n插件全部安装完成后，可以重启一下Jenkins。\n\n## 相关配置\n\n#### 添加凭据\n\n点击 Manage Jenkins（系统管理） ——> Manage Credentials（凭据管理）\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0d3890020d34004adb05cab48310dd1~tplv-k3u1fbpfcp-watermark.image?)\n\n点击添加凭据 ——> 输入宿主机服务器的用户名和密码等信息并保存\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8eb6e5330d2140cb9705256fc722dc9d~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 配置SSH remote hosts\n\n这个配置是干什么的呢？配置SSH连接Dockerfile所在服务器的相关信息，并添加凭证，最后测试连接并保存，以备后面使用！！！\n\n点击 Manage Jenkins（系统管理） ——> 系统配置\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3813b66e9134305a1acb1d7515110bd~tplv-k3u1fbpfcp-watermark.image?)\n\n找到配置 ——> 下拉选择SSH remote hosts\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7436757a876049db93e6b255662001f2~tplv-k3u1fbpfcp-watermark.image?)\n\n如下图，输入对应的信息，并校验是否连接成功！成功后，点击应用 ——> 点击保存\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3559c64c918c4355aaff8d136e689da9~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 配置Publish over SSH\n\n找到配置 ——> 下拉选择Publish over SSH，进行相关配置即可。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0bb12f108302405ba90bb33e80fd0d5e~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78ad24f26a2a46b68ea44ea1c6ceb537~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de7ba1ca4a074ad1bb6f6a4b8fe71ee3~tplv-k3u1fbpfcp-watermark.image?)\n\n这里配置的数据，目前只能在Post Steps中选中send files or execute commands over ssh使用，要想能够在execute shell script on remote host using ssh方式中使用，需要再配置一份SSH remote hosts和它配套使用\n\n## 全局工具配置\n\n由于我们要实现的是SpringBoot项目的自动化部署操作，所以需要安装JDK、Git、Maven、Docker。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0dec279d6d44a83b2138cd7663e0995~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装JDK\n\n可以安装多个，根据项目JDK版本需求。\n\n输入自定义JDK名称 ——> 勾选自动安装 ——> 输入Oracle账户、密码 ——> 选择JDK版本 ——> 勾选同意协议\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72aa67fd5a494228840c5bef060e36b8~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Git\n\n输入自定义Git名称 ——> 勾选自动安装\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b49eb7bd11d48ab9ffce4f29431c216~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Maven\n\n输入自定义名称 ——> 勾选自动安装 ——> 选择版本\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5394195a98b647189dfaa5cd74b1a0b0~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 安装Docker\n\n输入自定义名称 ——> 勾选自动安装\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/893704cbe8fe449fb615534bf9e82cea~tplv-k3u1fbpfcp-watermark.image?)\n\n最后，点击应用 ——> 点击保存即可。\n\n## 新建Jenkins任务\n\n### 点击新建任务，输入名称\n\n注意：本名称必须和项目名称一致，因为本名称会在jenkins工作空间下生成目录，类似于IDEA或Eclipse的工作空间的概念。所以，一般情况下，保证本名称=项目名称=docker镜像名称=docker容器名称 这样能尽可能的减轻jenkins配置的shell命令的复杂性！（空间命名要小写：因为镜像名不允许存在大写字母）\n\n选择构建一个Maven项目（因为是Spring Boot的服务）\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5a510bcf4ac49159f3f3b2960ae4fc5~tplv-k3u1fbpfcp-watermark.image?)\n\n### 源码管理\n\n输入描述信息，源码管理选择Git，从gitlab复制克隆地址（http协议的）粘贴到Repository URL中。未添加凭证会报授权失败的错误。错误如下：\n```\n![]()无法连接仓库：Command \"git ls-remote -h -- http://192.168.57.128:8880/root/video-book-backend.git HEAD\" returned status code 128:\\\nstdout:\\\nstderr: remote: HTTP Basic: Access denied\\\nfatal: Authentication failed for \'http://192.168.57.128:8880/root/video-book-backend.git/\'\n```\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94c2477c80724a959f8bb9f461814f41~tplv-k3u1fbpfcp-watermark.image?)\n\n添加gitlab凭证：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e08c1c343564fda9d5c599e985c38f5~tplv-k3u1fbpfcp-watermark.image?)\n\n### 构建触发器\n\n接下来将会生成供gitlab配置webhook使用的URL和Token，请记录下来，后面会使用。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1016fa1f35f24be7bf16ebe0a503bb8e~tplv-k3u1fbpfcp-watermark.image?)\n\n点击高级，拉下来找到Generate并点击，生成一串Secret Token。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13fb693d0ed14c63b8b613cccc7cd5b9~tplv-k3u1fbpfcp-watermark.image?)\n\n### 添加webhook\n\n前往gitlab，进入要构建的项目，在setting中选择Webhooks，输入URL和Secret Token 这两在上面图中已经给你标注了，去掉Enable SSL verification的勾选。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/904006704c604f6da4f2d1989200d462~tplv-k3u1fbpfcp-watermark.image?)\n\n点击Add webhook，如图表示成功添加了webhook：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6928c377f94748d0b70f57189e42e6cd~tplv-k3u1fbpfcp-watermark.image?)\n\n如果添加不成功解决方案请参考：[解决 Url is blocked: Requests to the local network are not allowed](https://www.cnblogs.com/zhongyuanzhao000/p/11379098.html)\n\n### 构建环境\n\n勾选Add timestamps to the Console Output，等下可以看到控制台打印的信息，这个根据自己的需求勾选。\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/badcdddabcc643b19f5a41fdc9f3416e~tplv-k3u1fbpfcp-watermark.image?)\n\n### Pre Steps(构建之前的步骤)\n\n配置前一步需要做的事情是：清理本项目在jenkins的workspace中的历史文件夹。\n\n你可以不用知道WORKSPACE具体的地址在哪里，因为下方有链接可以查看到当前jenkins中有哪些可用的变量供你使用。\n\n默认WORKSPACE地址：`/var/jenkins_home/workspace`（如果你jenkins是docker启动的，并且挂载了目录在宿主机，那你在宿主机也是可以看到的，即 `/usr/local/docker/workspace`）\n\n本处选择的是执行shell，则表示本处配置的shell命令，是默认在jenkins容器中执行的，而不是在宿主机上。\n\n下拉选择执行 shell：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c2e1bd362944ff2aab0a62646bae53d~tplv-k3u1fbpfcp-watermark.image?)\n\n在执行shell的命令中输入以下命令，设置全局变量：\n```\nSERVER_NAME_1=video-book-backend\necho \"=========================>>>>>>>工作空间WORKSPACE的地址：$WORKSPACE \"\ncd $WORKSPACE\necho \"=========================>>>>>>>进入工作空间WORKSPACE，清除工作空间中原项目的工作空间$SERVER_NAME_1 \"\nrm -rf $SERVER_NAME_1\necho \"=========================>>>>>>>清除工作空间中原项目的工作空间$SERVER_NAME_1 ......成功success\"\n```\n注意：本处的SERVER_NAME_1=jenkins-docker-gitlab-springboot是配置项目的名称(和gitlab中的项目名保持一致)\n\n### Build(构建)\n\n我们是SpringBoot项目，所以用到maven，这里设置一下全局操作，clean项目，并打成jar包，所以这里输入：`clean package`\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a41ff4b5061f48f39de4738c6282ec78~tplv-k3u1fbpfcp-watermark.image?)\n\n### Post Steps(执行任务)\n\n只在jenkins构建成功后，才执行这一步。\n\n因为最后的构建成功的maven项目的jar包是以docker启动服务为目的，所以最后的docker操作，一定是在jenkins容器以外的服务器上运行的，可能是本机宿主机，也可能是远程的服务器，这个根据自己的情况去配置。\n\n本处选择，在远程的SSH执行shell脚本。\n\n选中只有构建成功才执行这些命令，然后选择Execute shell script on remote host using ssh。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c25a57ddb8f4b10b31e4832503d4af2~tplv-k3u1fbpfcp-watermark.image?)\n\nshell命令:\n```\n# =====================================================================================\n# =================================定义初始化变量======================================\n# =====================================================================================\n\n# 操作/项目路径(Dockerfile存放的路径，Dockerfile一般都放在项目的根目录下)\n# 如果Dockerfile放在项目根目录的子目录下，则子目录不能与项目同名\n# 会导致在复制jar包的时候，覆盖子目录为jar包,同时没有扩展名jar,原因我暂时不知道\n# 目前我的做法是将Dockerfile放在项目根目录下\nBASE_PATH=/usr/local/docker/jenkins/workspace/video-book-backend\n\n# jenkins构建好的源jar路径\n# 这个路径是jenkins容器挂载在宿主机上的路径\n# 我的jenkins的目录被我挂载在了/usr/local/docker/jenkins上\nSOURCE_PATH=/usr/local/docker/jenkins/workspace\n\n# docker镜像、docker容器、Dockerfile同目录下的jar名字[用它build生成image的jar]、jenkins的workspace下的项目名称\n# 注意统一名称！！！！！\nSERVER_NAME=video-book-backend\n\n# 容器id  [grep -w 全量匹配容器名] [awk 获取信息行的第一列，即容器ID]  [无论容器启动与否，都获取到]\nCID=$(docker ps -a | grep -w \"$SERVER_NAME\" | awk \'{print $1}\')\n\n# 镜像id  [grep -w 全量匹配镜像名] [awk 获取信息行的第三列，即镜像ID]\nIID=$(docker images | grep -w \"$SERVER_NAME\" | awk \'{print $3}\')\n\n# 源jar完整地址[jenkins构建成功后，会在自己的workspace/项目/target下生成maven构建成功的jar包，获取jar包名的完整路径]\n# 例如：/usr/local/docker/jenkins/workspace/video-book-backend/target/video-book-backend-0.0.1-SNAPSHOT.jar\nSOURCE_JAR_PATH=$(find \"$SOURCE_PATH/$SERVER_NAME/target/\"  -name \"*$SERVER_NAME*.jar\" )\n\nDATE=`date +%Y%m%d%H%M%S`\n\n# =====================================================================================\n# ============================对原本已存在的jar进行备份================================\n# =====================================================================================\n\n# 备份\nfunction backup(){\n    if [ -f \"$BASE_PATH/$SERVER_NAME.jar\" ]; then\n        echo \"=========================>>>>>>>$SERVER_NAME.jar 备份...\"\n            mv $BASE_PATH/$SERVER_NAME.jar $BASE_PATH/backup/$SERVER_NAME-$DATE.jar\n        echo \"=========================>>>>>>>备份老的 $SERVER_NAME.jar 完成\"\n\n    else\n        echo \"=========================>>>>>>>老的$BASE_PATH/$SERVER_NAME.jar不存在，跳过备份\"\n    fi\n}\n\n# =====================================================================================\n# =========================移动最新源jar包到Dockerfile所在目录=========================\n# =====================================================================================\n\n\n \n# 查找源jar文件名，进行重命名，最后将源文件移动到Dockerfile文件所在目录\nfunction transfer(){\n      \n    echo \"=========================>>>>>>>源文件完整地址为 $SOURCE_JAR_PATH\"\n\n    echo \"=========================>>>>>>>重命名源文件\"\n        mv $SOURCE_JAR_PATH  $SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar\n\n    echo \"=========================>>>>>>>最新构建代码 将$SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar 迁移至 $BASE_PATH\"\n        cp $SOURCE_PATH/$SERVER_NAME/target/$SERVER_NAME.jar $BASE_PATH\n        \n    echo \"=========================>>>>>>>迁移完成Success\"\n\n}\n \n# =====================================================================================\n# ==================================构建最新镜像=======================================\n# =====================================================================================\n\n# 构建docker镜像\nfunction build(){\n    \n    # 无论镜像存在与否，都停止原容器服务，并移除原容器服务\n    echo \"=========================>>>>>>>停止$SERVER_NAME容器，CID=$CID\"\n    docker stop $CID\n\n    echo \"=========================>>>>>>>移除$SERVER_NAME容器，CID=$CID\"\n    docker rm $CID\n\n    # 无论如何，都去构建新的镜像\n    if [ -n \"$IID\" ]; then\n        echo \"=========================>>>>>>>存在$SERVER_NAME镜像，IID=$IID\"\n\n        echo \"=========================>>>>>>>移除老的$SERVER_NAME镜像，IID=$IID\"\n        \n        docker rmi $IID\n\n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，开始---->\"\n        \n        cd $BASE_PATH\n        docker build -t $SERVER_NAME .\n        \n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，完成---->\"\n\n    else\n        echo \"=========================>>>>>>>不存在$SERVER_NAME镜像，构建新的镜像，开始--->\"\n        \n        cd $BASE_PATH\n        docker build -t $SERVER_NAME .\n        \n        echo \"=========================>>>>>>>构建新的$SERVER_NAME镜像，结束--->\"\n    fi\n}\n \n\n# =====================================================================================\n# ==============================运行docker容器，启动服务===============================\n# =====================================================================================\n\n# 运行docker容器\nfunction run(){\n    backup\n    transfer\n    build\n\n    # 创建容器\n    docker run --name $SERVER_NAME -itd --net=host -v /etc/localtime:/etc/localtime:ro  -v /etc/timezone:/etc/timezone:ro  $SERVER_NAME \n\n}\n \n# 入口\nrun\n```\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e67ba6d7cf14d52b00009c09afc9349~tplv-k3u1fbpfcp-watermark.image?)\n\nOK，到这里基本的任务已经新建成功，至于后续的两个步骤，根据自己的需求自行配置，没有难度的。\n\n点击应用，保存。\n\n### 测试\n\n测试push事件触发自动化构建和部署，点击test下拉选择push events，出现HTTP 200表示OK了。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e85f532d1c2b4643996604347b945f51~tplv-k3u1fbpfcp-watermark.image?)\n\n回到Jenkins可以看到任务列表，查看构建信息等。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f954757d41324660ae01ff5de6afe17e~tplv-k3u1fbpfcp-watermark.image?)\n\n待Jenkins构建成功之后，在服务器上执行命令：`docker ps`，可以看到我们启动起来的 SpringBoot 容器：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8556de2ce136416ea36e817b661c2f80~tplv-k3u1fbpfcp-watermark.image?)\n\n## 邮件通知\n\n有时候团队合作，我们希望能通过邮件通知每一个开发者，项目是否构建成功。jenkins/jenkins:2.332.1默认安装了`# Email Extension Template`这个插件，还需要安装`Email Extension Template`这个插件\n\n系统管理->插件管理->可选插件->搜索`Email Extension Template`\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51c60941d3d3422e88db89b5188a3168~tplv-k3u1fbpfcp-watermark.image?)\n\n直接安装\n\n### 配置Email(Jenkins自带)\n\n#### 2.1 基础信息查询\n\n>找到所要配置邮箱的基础信息，这里以QQ邮箱为例\n\n1. 通过网页端QQ邮箱的设置进入到邮箱客户端设置页面\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f31038ef147f4c728540bc581f64d522~tplv-k3u1fbpfcp-watermark.image?)\n\n2. 找到邮箱的基础信息\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5694801b0ed74685a76cade6b358c5fc~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 2.2 Jenkins邮件通知配置\n\n在Jenkins：`系统管理->系统配置`中，最底部找到`邮件通知`，打开`高级`,注意到在配置的下方有个\"通过发送测试邮件测试配置\"，我们可以讲其勾选，填入邮箱地址，点击`Test configuration`来先测试一下邮件的发送。\n\n> 这边最好先保存一下再测试，否则出错，又得重配。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6420215d674647fb824854fd68a3efd6~tplv-k3u1fbpfcp-watermark.image?)\n\n如果报错如下：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8481f74294404047a2671bc8e2a3297e~tplv-k3u1fbpfcp-watermark.image?)\n\n这是因为我们还需要在设置`Jenkins Location`中配置`系统管理员邮件地址`，此地址要和`邮件通知`中的`用户名`一致\n\n### 配置Email(Extended E-mail Notification)\n\n>记得文章一开头提到的下载Extended插件，没错，Jenkins系统设置里还可以通过`Extended E-mail Notification`对邮件发送进行模板格式的自定义\n\n#### 3.1 基础信息配置\n\n基础信息配置与上述一致,唯一要注意的是这里需要重新生成一个授权码\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cb0934380904b098a035e54297946d4~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 3.2 模板格式配置\n\n接3.1配置继续。这里主要就是配置展示的模板格式，常用的格式化的参数有：\n```\n- $BUILD_STATUS – 构建结果\n- $PROJECT_NAME – 构建脚本名称\n- $BUILD_NUMBER – 构建脚本编号\n- $JOB_DESCRIPTION – 构建项目描述 \n- $CAUSE – 脚本启动原因\n- $BUILD_URL – 脚本构建详情URL地址\n```\n\n这里选择以HTML的格式展示，填入模板：\n```\n<!DOCTYPE html>    \n<html>    \n<head>    \n<meta charset=\"UTF-8\">    \n<title>${ENV, var=\"JOB_NAME\"}-第${BUILD_NUMBER}次构建日志</title>    \n</head>    \n    \n<body leftmargin=\"8\" marginwidth=\"0\" topmargin=\"8\" marginheight=\"4\"    \n    offset=\"0\">    \n    <table width=\"95%\" cellpadding=\"0\" cellspacing=\"0\"  style=\"font-size: 11pt; font-family: Tahoma, Arial, Helvetica, sans-serif\">    \n        <tr>    \n            本邮件由系统自动发出，无需回复！<br/>            \n            各位同事，大家好，以下为${PROJECT_NAME}项目构建信息</br> \n            <td><font color=\"#CC0000\">构建结果 - ${BUILD_STATUS}</font></td>   \n        </tr>    \n        <tr>    \n            <td><br />    \n            <b><font color=\"#0B610B\">构建信息</font></b>    \n            <hr size=\"2\" width=\"100%\" align=\"center\" /></td>    \n        </tr>    \n        <tr>    \n            <td>    \n                <ul>    \n                    <li>项目名称 ： ${PROJECT_NAME}</li>    \n                    <li>构建编号 ： 第${BUILD_NUMBER}次构建</li>    \n                    <li>触发原因： ${CAUSE}</li>    \n                    <li>构建状态： ${BUILD_STATUS}</li>    \n                    <li>构建日志： <a href=\"${BUILD_URL}console\">${BUILD_URL}console</a></li>    \n                    <li>构建  Url ： <a href=\"${BUILD_URL}\">${BUILD_URL}</a></li>    \n                    <li>工作目录 ： <a href=\"${PROJECT_URL}ws\">${PROJECT_URL}ws</a></li>    \n                    <li>项目  Url ： <a href=\"${PROJECT_URL}\">${PROJECT_URL}</a></li>    \n                </ul>    \n\n<h4><font color=\"#0B610B\">失败用例</font></h4>\n<hr size=\"2\" width=\"100%\" />\n$FAILED_TESTS<br/>\n\n<h4><font color=\"#0B610B\">最近提交(#$SVN_REVISION)</font></h4>\n<hr size=\"2\" width=\"100%\" />\n<ul>\n${CHANGES_SINCE_LAST_SUCCESS, reverse=true, format=\"%c\", changesFormat=\"<li>%d [%a] %m</li>\"}\n</ul>\n详细提交: <a href=\"${PROJECT_URL}changes\">${PROJECT_URL}changes</a><br/>\n\n            </td>    \n        </tr>    \n    </table>    \n</body>    \n</html>\n```\n\n如下图：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8b10b649f4943e1944fc094c72a3d2e~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 3.3 触发条件配置\n\n我们还可以在`Default Triggers`中根据自己的需要配置邮件的触发条件\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4328af1e2934c81b61f8c0429b6313b~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16835dfc64334f0e93a6cb7fd262922a~tplv-k3u1fbpfcp-watermark.image?)\n\n>这里为了防止因为构建一直尝试结果均为失败而造成的邮件轰炸，可以设置邮件仅第一次或第二次构建结果为失败时才发送邮件，后续失败的邮件将不再发送。我选择的是每一次失败和构建成功都会发邮件通知\n\n#### 3.4 jenkins的任务中配置邮件通知\n\n1. 在对应的任务中的构建设置中，勾选`E-mail Notification Recipients`\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/224fb406029d46d489cb6192848fdb6e~tplv-k3u1fbpfcp-watermark.image?)\n\n2. 在对应的任务中的构建后操作中，下拉选择`Editable Email Notification`\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1abc14189c874a818e5fe42a90371e43~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/594c71d3301544e48f6cc7468724b964~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b633844afb7a43e488cd3ab81d7c08a9~tplv-k3u1fbpfcp-watermark.image?)\n\n至此，jnekins的自动化构建的邮件通知已配置完成，在gitlab点击push event发起构建进行测试。\n\n发送成功的话，可看到如下图的提示：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a26d60de670c48ca991975dc2d20fa20~tplv-k3u1fbpfcp-watermark.image?)\n\n## 总结\n\n经过多款插件的安装配置，逐步掌握了如何上床Spring Boot项目到Gitlab中，并使用Jenkins自动构建任务，另外依托于Docker，让这一切变得更加方便，希望大家都多多思考，让机器自动干活，减少我们IT从业人员的重复、繁琐的工作量。\n\n\n', '小白学习gitlab+jenkins进行自动化构建(docker)之springboot项目', 0, 7, 2, 9, 0, '2023-06-09 16:56:30', '2023-06-09 16:56:30', 0);

-- ----------------------------
-- Table structure for tb_article_category
-- ----------------------------
DROP TABLE IF EXISTS `tb_article_category`;
CREATE TABLE `tb_article_category`  (
  `categoryId` int(12) NOT NULL AUTO_INCREMENT COMMENT '文章类别id',
  `categoryName` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '类别名称',
  `createTime` datetime NOT NULL COMMENT '创建时间',
  `updateTime` datetime NOT NULL COMMENT '更新时间',
  `delFlag` smallint(2) NOT NULL COMMENT '删除(0:未删除,1:已删除)',
  PRIMARY KEY (`categoryId`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 5 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tb_article_category
-- ----------------------------
INSERT INTO `tb_article_category` VALUES (1, '前端', '2023-06-07 12:31:04', '2023-06-07 13:43:58', 0);
INSERT INTO `tb_article_category` VALUES (2, '后端', '2023-06-07 12:31:28', '2023-06-07 12:31:28', 0);
INSERT INTO `tb_article_category` VALUES (3, 'Android', '2023-06-07 12:31:41', '2023-06-07 12:31:41', 0);
INSERT INTO `tb_article_category` VALUES (4, 'iOS', '2023-06-07 12:31:47', '2023-06-07 13:18:45', 0);

-- ----------------------------
-- Table structure for tb_authority
-- ----------------------------
DROP TABLE IF EXISTS `tb_authority`;
CREATE TABLE `tb_authority`  (
  `authorityId` int(12) NOT NULL AUTO_INCREMENT,
  `authority` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '权限',
  PRIMARY KEY (`authorityId`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of tb_authority
-- ----------------------------

-- ----------------------------
-- Table structure for tb_client
-- ----------------------------
DROP TABLE IF EXISTS `tb_client`;
CREATE TABLE `tb_client`  (
  `client_id` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '客户端id',
  `resource_ids` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '资源id',
  `client_secret` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '客户端密钥（已加密）',
  `plain_client_secret` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '客户端密钥（未加密）',
  `scope` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '权限范围',
  `authorized_grant_types` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '支持的授权类型',
  `web_server_redirect_uri` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '登录成功后的重定向地址',
  `authorities` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '权限',
  `access_token_validity` int(11) NULL DEFAULT NULL COMMENT 'acessToken有效时长',
  `refresh_token_validity` int(11) NULL DEFAULT NULL COMMENT 'refreshToken有效时长',
  `additional_information` varchar(4096) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '额外信息',
  `autoapprove` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '是否自动授权',
  `createTime` datetime NOT NULL COMMENT '创建日期',
  `updateTime` datetime NOT NULL COMMENT '更新日期',
  `delFlag` smallint(2) NOT NULL COMMENT '删除状态(0未删除，1已删除)',
  PRIMARY KEY (`client_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of tb_client
-- ----------------------------
INSERT INTO `tb_client` VALUES ('client1', 'client-resource', '$10$/Ci6DDwsvM6/dk9XOkPivuCCX.5WCLDM2H4VchKLyee4NIZdIVapW', '123456', 'user_base,all', 'authorization_code,password,client_credentials,implicit,refresh_token,sms_code,captcha', 'http://localhost:8080/#/login', NULL, 300, 1500, NULL, 'false', '2023-01-28 11:30:12', '2023-01-28 11:30:16', 0);

-- ----------------------------
-- Table structure for tb_file
-- ----------------------------
DROP TABLE IF EXISTS `tb_file`;
CREATE TABLE `tb_file`  (
  `fileId` int(11) NOT NULL AUTO_INCREMENT COMMENT '文件id',
  `fileMd5` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '文件的MD5',
  `fileName` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '文件名',
  `uploadStatus` int(2) NOT NULL COMMENT '上传状态 0.上传完成而且合并成功   1.已上传部分  2 分片全部上传完成仅需合并',
  `uploadUrl` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '文件上传后可访问的完整地址(ip或域名+文件地址+参数)',
  `path` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '文件地址',
  `suffix` varchar(12) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '文件类型',
  `chunkCount` bigint(64) NOT NULL,
  `userId` int(11) NOT NULL COMMENT '上传文件的用户id',
  `createTime` datetime NOT NULL COMMENT '文件上传日期',
  `updateTime` datetime NOT NULL COMMENT '文件更新日期',
  `expireTime` bigint(20) NULL DEFAULT NULL COMMENT '文件过期时间',
  PRIMARY KEY (`fileId`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 20 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of tb_file
-- ----------------------------
INSERT INTO `tb_file` VALUES (2, '980b8868abf8db32ab64adc685617368', 'default_avatar.svg', 0, 'http://101.35.44.70:9000/user-management/image/default_avatar.svg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=admin%2F20230607%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20230607T105245Z&X-Amz-Expires=604800&X-Amz-SignedHeaders=host&X-Amz-Signature=f8ca024c8f97e881c84ddb77b648e68287a6d9c8450e39736203531b8ca77048', '/user-management/image/default_avatar.svg', '.svg', 1, 2, '2023-06-07 18:52:46', '2023-06-07 18:52:46', 1686739965673);
INSERT INTO `tb_file` VALUES (4, '0b47f411c9e30d5a0964a980395a6b37', '545f84f52b32d49af76bfafae8160ab7.jpeg', 0, 'http://101.35.44.70:9000/user-management/image/545f84f52b32d49af76bfafae8160ab7.jpeg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=admin%2F20230608%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20230608T062748Z&X-Amz-Expires=604800&X-Amz-SignedHeaders=host&X-Amz-Signature=77527f3577fe330fd50b89afee21f7f7b357ec2a95b06bb8a0358b94f9ae475d', '/user-management/image/545f84f52b32d49af76bfafae8160ab7.jpeg', '.jpeg', 1, 2, '2023-06-08 14:27:48', '2023-06-08 14:27:48', 1686810468264);
INSERT INTO `tb_file` VALUES (5, '6505aabb80b3776456602b828897be4b', 'mmsgletter_2_bg_topline.png', 0, 'http://101.35.44.70:9000/user-management/image/mmsgletter_2_bg_topline.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=admin%2F20230609%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20230609T043010Z&X-Amz-Expires=604800&X-Amz-SignedHeaders=host&X-Amz-Signature=80b717b3a9811bb3f77b580c718a6e05a756f9d172d143b3d06f8f020a8a89de', '/user-management/image/mmsgletter_2_bg_topline.png', '.png', 1, 9, '2023-06-09 12:30:10', '2023-06-09 12:30:10', 1686889810029);
INSERT INTO `tb_file` VALUES (6, '3fedde5c356ce3c0d568fbf9e2bfbe4d', '857670b8b94c3f5f375cdecfae704cee.jpeg', 0, 'http://101.35.44.70:9000/user-management/image/857670b8b94c3f5f375cdecfae704cee.jpeg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=admin%2F20230609%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20230609T043523Z&X-Amz-Expires=604800&X-Amz-SignedHeaders=host&X-Amz-Signature=ab30ecb40cee7e85df7e5819e0f0dac326fb3174f8ed77aa31fc899d6e2ea9de', '/user-management/image/857670b8b94c3f5f375cdecfae704cee.jpeg', '.jpeg', 1, 9, '2023-06-09 12:35:24', '2023-06-09 12:35:24', 1686890123767);
INSERT INTO `tb_file` VALUES (7, '407113a2f65f5242b82cd71001e4be1b', 'avatar.jpg', 0, 'http://101.35.44.70:9000/user-management/image/avatar.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=admin%2F20230609%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20230609T085610Z&X-Amz-Expires=604800&X-Amz-SignedHeaders=host&X-Amz-Signature=b0caea22cde1b70865de9863a7a7ceaeed662a7a40d05a7a3d81ce8c018280d6', '/user-management/image/avatar.jpg', '.jpg', 1, 9, '2023-06-09 16:56:10', '2023-06-09 16:56:10', 1686905770311);
INSERT INTO `tb_file` VALUES (11, '4c00d93e2c67feae23ec011866acfdeb', 'image/75708eb5-b03b34de.mp4', 0, 'http://101.35.44.70:9000/user-management/image/75708eb5-b03b34de.mp4?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=admin%2F20230622%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20230622T031512Z&X-Amz-Expires=604800&X-Amz-SignedHeaders=host&X-Amz-Signature=7a2c1d3914808178002ec3ea7881bbb2459fb684e2d668ac69e75b88aa8a255f', '/user-management/image/75708eb5-b03b34de.mp4', '.mp4', 2, 2, '2023-06-22 11:15:12', '2023-06-22 11:15:12', 1688008512149);
INSERT INTO `tb_file` VALUES (12, 'a87edcbdc7518700b8105d26e87c345b', 'image/navicat150_premium_cs_x64.exe', 0, 'http://101.35.44.70:9000/user-management/image/navicat150_premium_cs_x64.exe?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=admin%2F20230622%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20230622T031751Z&X-Amz-Expires=604800&X-Amz-SignedHeaders=host&X-Amz-Signature=e05f5026cce4666ad0c8e3dc17f569aeb7f9ab3e9ac2a9fafd7f43dc1bcb1635', '/user-management/image/navicat150_premium_cs_x64.exe', '.exe', 12, 2, '2023-06-22 11:17:52', '2023-06-22 11:17:52', 1688008671968);
INSERT INTO `tb_file` VALUES (13, '8678966cc7a98dbb06a2ac1478fe5c25', 'image/77974cbf.mp4', 0, 'http://101.35.44.70:9000/user-management/image/77974cbf.mp4?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=admin%2F20230622%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20230622T035157Z&X-Amz-Expires=604800&X-Amz-SignedHeaders=host&X-Amz-Signature=574954149c9224013a753e7acbee0e0912616db7cb47190e595d07659dc343b7', '/user-management/image/77974cbf.mp4', '.mp4', 2, 2, '2023-06-22 11:51:58', '2023-06-22 11:51:58', 1688010717673);
INSERT INTO `tb_file` VALUES (14, '970adb3be1c02362982f2144a3124f29', 'image/authorization.sql', 0, 'http://101.35.44.70:9000/user-management/image/authorization.sql?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=admin%2F20230622%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20230622T044411Z&X-Amz-Expires=604800&X-Amz-SignedHeaders=host&X-Amz-Signature=af23771b98f618de814a723d991ea06dfb4b5112e7e3a6676c83e0d1fdf7eee1', '/user-management/image/authorization.sql', '.sql', 1, 2, '2023-06-22 12:44:11', '2023-06-22 12:44:11', 1688013851352);
INSERT INTO `tb_file` VALUES (19, '907c018434990b1ef8c39340fcaa1df1', 'image/nvm-setup.exe', 0, 'http://101.35.44.70:9000/user-management/image/nvm-setup.exe?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=admin%2F20230715%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20230715T033510Z&X-Amz-Expires=604800&X-Amz-SignedHeaders=host&X-Amz-Signature=804fdd7994ac125f8fcc83a71fb2deebdb0d883295407cba7e57bb53f0f97ecb', '/user-management/image/nvm-setup.exe', '.exe', 2, 9, '2023-07-15 11:35:10', '2023-07-15 11:35:10', 1689996910219);

-- ----------------------------
-- Table structure for tb_role
-- ----------------------------
DROP TABLE IF EXISTS `tb_role`;
CREATE TABLE `tb_role`  (
  `roleId` int(12) NOT NULL AUTO_INCREMENT,
  `roleName` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '角色名称',
  `remark` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '角色备注',
  `delFlag` smallint(2) NOT NULL COMMENT '删除状态(0为未删除，1为已删除)',
  `createTime` datetime NOT NULL COMMENT '角色创建日期',
  `updateTime` datetime NOT NULL COMMENT '角色修改日期',
  PRIMARY KEY (`roleId`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 5 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of tb_role
-- ----------------------------
INSERT INTO `tb_role` VALUES (2, 'ROLE_user', '普通用户', 0, '2023-01-12 16:07:06', '2023-01-12 23:05:58');
INSERT INTO `tb_role` VALUES (3, 'ROLE_superAdmin', '超级管理员', 0, '2023-01-12 16:07:11', '2023-01-12 16:07:13');
INSERT INTO `tb_role` VALUES (4, 'ROLE_admin', '管理员', 0, '2023-01-12 22:16:07', '2023-01-12 22:16:07');

-- ----------------------------
-- Table structure for tb_subject
-- ----------------------------
DROP TABLE IF EXISTS `tb_subject`;
CREATE TABLE `tb_subject`  (
  `subjectId` int(12) NOT NULL AUTO_INCREMENT COMMENT '主体类型id',
  `subjectName` varchar(16) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '主体类型名',
  PRIMARY KEY (`subjectId`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 3 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of tb_subject
-- ----------------------------
INSERT INTO `tb_subject` VALUES (1, '企业');
INSERT INTO `tb_subject` VALUES (2, '个人');

-- ----------------------------
-- Table structure for tb_user
-- ----------------------------
DROP TABLE IF EXISTS `tb_user`;
CREATE TABLE `tb_user`  (
  `userId` int(12) NOT NULL AUTO_INCREMENT,
  `realName` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '用户真实姓名',
  `username` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '用户名',
  `password` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '密码',
  `sex` smallint(4) NOT NULL COMMENT '用户性别(0为男，1为女)',
  `age` int(12) NOT NULL COMMENT '用户年龄',
  `phone` varchar(16) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '手机号',
  `email` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '邮箱',
  `audited` smallint(4) NOT NULL COMMENT '是否已审核(0为待审核，1为审核通过，2为审核失败)',
  `deleted` smallint(4) NOT NULL COMMENT '用户是否被删除(0为未删除，1为已删除)',
  `createTime` datetime NOT NULL COMMENT '用户创建日期',
  `updateTime` datetime NOT NULL COMMENT '用户更新日期',
  PRIMARY KEY (`userId`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 10 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of tb_user
-- ----------------------------
INSERT INTO `tb_user` VALUES (2, NULL, 'superAdmin', '$2a$10$4S2LpgFsnp56ujRZuSLiV.SY.dbTx1ccLmystccELtgOpu4CDzkee', 0, 22, '15300484341', NULL, 0, 0, '2023-01-11 11:58:52', '2023-01-11 11:59:00');
INSERT INTO `tb_user` VALUES (9, NULL, '3096015076@qq.com', '$2a$10$SUdrmI9QvHAw27RMispg2eLGatyym75j6GdoIzdNZ65WmkZTvKSIu', 0, 22, '15300484341', '3096015076@qq.com', 2, 0, '2023-01-11 11:59:04', '2023-01-16 13:24:24');

-- ----------------------------
-- Table structure for tb_user_app
-- ----------------------------
DROP TABLE IF EXISTS `tb_user_app`;
CREATE TABLE `tb_user_app`  (
  `userId` int(12) NOT NULL COMMENT '用户id',
  `appId` int(12) NOT NULL COMMENT '应用id',
  `delFlag` smallint(2) NOT NULL COMMENT '删除状态(0为未删除，1为已删除)',
  `createTime` datetime NOT NULL COMMENT '创建日期',
  `updateTime` datetime NOT NULL COMMENT '更新日期',
  PRIMARY KEY (`userId`, `appId`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of tb_user_app
-- ----------------------------
INSERT INTO `tb_user_app` VALUES (2, 5, 0, '2023-01-29 14:24:43', '2023-01-29 14:24:46');
INSERT INTO `tb_user_app` VALUES (9, 4, 0, '2023-01-29 14:24:49', '2023-01-31 09:54:37');
INSERT INTO `tb_user_app` VALUES (9, 6, 0, '2023-01-29 14:24:54', '2023-01-31 09:55:44');
INSERT INTO `tb_user_app` VALUES (9, 8, 0, '2023-01-31 18:01:41', '2023-01-31 18:01:41');
INSERT INTO `tb_user_app` VALUES (9, 9, 0, '2023-01-31 18:01:48', '2023-01-31 18:01:48');
INSERT INTO `tb_user_app` VALUES (9, 10, 0, '2023-01-31 18:01:53', '2023-01-31 18:01:53');
INSERT INTO `tb_user_app` VALUES (9, 11, 0, '2023-01-31 18:01:57', '2023-01-31 18:01:57');
INSERT INTO `tb_user_app` VALUES (9, 12, 0, '2023-01-31 18:02:01', '2023-01-31 18:02:01');
INSERT INTO `tb_user_app` VALUES (9, 13, 0, '2023-01-31 18:02:05', '2023-01-31 18:02:05');
INSERT INTO `tb_user_app` VALUES (9, 14, 0, '2023-01-31 18:02:10', '2023-01-31 18:02:10');
INSERT INTO `tb_user_app` VALUES (9, 15, 0, '2023-01-31 18:02:14', '2023-01-31 18:02:14');
INSERT INTO `tb_user_app` VALUES (9, 16, 0, '2023-01-31 18:02:18', '2023-01-31 18:02:18');
INSERT INTO `tb_user_app` VALUES (9, 17, 0, '2023-01-31 18:02:27', '2023-01-31 18:02:27');
INSERT INTO `tb_user_app` VALUES (9, 18, 0, '2023-01-31 18:02:31', '2023-01-31 18:02:31');
INSERT INTO `tb_user_app` VALUES (9, 19, 0, '2023-01-31 18:02:35', '2023-01-31 18:02:35');
INSERT INTO `tb_user_app` VALUES (9, 20, 0, '2023-01-31 18:02:40', '2023-01-31 18:02:40');
INSERT INTO `tb_user_app` VALUES (9, 21, 0, '2023-01-31 18:02:44', '2023-01-31 18:02:44');
INSERT INTO `tb_user_app` VALUES (9, 22, 0, '2023-01-31 18:02:47', '2023-01-31 18:02:47');

-- ----------------------------
-- Table structure for tb_user_authority
-- ----------------------------
DROP TABLE IF EXISTS `tb_user_authority`;
CREATE TABLE `tb_user_authority`  (
  `userId` int(12) NOT NULL COMMENT '用户id',
  `authorityId` int(12) NOT NULL COMMENT '权限id',
  PRIMARY KEY (`userId`, `authorityId`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of tb_user_authority
-- ----------------------------

-- ----------------------------
-- Table structure for tb_user_client
-- ----------------------------
DROP TABLE IF EXISTS `tb_user_client`;
CREATE TABLE `tb_user_client`  (
  `userId` int(12) NOT NULL COMMENT '用户id',
  `clientId` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '客户端id',
  PRIMARY KEY (`userId`, `clientId`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of tb_user_client
-- ----------------------------

-- ----------------------------
-- Table structure for tb_user_role
-- ----------------------------
DROP TABLE IF EXISTS `tb_user_role`;
CREATE TABLE `tb_user_role`  (
  `userId` int(12) NOT NULL COMMENT '用户id',
  `roleId` int(12) NOT NULL COMMENT '角色id',
  PRIMARY KEY (`userId`, `roleId`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of tb_user_role
-- ----------------------------
INSERT INTO `tb_user_role` VALUES (2, 3);
INSERT INTO `tb_user_role` VALUES (9, 2);

-- ----------------------------
-- Table structure for tb_user_subject
-- ----------------------------
DROP TABLE IF EXISTS `tb_user_subject`;
CREATE TABLE `tb_user_subject`  (
  `userId` int(12) NOT NULL COMMENT '用户id',
  `subjectId` int(12) NOT NULL COMMENT '用户类型id',
  PRIMARY KEY (`userId`, `subjectId`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of tb_user_subject
-- ----------------------------
INSERT INTO `tb_user_subject` VALUES (9, 2);

SET FOREIGN_KEY_CHECKS = 1;
